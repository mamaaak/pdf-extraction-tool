"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/reselect";
exports.ids = ["vendor-chunks/reselect"];
exports.modules = {

/***/ "(ssr)/./node_modules/reselect/dist/reselect.mjs":
/*!*************************************************!*\
  !*** ./node_modules/reselect/dist/reselect.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSelector: () => (/* binding */ createSelector),\n/* harmony export */   createSelectorCreator: () => (/* binding */ createSelectorCreator),\n/* harmony export */   createStructuredSelector: () => (/* binding */ createStructuredSelector),\n/* harmony export */   lruMemoize: () => (/* binding */ lruMemoize),\n/* harmony export */   referenceEqualityCheck: () => (/* binding */ referenceEqualityCheck),\n/* harmony export */   setGlobalDevModeChecks: () => (/* binding */ setGlobalDevModeChecks),\n/* harmony export */   unstable_autotrackMemoize: () => (/* binding */ autotrackMemoize),\n/* harmony export */   weakMapMemoize: () => (/* binding */ weakMapMemoize)\n/* harmony export */ });\n// src/devModeChecks/identityFunctionCheck.ts\r\nvar runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult) => {\r\n  if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {\r\n    let isInputSameAsOutput = false;\r\n    try {\r\n      const emptyObject = {};\r\n      if (resultFunc(emptyObject) === emptyObject)\r\n        isInputSameAsOutput = true;\r\n    } catch {\r\n    }\r\n    if (isInputSameAsOutput) {\r\n      let stack = void 0;\r\n      try {\r\n        throw new Error();\r\n      } catch (e) {\r\n        ;\r\n        ({ stack } = e);\r\n      }\r\n      console.warn(\r\n        \"The result function returned its own inputs without modification. e.g\\n`createSelector([state => state.todos], todos => todos)`\\nThis could lead to inefficient memoization and unnecessary re-renders.\\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.\",\r\n        { stack }\r\n      );\r\n    }\r\n  }\r\n};\r\n\r\n// src/devModeChecks/inputStabilityCheck.ts\r\nvar runInputStabilityCheck = (inputSelectorResultsObject, options, inputSelectorArgs) => {\r\n  const { memoize, memoizeOptions } = options;\r\n  const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;\r\n  const createAnEmptyObject = memoize(() => ({}), ...memoizeOptions);\r\n  const areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);\r\n  if (!areInputSelectorResultsEqual) {\r\n    let stack = void 0;\r\n    try {\r\n      throw new Error();\r\n    } catch (e) {\r\n      ;\r\n      ({ stack } = e);\r\n    }\r\n    console.warn(\r\n      \"An input selector returned a different result when passed same arguments.\\nThis means your output selector will likely run more frequently than intended.\\nAvoid returning a new reference inside your input selector, e.g.\\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`\",\r\n      {\r\n        arguments: inputSelectorArgs,\r\n        firstInputs: inputSelectorResults,\r\n        secondInputs: inputSelectorResultsCopy,\r\n        stack\r\n      }\r\n    );\r\n  }\r\n};\r\n\r\n// src/devModeChecks/setGlobalDevModeChecks.ts\r\nvar globalDevModeChecks = {\r\n  inputStabilityCheck: \"once\",\r\n  identityFunctionCheck: \"once\"\r\n};\r\nvar setGlobalDevModeChecks = (devModeChecks) => {\r\n  Object.assign(globalDevModeChecks, devModeChecks);\r\n};\r\n\r\n// src/utils.ts\r\nvar NOT_FOUND = /* @__PURE__ */ Symbol(\"NOT_FOUND\");\r\nfunction assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {\r\n  if (typeof func !== \"function\") {\r\n    throw new TypeError(errorMessage);\r\n  }\r\n}\r\nfunction assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {\r\n  if (typeof object !== \"object\") {\r\n    throw new TypeError(errorMessage);\r\n  }\r\n}\r\nfunction assertIsArrayOfFunctions(array, errorMessage = `expected all items to be functions, instead received the following types: `) {\r\n  if (!array.every((item) => typeof item === \"function\")) {\r\n    const itemTypes = array.map(\r\n      (item) => typeof item === \"function\" ? `function ${item.name || \"unnamed\"}()` : typeof item\r\n    ).join(\", \");\r\n    throw new TypeError(`${errorMessage}[${itemTypes}]`);\r\n  }\r\n}\r\nvar ensureIsArray = (item) => {\r\n  return Array.isArray(item) ? item : [item];\r\n};\r\nfunction getDependencies(createSelectorArgs) {\r\n  const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;\r\n  assertIsArrayOfFunctions(\r\n    dependencies,\r\n    `createSelector expects all input-selectors to be functions, but received the following types: `\r\n  );\r\n  return dependencies;\r\n}\r\nfunction collectInputSelectorResults(dependencies, inputSelectorArgs) {\r\n  const inputSelectorResults = [];\r\n  const { length } = dependencies;\r\n  for (let i = 0; i < length; i++) {\r\n    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));\r\n  }\r\n  return inputSelectorResults;\r\n}\r\nvar getDevModeChecksExecutionInfo = (firstRun, devModeChecks) => {\r\n  const { identityFunctionCheck, inputStabilityCheck } = {\r\n    ...globalDevModeChecks,\r\n    ...devModeChecks\r\n  };\r\n  return {\r\n    identityFunctionCheck: {\r\n      shouldRun: identityFunctionCheck === \"always\" || identityFunctionCheck === \"once\" && firstRun,\r\n      run: runIdentityFunctionCheck\r\n    },\r\n    inputStabilityCheck: {\r\n      shouldRun: inputStabilityCheck === \"always\" || inputStabilityCheck === \"once\" && firstRun,\r\n      run: runInputStabilityCheck\r\n    }\r\n  };\r\n};\r\n\r\n// src/autotrackMemoize/autotracking.ts\r\nvar $REVISION = 0;\r\nvar CURRENT_TRACKER = null;\r\nvar Cell = class {\r\n  revision = $REVISION;\r\n  _value;\r\n  _lastValue;\r\n  _isEqual = tripleEq;\r\n  constructor(initialValue, isEqual = tripleEq) {\r\n    this._value = this._lastValue = initialValue;\r\n    this._isEqual = isEqual;\r\n  }\r\n  // Whenever a storage value is read, it'll add itself to the current tracker if\r\n  // one exists, entangling its state with that cache.\r\n  get value() {\r\n    CURRENT_TRACKER?.add(this);\r\n    return this._value;\r\n  }\r\n  // Whenever a storage value is updated, we bump the global revision clock,\r\n  // assign the revision for this storage to the new value, _and_ we schedule a\r\n  // rerender. This is important, and it's what makes autotracking  _pull_\r\n  // based. We don't actively tell the caches which depend on the storage that\r\n  // anything has happened. Instead, we recompute the caches when needed.\r\n  set value(newValue) {\r\n    if (this.value === newValue)\r\n      return;\r\n    this._value = newValue;\r\n    this.revision = ++$REVISION;\r\n  }\r\n};\r\nfunction tripleEq(a, b) {\r\n  return a === b;\r\n}\r\nvar TrackingCache = class {\r\n  _cachedValue;\r\n  _cachedRevision = -1;\r\n  _deps = [];\r\n  hits = 0;\r\n  fn;\r\n  constructor(fn) {\r\n    this.fn = fn;\r\n  }\r\n  clear() {\r\n    this._cachedValue = void 0;\r\n    this._cachedRevision = -1;\r\n    this._deps = [];\r\n    this.hits = 0;\r\n  }\r\n  get value() {\r\n    if (this.revision > this._cachedRevision) {\r\n      const { fn } = this;\r\n      const currentTracker = /* @__PURE__ */ new Set();\r\n      const prevTracker = CURRENT_TRACKER;\r\n      CURRENT_TRACKER = currentTracker;\r\n      this._cachedValue = fn();\r\n      CURRENT_TRACKER = prevTracker;\r\n      this.hits++;\r\n      this._deps = Array.from(currentTracker);\r\n      this._cachedRevision = this.revision;\r\n    }\r\n    CURRENT_TRACKER?.add(this);\r\n    return this._cachedValue;\r\n  }\r\n  get revision() {\r\n    return Math.max(...this._deps.map((d) => d.revision), 0);\r\n  }\r\n};\r\nfunction getValue(cell) {\r\n  if (!(cell instanceof Cell)) {\r\n    console.warn(\"Not a valid cell! \", cell);\r\n  }\r\n  return cell.value;\r\n}\r\nfunction setValue(storage, value) {\r\n  if (!(storage instanceof Cell)) {\r\n    throw new TypeError(\r\n      \"setValue must be passed a tracked store created with `createStorage`.\"\r\n    );\r\n  }\r\n  storage.value = storage._lastValue = value;\r\n}\r\nfunction createCell(initialValue, isEqual = tripleEq) {\r\n  return new Cell(initialValue, isEqual);\r\n}\r\nfunction createCache(fn) {\r\n  assertIsFunction(\r\n    fn,\r\n    \"the first parameter to `createCache` must be a function\"\r\n  );\r\n  return new TrackingCache(fn);\r\n}\r\n\r\n// src/autotrackMemoize/tracking.ts\r\nvar neverEq = (a, b) => false;\r\nfunction createTag() {\r\n  return createCell(null, neverEq);\r\n}\r\nfunction dirtyTag(tag, value) {\r\n  setValue(tag, value);\r\n}\r\nvar consumeCollection = (node) => {\r\n  let tag = node.collectionTag;\r\n  if (tag === null) {\r\n    tag = node.collectionTag = createTag();\r\n  }\r\n  getValue(tag);\r\n};\r\nvar dirtyCollection = (node) => {\r\n  const tag = node.collectionTag;\r\n  if (tag !== null) {\r\n    dirtyTag(tag, null);\r\n  }\r\n};\r\n\r\n// src/autotrackMemoize/proxy.ts\r\nvar REDUX_PROXY_LABEL = Symbol();\r\nvar nextId = 0;\r\nvar proto = Object.getPrototypeOf({});\r\nvar ObjectTreeNode = class {\r\n  constructor(value) {\r\n    this.value = value;\r\n    this.value = value;\r\n    this.tag.value = value;\r\n  }\r\n  proxy = new Proxy(this, objectProxyHandler);\r\n  tag = createTag();\r\n  tags = {};\r\n  children = {};\r\n  collectionTag = null;\r\n  id = nextId++;\r\n};\r\nvar objectProxyHandler = {\r\n  get(node, key) {\r\n    function calculateResult() {\r\n      const { value } = node;\r\n      const childValue = Reflect.get(value, key);\r\n      if (typeof key === \"symbol\") {\r\n        return childValue;\r\n      }\r\n      if (key in proto) {\r\n        return childValue;\r\n      }\r\n      if (typeof childValue === \"object\" && childValue !== null) {\r\n        let childNode = node.children[key];\r\n        if (childNode === void 0) {\r\n          childNode = node.children[key] = createNode(childValue);\r\n        }\r\n        if (childNode.tag) {\r\n          getValue(childNode.tag);\r\n        }\r\n        return childNode.proxy;\r\n      } else {\r\n        let tag = node.tags[key];\r\n        if (tag === void 0) {\r\n          tag = node.tags[key] = createTag();\r\n          tag.value = childValue;\r\n        }\r\n        getValue(tag);\r\n        return childValue;\r\n      }\r\n    }\r\n    const res = calculateResult();\r\n    return res;\r\n  },\r\n  ownKeys(node) {\r\n    consumeCollection(node);\r\n    return Reflect.ownKeys(node.value);\r\n  },\r\n  getOwnPropertyDescriptor(node, prop) {\r\n    return Reflect.getOwnPropertyDescriptor(node.value, prop);\r\n  },\r\n  has(node, prop) {\r\n    return Reflect.has(node.value, prop);\r\n  }\r\n};\r\nvar ArrayTreeNode = class {\r\n  constructor(value) {\r\n    this.value = value;\r\n    this.value = value;\r\n    this.tag.value = value;\r\n  }\r\n  proxy = new Proxy([this], arrayProxyHandler);\r\n  tag = createTag();\r\n  tags = {};\r\n  children = {};\r\n  collectionTag = null;\r\n  id = nextId++;\r\n};\r\nvar arrayProxyHandler = {\r\n  get([node], key) {\r\n    if (key === \"length\") {\r\n      consumeCollection(node);\r\n    }\r\n    return objectProxyHandler.get(node, key);\r\n  },\r\n  ownKeys([node]) {\r\n    return objectProxyHandler.ownKeys(node);\r\n  },\r\n  getOwnPropertyDescriptor([node], prop) {\r\n    return objectProxyHandler.getOwnPropertyDescriptor(node, prop);\r\n  },\r\n  has([node], prop) {\r\n    return objectProxyHandler.has(node, prop);\r\n  }\r\n};\r\nfunction createNode(value) {\r\n  if (Array.isArray(value)) {\r\n    return new ArrayTreeNode(value);\r\n  }\r\n  return new ObjectTreeNode(value);\r\n}\r\nfunction updateNode(node, newValue) {\r\n  const { value, tags, children } = node;\r\n  node.value = newValue;\r\n  if (Array.isArray(value) && Array.isArray(newValue) && value.length !== newValue.length) {\r\n    dirtyCollection(node);\r\n  } else {\r\n    if (value !== newValue) {\r\n      let oldKeysSize = 0;\r\n      let newKeysSize = 0;\r\n      let anyKeysAdded = false;\r\n      for (const _key in value) {\r\n        oldKeysSize++;\r\n      }\r\n      for (const key in newValue) {\r\n        newKeysSize++;\r\n        if (!(key in value)) {\r\n          anyKeysAdded = true;\r\n          break;\r\n        }\r\n      }\r\n      const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize;\r\n      if (isDifferent) {\r\n        dirtyCollection(node);\r\n      }\r\n    }\r\n  }\r\n  for (const key in tags) {\r\n    const childValue = value[key];\r\n    const newChildValue = newValue[key];\r\n    if (childValue !== newChildValue) {\r\n      dirtyCollection(node);\r\n      dirtyTag(tags[key], newChildValue);\r\n    }\r\n    if (typeof newChildValue === \"object\" && newChildValue !== null) {\r\n      delete tags[key];\r\n    }\r\n  }\r\n  for (const key in children) {\r\n    const childNode = children[key];\r\n    const newChildValue = newValue[key];\r\n    const childValue = childNode.value;\r\n    if (childValue === newChildValue) {\r\n      continue;\r\n    } else if (typeof newChildValue === \"object\" && newChildValue !== null) {\r\n      updateNode(childNode, newChildValue);\r\n    } else {\r\n      deleteNode(childNode);\r\n      delete children[key];\r\n    }\r\n  }\r\n}\r\nfunction deleteNode(node) {\r\n  if (node.tag) {\r\n    dirtyTag(node.tag, null);\r\n  }\r\n  dirtyCollection(node);\r\n  for (const key in node.tags) {\r\n    dirtyTag(node.tags[key], null);\r\n  }\r\n  for (const key in node.children) {\r\n    deleteNode(node.children[key]);\r\n  }\r\n}\r\n\r\n// src/lruMemoize.ts\r\nfunction createSingletonCache(equals) {\r\n  let entry;\r\n  return {\r\n    get(key) {\r\n      if (entry && equals(entry.key, key)) {\r\n        return entry.value;\r\n      }\r\n      return NOT_FOUND;\r\n    },\r\n    put(key, value) {\r\n      entry = { key, value };\r\n    },\r\n    getEntries() {\r\n      return entry ? [entry] : [];\r\n    },\r\n    clear() {\r\n      entry = void 0;\r\n    }\r\n  };\r\n}\r\nfunction createLruCache(maxSize, equals) {\r\n  let entries = [];\r\n  function get(key) {\r\n    const cacheIndex = entries.findIndex((entry) => equals(key, entry.key));\r\n    if (cacheIndex > -1) {\r\n      const entry = entries[cacheIndex];\r\n      if (cacheIndex > 0) {\r\n        entries.splice(cacheIndex, 1);\r\n        entries.unshift(entry);\r\n      }\r\n      return entry.value;\r\n    }\r\n    return NOT_FOUND;\r\n  }\r\n  function put(key, value) {\r\n    if (get(key) === NOT_FOUND) {\r\n      entries.unshift({ key, value });\r\n      if (entries.length > maxSize) {\r\n        entries.pop();\r\n      }\r\n    }\r\n  }\r\n  function getEntries() {\r\n    return entries;\r\n  }\r\n  function clear() {\r\n    entries = [];\r\n  }\r\n  return { get, put, getEntries, clear };\r\n}\r\nvar referenceEqualityCheck = (a, b) => a === b;\r\nfunction createCacheKeyComparator(equalityCheck) {\r\n  return function areArgumentsShallowlyEqual(prev, next) {\r\n    if (prev === null || next === null || prev.length !== next.length) {\r\n      return false;\r\n    }\r\n    const { length } = prev;\r\n    for (let i = 0; i < length; i++) {\r\n      if (!equalityCheck(prev[i], next[i])) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n}\r\nfunction lruMemoize(func, equalityCheckOrOptions) {\r\n  const providedOptions = typeof equalityCheckOrOptions === \"object\" ? equalityCheckOrOptions : { equalityCheck: equalityCheckOrOptions };\r\n  const {\r\n    equalityCheck = referenceEqualityCheck,\r\n    maxSize = 1,\r\n    resultEqualityCheck\r\n  } = providedOptions;\r\n  const comparator = createCacheKeyComparator(equalityCheck);\r\n  let resultsCount = 0;\r\n  const cache = maxSize <= 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);\r\n  function memoized() {\r\n    let value = cache.get(arguments);\r\n    if (value === NOT_FOUND) {\r\n      value = func.apply(null, arguments);\r\n      resultsCount++;\r\n      if (resultEqualityCheck) {\r\n        const entries = cache.getEntries();\r\n        const matchingEntry = entries.find(\r\n          (entry) => resultEqualityCheck(entry.value, value)\r\n        );\r\n        if (matchingEntry) {\r\n          value = matchingEntry.value;\r\n          resultsCount !== 0 && resultsCount--;\r\n        }\r\n      }\r\n      cache.put(arguments, value);\r\n    }\r\n    return value;\r\n  }\r\n  memoized.clearCache = () => {\r\n    cache.clear();\r\n    memoized.resetResultsCount();\r\n  };\r\n  memoized.resultsCount = () => resultsCount;\r\n  memoized.resetResultsCount = () => {\r\n    resultsCount = 0;\r\n  };\r\n  return memoized;\r\n}\r\n\r\n// src/autotrackMemoize/autotrackMemoize.ts\r\nfunction autotrackMemoize(func) {\r\n  const node = createNode(\r\n    []\r\n  );\r\n  let lastArgs = null;\r\n  const shallowEqual = createCacheKeyComparator(referenceEqualityCheck);\r\n  const cache = createCache(() => {\r\n    const res = func.apply(null, node.proxy);\r\n    return res;\r\n  });\r\n  function memoized() {\r\n    if (!shallowEqual(lastArgs, arguments)) {\r\n      updateNode(node, arguments);\r\n      lastArgs = arguments;\r\n    }\r\n    return cache.value;\r\n  }\r\n  memoized.clearCache = () => {\r\n    return cache.clear();\r\n  };\r\n  return memoized;\r\n}\r\n\r\n// src/weakMapMemoize.ts\r\nvar StrongRef = class {\r\n  constructor(value) {\r\n    this.value = value;\r\n  }\r\n  deref() {\r\n    return this.value;\r\n  }\r\n};\r\nvar Ref = typeof WeakRef !== \"undefined\" ? WeakRef : StrongRef;\r\nvar UNTERMINATED = 0;\r\nvar TERMINATED = 1;\r\nfunction createCacheNode() {\r\n  return {\r\n    s: UNTERMINATED,\r\n    v: void 0,\r\n    o: null,\r\n    p: null\r\n  };\r\n}\r\nfunction weakMapMemoize(func, options = {}) {\r\n  let fnNode = createCacheNode();\r\n  const { resultEqualityCheck } = options;\r\n  let lastResult;\r\n  let resultsCount = 0;\r\n  function memoized() {\r\n    let cacheNode = fnNode;\r\n    const { length } = arguments;\r\n    for (let i = 0, l = length; i < l; i++) {\r\n      const arg = arguments[i];\r\n      if (typeof arg === \"function\" || typeof arg === \"object\" && arg !== null) {\r\n        let objectCache = cacheNode.o;\r\n        if (objectCache === null) {\r\n          cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();\r\n        }\r\n        const objectNode = objectCache.get(arg);\r\n        if (objectNode === void 0) {\r\n          cacheNode = createCacheNode();\r\n          objectCache.set(arg, cacheNode);\r\n        } else {\r\n          cacheNode = objectNode;\r\n        }\r\n      } else {\r\n        let primitiveCache = cacheNode.p;\r\n        if (primitiveCache === null) {\r\n          cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();\r\n        }\r\n        const primitiveNode = primitiveCache.get(arg);\r\n        if (primitiveNode === void 0) {\r\n          cacheNode = createCacheNode();\r\n          primitiveCache.set(arg, cacheNode);\r\n        } else {\r\n          cacheNode = primitiveNode;\r\n        }\r\n      }\r\n    }\r\n    const terminatedNode = cacheNode;\r\n    let result;\r\n    if (cacheNode.s === TERMINATED) {\r\n      result = cacheNode.v;\r\n    } else {\r\n      result = func.apply(null, arguments);\r\n      resultsCount++;\r\n      if (resultEqualityCheck) {\r\n        const lastResultValue = lastResult?.deref?.() ?? lastResult;\r\n        if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {\r\n          result = lastResultValue;\r\n          resultsCount !== 0 && resultsCount--;\r\n        }\r\n        const needsWeakRef = typeof result === \"object\" && result !== null || typeof result === \"function\";\r\n        lastResult = needsWeakRef ? new Ref(result) : result;\r\n      }\r\n    }\r\n    terminatedNode.s = TERMINATED;\r\n    terminatedNode.v = result;\r\n    return result;\r\n  }\r\n  memoized.clearCache = () => {\r\n    fnNode = createCacheNode();\r\n    memoized.resetResultsCount();\r\n  };\r\n  memoized.resultsCount = () => resultsCount;\r\n  memoized.resetResultsCount = () => {\r\n    resultsCount = 0;\r\n  };\r\n  return memoized;\r\n}\r\n\r\n// src/createSelectorCreator.ts\r\nfunction createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {\r\n  const createSelectorCreatorOptions = typeof memoizeOrOptions === \"function\" ? {\r\n    memoize: memoizeOrOptions,\r\n    memoizeOptions: memoizeOptionsFromArgs\r\n  } : memoizeOrOptions;\r\n  const createSelector2 = (...createSelectorArgs) => {\r\n    let recomputations = 0;\r\n    let dependencyRecomputations = 0;\r\n    let lastResult;\r\n    let directlyPassedOptions = {};\r\n    let resultFunc = createSelectorArgs.pop();\r\n    if (typeof resultFunc === \"object\") {\r\n      directlyPassedOptions = resultFunc;\r\n      resultFunc = createSelectorArgs.pop();\r\n    }\r\n    assertIsFunction(\r\n      resultFunc,\r\n      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`\r\n    );\r\n    const combinedOptions = {\r\n      ...createSelectorCreatorOptions,\r\n      ...directlyPassedOptions\r\n    };\r\n    const {\r\n      memoize,\r\n      memoizeOptions = [],\r\n      argsMemoize = weakMapMemoize,\r\n      argsMemoizeOptions = [],\r\n      devModeChecks = {}\r\n    } = combinedOptions;\r\n    const finalMemoizeOptions = ensureIsArray(memoizeOptions);\r\n    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);\r\n    const dependencies = getDependencies(createSelectorArgs);\r\n    const memoizedResultFunc = memoize(function recomputationWrapper() {\r\n      recomputations++;\r\n      return resultFunc.apply(\r\n        null,\r\n        arguments\r\n      );\r\n    }, ...finalMemoizeOptions);\r\n    let firstRun = true;\r\n    const selector = argsMemoize(function dependenciesChecker() {\r\n      dependencyRecomputations++;\r\n      const inputSelectorResults = collectInputSelectorResults(\r\n        dependencies,\r\n        arguments\r\n      );\r\n      lastResult = memoizedResultFunc.apply(null, inputSelectorResults);\r\n      if (true) {\r\n        const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);\r\n        if (identityFunctionCheck.shouldRun) {\r\n          identityFunctionCheck.run(\r\n            resultFunc,\r\n            inputSelectorResults,\r\n            lastResult\r\n          );\r\n        }\r\n        if (inputStabilityCheck.shouldRun) {\r\n          const inputSelectorResultsCopy = collectInputSelectorResults(\r\n            dependencies,\r\n            arguments\r\n          );\r\n          inputStabilityCheck.run(\r\n            { inputSelectorResults, inputSelectorResultsCopy },\r\n            { memoize, memoizeOptions: finalMemoizeOptions },\r\n            arguments\r\n          );\r\n        }\r\n        if (firstRun)\r\n          firstRun = false;\r\n      }\r\n      return lastResult;\r\n    }, ...finalArgsMemoizeOptions);\r\n    return Object.assign(selector, {\r\n      resultFunc,\r\n      memoizedResultFunc,\r\n      dependencies,\r\n      dependencyRecomputations: () => dependencyRecomputations,\r\n      resetDependencyRecomputations: () => {\r\n        dependencyRecomputations = 0;\r\n      },\r\n      lastResult: () => lastResult,\r\n      recomputations: () => recomputations,\r\n      resetRecomputations: () => {\r\n        recomputations = 0;\r\n      },\r\n      memoize,\r\n      argsMemoize\r\n    });\r\n  };\r\n  Object.assign(createSelector2, {\r\n    withTypes: () => createSelector2\r\n  });\r\n  return createSelector2;\r\n}\r\nvar createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);\r\n\r\n// src/createStructuredSelector.ts\r\nvar createStructuredSelector = Object.assign(\r\n  (inputSelectorsObject, selectorCreator = createSelector) => {\r\n    assertIsObject(\r\n      inputSelectorsObject,\r\n      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`\r\n    );\r\n    const inputSelectorKeys = Object.keys(inputSelectorsObject);\r\n    const dependencies = inputSelectorKeys.map(\r\n      (key) => inputSelectorsObject[key]\r\n    );\r\n    const structuredSelector = selectorCreator(\r\n      dependencies,\r\n      (...inputSelectorResults) => {\r\n        return inputSelectorResults.reduce((composition, value, index) => {\r\n          composition[inputSelectorKeys[index]] = value;\r\n          return composition;\r\n        }, {});\r\n      }\r\n    );\r\n    return structuredSelector;\r\n  },\r\n  { withTypes: () => createStructuredSelector }\r\n);\r\n\r\n//# sourceMappingURL=reselect.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVzZWxlY3QvZGlzdC9yZXNlbGVjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQkFBMEI7QUFDcEMsVUFBVSxpREFBaUQ7QUFDM0QsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxTQUFTLFFBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLFlBQVk7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsY0FBYztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx1QkFBdUI7QUFDaEY7QUFDQSwyQkFBMkIsYUFBYSxHQUFHLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZDQUE2QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLGtCQUFrQjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQyxnQkFBZ0IsNkNBQTZDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnREFBZ0Q7QUFDOUQsY0FBYyw4Q0FBOEM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0hBQStILDRCQUE0QjtBQUMzSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILElBQUk7QUFDSjtBQVVFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9yZXNlbGVjdC9kaXN0L3Jlc2VsZWN0Lm1qcz8yNzEzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9kZXZNb2RlQ2hlY2tzL2lkZW50aXR5RnVuY3Rpb25DaGVjay50c1xyXG52YXIgcnVuSWRlbnRpdHlGdW5jdGlvbkNoZWNrID0gKHJlc3VsdEZ1bmMsIGlucHV0U2VsZWN0b3JzUmVzdWx0cywgb3V0cHV0U2VsZWN0b3JSZXN1bHQpID0+IHtcclxuICBpZiAoaW5wdXRTZWxlY3RvcnNSZXN1bHRzLmxlbmd0aCA9PT0gMSAmJiBpbnB1dFNlbGVjdG9yc1Jlc3VsdHNbMF0gPT09IG91dHB1dFNlbGVjdG9yUmVzdWx0KSB7XHJcbiAgICBsZXQgaXNJbnB1dFNhbWVBc091dHB1dCA9IGZhbHNlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZW1wdHlPYmplY3QgPSB7fTtcclxuICAgICAgaWYgKHJlc3VsdEZ1bmMoZW1wdHlPYmplY3QpID09PSBlbXB0eU9iamVjdClcclxuICAgICAgICBpc0lucHV0U2FtZUFzT3V0cHV0ID0gdHJ1ZTtcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgfVxyXG4gICAgaWYgKGlzSW5wdXRTYW1lQXNPdXRwdXQpIHtcclxuICAgICAgbGV0IHN0YWNrID0gdm9pZCAwO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgO1xyXG4gICAgICAgICh7IHN0YWNrIH0gPSBlKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgXCJUaGUgcmVzdWx0IGZ1bmN0aW9uIHJldHVybmVkIGl0cyBvd24gaW5wdXRzIHdpdGhvdXQgbW9kaWZpY2F0aW9uLiBlLmdcXG5gY3JlYXRlU2VsZWN0b3IoW3N0YXRlID0+IHN0YXRlLnRvZG9zXSwgdG9kb3MgPT4gdG9kb3MpYFxcblRoaXMgY291bGQgbGVhZCB0byBpbmVmZmljaWVudCBtZW1vaXphdGlvbiBhbmQgdW5uZWNlc3NhcnkgcmUtcmVuZGVycy5cXG5FbnN1cmUgdHJhbnNmb3JtYXRpb24gbG9naWMgaXMgaW4gdGhlIHJlc3VsdCBmdW5jdGlvbiwgYW5kIGV4dHJhY3Rpb24gbG9naWMgaXMgaW4gdGhlIGlucHV0IHNlbGVjdG9ycy5cIixcclxuICAgICAgICB7IHN0YWNrIH1cclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4vLyBzcmMvZGV2TW9kZUNoZWNrcy9pbnB1dFN0YWJpbGl0eUNoZWNrLnRzXHJcbnZhciBydW5JbnB1dFN0YWJpbGl0eUNoZWNrID0gKGlucHV0U2VsZWN0b3JSZXN1bHRzT2JqZWN0LCBvcHRpb25zLCBpbnB1dFNlbGVjdG9yQXJncykgPT4ge1xyXG4gIGNvbnN0IHsgbWVtb2l6ZSwgbWVtb2l6ZU9wdGlvbnMgfSA9IG9wdGlvbnM7XHJcbiAgY29uc3QgeyBpbnB1dFNlbGVjdG9yUmVzdWx0cywgaW5wdXRTZWxlY3RvclJlc3VsdHNDb3B5IH0gPSBpbnB1dFNlbGVjdG9yUmVzdWx0c09iamVjdDtcclxuICBjb25zdCBjcmVhdGVBbkVtcHR5T2JqZWN0ID0gbWVtb2l6ZSgoKSA9PiAoe30pLCAuLi5tZW1vaXplT3B0aW9ucyk7XHJcbiAgY29uc3QgYXJlSW5wdXRTZWxlY3RvclJlc3VsdHNFcXVhbCA9IGNyZWF0ZUFuRW1wdHlPYmplY3QuYXBwbHkobnVsbCwgaW5wdXRTZWxlY3RvclJlc3VsdHMpID09PSBjcmVhdGVBbkVtcHR5T2JqZWN0LmFwcGx5KG51bGwsIGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSk7XHJcbiAgaWYgKCFhcmVJbnB1dFNlbGVjdG9yUmVzdWx0c0VxdWFsKSB7XHJcbiAgICBsZXQgc3RhY2sgPSB2b2lkIDA7XHJcbiAgICB0cnkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgO1xyXG4gICAgICAoeyBzdGFjayB9ID0gZSk7XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgIFwiQW4gaW5wdXQgc2VsZWN0b3IgcmV0dXJuZWQgYSBkaWZmZXJlbnQgcmVzdWx0IHdoZW4gcGFzc2VkIHNhbWUgYXJndW1lbnRzLlxcblRoaXMgbWVhbnMgeW91ciBvdXRwdXQgc2VsZWN0b3Igd2lsbCBsaWtlbHkgcnVuIG1vcmUgZnJlcXVlbnRseSB0aGFuIGludGVuZGVkLlxcbkF2b2lkIHJldHVybmluZyBhIG5ldyByZWZlcmVuY2UgaW5zaWRlIHlvdXIgaW5wdXQgc2VsZWN0b3IsIGUuZy5cXG5gY3JlYXRlU2VsZWN0b3IoW3N0YXRlID0+IHN0YXRlLnRvZG9zLm1hcCh0b2RvID0+IHRvZG8uaWQpXSwgdG9kb0lkcyA9PiB0b2RvSWRzLmxlbmd0aClgXCIsXHJcbiAgICAgIHtcclxuICAgICAgICBhcmd1bWVudHM6IGlucHV0U2VsZWN0b3JBcmdzLFxyXG4gICAgICAgIGZpcnN0SW5wdXRzOiBpbnB1dFNlbGVjdG9yUmVzdWx0cyxcclxuICAgICAgICBzZWNvbmRJbnB1dHM6IGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSxcclxuICAgICAgICBzdGFja1xyXG4gICAgICB9XHJcbiAgICApO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIHNyYy9kZXZNb2RlQ2hlY2tzL3NldEdsb2JhbERldk1vZGVDaGVja3MudHNcclxudmFyIGdsb2JhbERldk1vZGVDaGVja3MgPSB7XHJcbiAgaW5wdXRTdGFiaWxpdHlDaGVjazogXCJvbmNlXCIsXHJcbiAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiBcIm9uY2VcIlxyXG59O1xyXG52YXIgc2V0R2xvYmFsRGV2TW9kZUNoZWNrcyA9IChkZXZNb2RlQ2hlY2tzKSA9PiB7XHJcbiAgT2JqZWN0LmFzc2lnbihnbG9iYWxEZXZNb2RlQ2hlY2tzLCBkZXZNb2RlQ2hlY2tzKTtcclxufTtcclxuXHJcbi8vIHNyYy91dGlscy50c1xyXG52YXIgTk9UX0ZPVU5EID0gLyogQF9fUFVSRV9fICovIFN5bWJvbChcIk5PVF9GT1VORFwiKTtcclxuZnVuY3Rpb24gYXNzZXJ0SXNGdW5jdGlvbihmdW5jLCBlcnJvck1lc3NhZ2UgPSBgZXhwZWN0ZWQgYSBmdW5jdGlvbiwgaW5zdGVhZCByZWNlaXZlZCAke3R5cGVvZiBmdW5jfWApIHtcclxuICBpZiAodHlwZW9mIGZ1bmMgIT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihlcnJvck1lc3NhZ2UpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBhc3NlcnRJc09iamVjdChvYmplY3QsIGVycm9yTWVzc2FnZSA9IGBleHBlY3RlZCBhbiBvYmplY3QsIGluc3RlYWQgcmVjZWl2ZWQgJHt0eXBlb2Ygb2JqZWN0fWApIHtcclxuICBpZiAodHlwZW9mIG9iamVjdCAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihlcnJvck1lc3NhZ2UpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBhc3NlcnRJc0FycmF5T2ZGdW5jdGlvbnMoYXJyYXksIGVycm9yTWVzc2FnZSA9IGBleHBlY3RlZCBhbGwgaXRlbXMgdG8gYmUgZnVuY3Rpb25zLCBpbnN0ZWFkIHJlY2VpdmVkIHRoZSBmb2xsb3dpbmcgdHlwZXM6IGApIHtcclxuICBpZiAoIWFycmF5LmV2ZXJ5KChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PT0gXCJmdW5jdGlvblwiKSkge1xyXG4gICAgY29uc3QgaXRlbVR5cGVzID0gYXJyYXkubWFwKFxyXG4gICAgICAoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIiA/IGBmdW5jdGlvbiAke2l0ZW0ubmFtZSB8fCBcInVubmFtZWRcIn0oKWAgOiB0eXBlb2YgaXRlbVxyXG4gICAgKS5qb2luKFwiLCBcIik7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2Vycm9yTWVzc2FnZX1bJHtpdGVtVHlwZXN9XWApO1xyXG4gIH1cclxufVxyXG52YXIgZW5zdXJlSXNBcnJheSA9IChpdGVtKSA9PiB7XHJcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaXRlbSkgPyBpdGVtIDogW2l0ZW1dO1xyXG59O1xyXG5mdW5jdGlvbiBnZXREZXBlbmRlbmNpZXMoY3JlYXRlU2VsZWN0b3JBcmdzKSB7XHJcbiAgY29uc3QgZGVwZW5kZW5jaWVzID0gQXJyYXkuaXNBcnJheShjcmVhdGVTZWxlY3RvckFyZ3NbMF0pID8gY3JlYXRlU2VsZWN0b3JBcmdzWzBdIDogY3JlYXRlU2VsZWN0b3JBcmdzO1xyXG4gIGFzc2VydElzQXJyYXlPZkZ1bmN0aW9ucyhcclxuICAgIGRlcGVuZGVuY2llcyxcclxuICAgIGBjcmVhdGVTZWxlY3RvciBleHBlY3RzIGFsbCBpbnB1dC1zZWxlY3RvcnMgdG8gYmUgZnVuY3Rpb25zLCBidXQgcmVjZWl2ZWQgdGhlIGZvbGxvd2luZyB0eXBlczogYFxyXG4gICk7XHJcbiAgcmV0dXJuIGRlcGVuZGVuY2llcztcclxufVxyXG5mdW5jdGlvbiBjb2xsZWN0SW5wdXRTZWxlY3RvclJlc3VsdHMoZGVwZW5kZW5jaWVzLCBpbnB1dFNlbGVjdG9yQXJncykge1xyXG4gIGNvbnN0IGlucHV0U2VsZWN0b3JSZXN1bHRzID0gW107XHJcbiAgY29uc3QgeyBsZW5ndGggfSA9IGRlcGVuZGVuY2llcztcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICBpbnB1dFNlbGVjdG9yUmVzdWx0cy5wdXNoKGRlcGVuZGVuY2llc1tpXS5hcHBseShudWxsLCBpbnB1dFNlbGVjdG9yQXJncykpO1xyXG4gIH1cclxuICByZXR1cm4gaW5wdXRTZWxlY3RvclJlc3VsdHM7XHJcbn1cclxudmFyIGdldERldk1vZGVDaGVja3NFeGVjdXRpb25JbmZvID0gKGZpcnN0UnVuLCBkZXZNb2RlQ2hlY2tzKSA9PiB7XHJcbiAgY29uc3QgeyBpZGVudGl0eUZ1bmN0aW9uQ2hlY2ssIGlucHV0U3RhYmlsaXR5Q2hlY2sgfSA9IHtcclxuICAgIC4uLmdsb2JhbERldk1vZGVDaGVja3MsXHJcbiAgICAuLi5kZXZNb2RlQ2hlY2tzXHJcbiAgfTtcclxuICByZXR1cm4ge1xyXG4gICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiB7XHJcbiAgICAgIHNob3VsZFJ1bjogaWRlbnRpdHlGdW5jdGlvbkNoZWNrID09PSBcImFsd2F5c1wiIHx8IGlkZW50aXR5RnVuY3Rpb25DaGVjayA9PT0gXCJvbmNlXCIgJiYgZmlyc3RSdW4sXHJcbiAgICAgIHJ1bjogcnVuSWRlbnRpdHlGdW5jdGlvbkNoZWNrXHJcbiAgICB9LFxyXG4gICAgaW5wdXRTdGFiaWxpdHlDaGVjazoge1xyXG4gICAgICBzaG91bGRSdW46IGlucHV0U3RhYmlsaXR5Q2hlY2sgPT09IFwiYWx3YXlzXCIgfHwgaW5wdXRTdGFiaWxpdHlDaGVjayA9PT0gXCJvbmNlXCIgJiYgZmlyc3RSdW4sXHJcbiAgICAgIHJ1bjogcnVuSW5wdXRTdGFiaWxpdHlDaGVja1xyXG4gICAgfVxyXG4gIH07XHJcbn07XHJcblxyXG4vLyBzcmMvYXV0b3RyYWNrTWVtb2l6ZS9hdXRvdHJhY2tpbmcudHNcclxudmFyICRSRVZJU0lPTiA9IDA7XHJcbnZhciBDVVJSRU5UX1RSQUNLRVIgPSBudWxsO1xyXG52YXIgQ2VsbCA9IGNsYXNzIHtcclxuICByZXZpc2lvbiA9ICRSRVZJU0lPTjtcclxuICBfdmFsdWU7XHJcbiAgX2xhc3RWYWx1ZTtcclxuICBfaXNFcXVhbCA9IHRyaXBsZUVxO1xyXG4gIGNvbnN0cnVjdG9yKGluaXRpYWxWYWx1ZSwgaXNFcXVhbCA9IHRyaXBsZUVxKSB7XHJcbiAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX2xhc3RWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcclxuICAgIHRoaXMuX2lzRXF1YWwgPSBpc0VxdWFsO1xyXG4gIH1cclxuICAvLyBXaGVuZXZlciBhIHN0b3JhZ2UgdmFsdWUgaXMgcmVhZCwgaXQnbGwgYWRkIGl0c2VsZiB0byB0aGUgY3VycmVudCB0cmFja2VyIGlmXHJcbiAgLy8gb25lIGV4aXN0cywgZW50YW5nbGluZyBpdHMgc3RhdGUgd2l0aCB0aGF0IGNhY2hlLlxyXG4gIGdldCB2YWx1ZSgpIHtcclxuICAgIENVUlJFTlRfVFJBQ0tFUj8uYWRkKHRoaXMpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG4gIH1cclxuICAvLyBXaGVuZXZlciBhIHN0b3JhZ2UgdmFsdWUgaXMgdXBkYXRlZCwgd2UgYnVtcCB0aGUgZ2xvYmFsIHJldmlzaW9uIGNsb2NrLFxyXG4gIC8vIGFzc2lnbiB0aGUgcmV2aXNpb24gZm9yIHRoaXMgc3RvcmFnZSB0byB0aGUgbmV3IHZhbHVlLCBfYW5kXyB3ZSBzY2hlZHVsZSBhXHJcbiAgLy8gcmVyZW5kZXIuIFRoaXMgaXMgaW1wb3J0YW50LCBhbmQgaXQncyB3aGF0IG1ha2VzIGF1dG90cmFja2luZyAgX3B1bGxfXHJcbiAgLy8gYmFzZWQuIFdlIGRvbid0IGFjdGl2ZWx5IHRlbGwgdGhlIGNhY2hlcyB3aGljaCBkZXBlbmQgb24gdGhlIHN0b3JhZ2UgdGhhdFxyXG4gIC8vIGFueXRoaW5nIGhhcyBoYXBwZW5lZC4gSW5zdGVhZCwgd2UgcmVjb21wdXRlIHRoZSBjYWNoZXMgd2hlbiBuZWVkZWQuXHJcbiAgc2V0IHZhbHVlKG5ld1ZhbHVlKSB7XHJcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gbmV3VmFsdWUpXHJcbiAgICAgIHJldHVybjtcclxuICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICB0aGlzLnJldmlzaW9uID0gKyskUkVWSVNJT047XHJcbiAgfVxyXG59O1xyXG5mdW5jdGlvbiB0cmlwbGVFcShhLCBiKSB7XHJcbiAgcmV0dXJuIGEgPT09IGI7XHJcbn1cclxudmFyIFRyYWNraW5nQ2FjaGUgPSBjbGFzcyB7XHJcbiAgX2NhY2hlZFZhbHVlO1xyXG4gIF9jYWNoZWRSZXZpc2lvbiA9IC0xO1xyXG4gIF9kZXBzID0gW107XHJcbiAgaGl0cyA9IDA7XHJcbiAgZm47XHJcbiAgY29uc3RydWN0b3IoZm4pIHtcclxuICAgIHRoaXMuZm4gPSBmbjtcclxuICB9XHJcbiAgY2xlYXIoKSB7XHJcbiAgICB0aGlzLl9jYWNoZWRWYWx1ZSA9IHZvaWQgMDtcclxuICAgIHRoaXMuX2NhY2hlZFJldmlzaW9uID0gLTE7XHJcbiAgICB0aGlzLl9kZXBzID0gW107XHJcbiAgICB0aGlzLmhpdHMgPSAwO1xyXG4gIH1cclxuICBnZXQgdmFsdWUoKSB7XHJcbiAgICBpZiAodGhpcy5yZXZpc2lvbiA+IHRoaXMuX2NhY2hlZFJldmlzaW9uKSB7XHJcbiAgICAgIGNvbnN0IHsgZm4gfSA9IHRoaXM7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRUcmFja2VyID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcclxuICAgICAgY29uc3QgcHJldlRyYWNrZXIgPSBDVVJSRU5UX1RSQUNLRVI7XHJcbiAgICAgIENVUlJFTlRfVFJBQ0tFUiA9IGN1cnJlbnRUcmFja2VyO1xyXG4gICAgICB0aGlzLl9jYWNoZWRWYWx1ZSA9IGZuKCk7XHJcbiAgICAgIENVUlJFTlRfVFJBQ0tFUiA9IHByZXZUcmFja2VyO1xyXG4gICAgICB0aGlzLmhpdHMrKztcclxuICAgICAgdGhpcy5fZGVwcyA9IEFycmF5LmZyb20oY3VycmVudFRyYWNrZXIpO1xyXG4gICAgICB0aGlzLl9jYWNoZWRSZXZpc2lvbiA9IHRoaXMucmV2aXNpb247XHJcbiAgICB9XHJcbiAgICBDVVJSRU5UX1RSQUNLRVI/LmFkZCh0aGlzKTtcclxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRWYWx1ZTtcclxuICB9XHJcbiAgZ2V0IHJldmlzaW9uKCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KC4uLnRoaXMuX2RlcHMubWFwKChkKSA9PiBkLnJldmlzaW9uKSwgMCk7XHJcbiAgfVxyXG59O1xyXG5mdW5jdGlvbiBnZXRWYWx1ZShjZWxsKSB7XHJcbiAgaWYgKCEoY2VsbCBpbnN0YW5jZW9mIENlbGwpKSB7XHJcbiAgICBjb25zb2xlLndhcm4oXCJOb3QgYSB2YWxpZCBjZWxsISBcIiwgY2VsbCk7XHJcbiAgfVxyXG4gIHJldHVybiBjZWxsLnZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIHNldFZhbHVlKHN0b3JhZ2UsIHZhbHVlKSB7XHJcbiAgaWYgKCEoc3RvcmFnZSBpbnN0YW5jZW9mIENlbGwpKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxyXG4gICAgICBcInNldFZhbHVlIG11c3QgYmUgcGFzc2VkIGEgdHJhY2tlZCBzdG9yZSBjcmVhdGVkIHdpdGggYGNyZWF0ZVN0b3JhZ2VgLlwiXHJcbiAgICApO1xyXG4gIH1cclxuICBzdG9yYWdlLnZhbHVlID0gc3RvcmFnZS5fbGFzdFZhbHVlID0gdmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ2VsbChpbml0aWFsVmFsdWUsIGlzRXF1YWwgPSB0cmlwbGVFcSkge1xyXG4gIHJldHVybiBuZXcgQ2VsbChpbml0aWFsVmFsdWUsIGlzRXF1YWwpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKGZuKSB7XHJcbiAgYXNzZXJ0SXNGdW5jdGlvbihcclxuICAgIGZuLFxyXG4gICAgXCJ0aGUgZmlyc3QgcGFyYW1ldGVyIHRvIGBjcmVhdGVDYWNoZWAgbXVzdCBiZSBhIGZ1bmN0aW9uXCJcclxuICApO1xyXG4gIHJldHVybiBuZXcgVHJhY2tpbmdDYWNoZShmbik7XHJcbn1cclxuXHJcbi8vIHNyYy9hdXRvdHJhY2tNZW1vaXplL3RyYWNraW5nLnRzXHJcbnZhciBuZXZlckVxID0gKGEsIGIpID0+IGZhbHNlO1xyXG5mdW5jdGlvbiBjcmVhdGVUYWcoKSB7XHJcbiAgcmV0dXJuIGNyZWF0ZUNlbGwobnVsbCwgbmV2ZXJFcSk7XHJcbn1cclxuZnVuY3Rpb24gZGlydHlUYWcodGFnLCB2YWx1ZSkge1xyXG4gIHNldFZhbHVlKHRhZywgdmFsdWUpO1xyXG59XHJcbnZhciBjb25zdW1lQ29sbGVjdGlvbiA9IChub2RlKSA9PiB7XHJcbiAgbGV0IHRhZyA9IG5vZGUuY29sbGVjdGlvblRhZztcclxuICBpZiAodGFnID09PSBudWxsKSB7XHJcbiAgICB0YWcgPSBub2RlLmNvbGxlY3Rpb25UYWcgPSBjcmVhdGVUYWcoKTtcclxuICB9XHJcbiAgZ2V0VmFsdWUodGFnKTtcclxufTtcclxudmFyIGRpcnR5Q29sbGVjdGlvbiA9IChub2RlKSA9PiB7XHJcbiAgY29uc3QgdGFnID0gbm9kZS5jb2xsZWN0aW9uVGFnO1xyXG4gIGlmICh0YWcgIT09IG51bGwpIHtcclxuICAgIGRpcnR5VGFnKHRhZywgbnVsbCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gc3JjL2F1dG90cmFja01lbW9pemUvcHJveHkudHNcclxudmFyIFJFRFVYX1BST1hZX0xBQkVMID0gU3ltYm9sKCk7XHJcbnZhciBuZXh0SWQgPSAwO1xyXG52YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pO1xyXG52YXIgT2JqZWN0VHJlZU5vZGUgPSBjbGFzcyB7XHJcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcclxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIHRoaXMudGFnLnZhbHVlID0gdmFsdWU7XHJcbiAgfVxyXG4gIHByb3h5ID0gbmV3IFByb3h5KHRoaXMsIG9iamVjdFByb3h5SGFuZGxlcik7XHJcbiAgdGFnID0gY3JlYXRlVGFnKCk7XHJcbiAgdGFncyA9IHt9O1xyXG4gIGNoaWxkcmVuID0ge307XHJcbiAgY29sbGVjdGlvblRhZyA9IG51bGw7XHJcbiAgaWQgPSBuZXh0SWQrKztcclxufTtcclxudmFyIG9iamVjdFByb3h5SGFuZGxlciA9IHtcclxuICBnZXQobm9kZSwga2V5KSB7XHJcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVSZXN1bHQoKSB7XHJcbiAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IG5vZGU7XHJcbiAgICAgIGNvbnN0IGNoaWxkVmFsdWUgPSBSZWZsZWN0LmdldCh2YWx1ZSwga2V5KTtcclxuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIpIHtcclxuICAgICAgICByZXR1cm4gY2hpbGRWYWx1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoa2V5IGluIHByb3RvKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkVmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiBjaGlsZFZhbHVlID09PSBcIm9iamVjdFwiICYmIGNoaWxkVmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICBsZXQgY2hpbGROb2RlID0gbm9kZS5jaGlsZHJlbltrZXldO1xyXG4gICAgICAgIGlmIChjaGlsZE5vZGUgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgY2hpbGROb2RlID0gbm9kZS5jaGlsZHJlbltrZXldID0gY3JlYXRlTm9kZShjaGlsZFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoaWxkTm9kZS50YWcpIHtcclxuICAgICAgICAgIGdldFZhbHVlKGNoaWxkTm9kZS50YWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hpbGROb2RlLnByb3h5O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxldCB0YWcgPSBub2RlLnRhZ3Nba2V5XTtcclxuICAgICAgICBpZiAodGFnID09PSB2b2lkIDApIHtcclxuICAgICAgICAgIHRhZyA9IG5vZGUudGFnc1trZXldID0gY3JlYXRlVGFnKCk7XHJcbiAgICAgICAgICB0YWcudmFsdWUgPSBjaGlsZFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRWYWx1ZSh0YWcpO1xyXG4gICAgICAgIHJldHVybiBjaGlsZFZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXMgPSBjYWxjdWxhdGVSZXN1bHQoKTtcclxuICAgIHJldHVybiByZXM7XHJcbiAgfSxcclxuICBvd25LZXlzKG5vZGUpIHtcclxuICAgIGNvbnN1bWVDb2xsZWN0aW9uKG5vZGUpO1xyXG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhub2RlLnZhbHVlKTtcclxuICB9LFxyXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihub2RlLCBwcm9wKSB7XHJcbiAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZS52YWx1ZSwgcHJvcCk7XHJcbiAgfSxcclxuICBoYXMobm9kZSwgcHJvcCkge1xyXG4gICAgcmV0dXJuIFJlZmxlY3QuaGFzKG5vZGUudmFsdWUsIHByb3ApO1xyXG4gIH1cclxufTtcclxudmFyIEFycmF5VHJlZU5vZGUgPSBjbGFzcyB7XHJcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcclxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIHRoaXMudGFnLnZhbHVlID0gdmFsdWU7XHJcbiAgfVxyXG4gIHByb3h5ID0gbmV3IFByb3h5KFt0aGlzXSwgYXJyYXlQcm94eUhhbmRsZXIpO1xyXG4gIHRhZyA9IGNyZWF0ZVRhZygpO1xyXG4gIHRhZ3MgPSB7fTtcclxuICBjaGlsZHJlbiA9IHt9O1xyXG4gIGNvbGxlY3Rpb25UYWcgPSBudWxsO1xyXG4gIGlkID0gbmV4dElkKys7XHJcbn07XHJcbnZhciBhcnJheVByb3h5SGFuZGxlciA9IHtcclxuICBnZXQoW25vZGVdLCBrZXkpIHtcclxuICAgIGlmIChrZXkgPT09IFwibGVuZ3RoXCIpIHtcclxuICAgICAgY29uc3VtZUNvbGxlY3Rpb24obm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqZWN0UHJveHlIYW5kbGVyLmdldChub2RlLCBrZXkpO1xyXG4gIH0sXHJcbiAgb3duS2V5cyhbbm9kZV0pIHtcclxuICAgIHJldHVybiBvYmplY3RQcm94eUhhbmRsZXIub3duS2V5cyhub2RlKTtcclxuICB9LFxyXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihbbm9kZV0sIHByb3ApIHtcclxuICAgIHJldHVybiBvYmplY3RQcm94eUhhbmRsZXIuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUsIHByb3ApO1xyXG4gIH0sXHJcbiAgaGFzKFtub2RlXSwgcHJvcCkge1xyXG4gICAgcmV0dXJuIG9iamVjdFByb3h5SGFuZGxlci5oYXMobm9kZSwgcHJvcCk7XHJcbiAgfVxyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVOb2RlKHZhbHVlKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICByZXR1cm4gbmV3IEFycmF5VHJlZU5vZGUodmFsdWUpO1xyXG4gIH1cclxuICByZXR1cm4gbmV3IE9iamVjdFRyZWVOb2RlKHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVOb2RlKG5vZGUsIG5ld1ZhbHVlKSB7XHJcbiAgY29uc3QgeyB2YWx1ZSwgdGFncywgY2hpbGRyZW4gfSA9IG5vZGU7XHJcbiAgbm9kZS52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KG5ld1ZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggIT09IG5ld1ZhbHVlLmxlbmd0aCkge1xyXG4gICAgZGlydHlDb2xsZWN0aW9uKG5vZGUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAodmFsdWUgIT09IG5ld1ZhbHVlKSB7XHJcbiAgICAgIGxldCBvbGRLZXlzU2l6ZSA9IDA7XHJcbiAgICAgIGxldCBuZXdLZXlzU2l6ZSA9IDA7XHJcbiAgICAgIGxldCBhbnlLZXlzQWRkZWQgPSBmYWxzZTtcclxuICAgICAgZm9yIChjb25zdCBfa2V5IGluIHZhbHVlKSB7XHJcbiAgICAgICAgb2xkS2V5c1NpemUrKztcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdWYWx1ZSkge1xyXG4gICAgICAgIG5ld0tleXNTaXplKys7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIHZhbHVlKSkge1xyXG4gICAgICAgICAgYW55S2V5c0FkZGVkID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjb25zdCBpc0RpZmZlcmVudCA9IGFueUtleXNBZGRlZCB8fCBvbGRLZXlzU2l6ZSAhPT0gbmV3S2V5c1NpemU7XHJcbiAgICAgIGlmIChpc0RpZmZlcmVudCkge1xyXG4gICAgICAgIGRpcnR5Q29sbGVjdGlvbihub2RlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBmb3IgKGNvbnN0IGtleSBpbiB0YWdzKSB7XHJcbiAgICBjb25zdCBjaGlsZFZhbHVlID0gdmFsdWVba2V5XTtcclxuICAgIGNvbnN0IG5ld0NoaWxkVmFsdWUgPSBuZXdWYWx1ZVtrZXldO1xyXG4gICAgaWYgKGNoaWxkVmFsdWUgIT09IG5ld0NoaWxkVmFsdWUpIHtcclxuICAgICAgZGlydHlDb2xsZWN0aW9uKG5vZGUpO1xyXG4gICAgICBkaXJ0eVRhZyh0YWdzW2tleV0sIG5ld0NoaWxkVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZFZhbHVlID09PSBcIm9iamVjdFwiICYmIG5ld0NoaWxkVmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgZGVsZXRlIHRhZ3Nba2V5XTtcclxuICAgIH1cclxuICB9XHJcbiAgZm9yIChjb25zdCBrZXkgaW4gY2hpbGRyZW4pIHtcclxuICAgIGNvbnN0IGNoaWxkTm9kZSA9IGNoaWxkcmVuW2tleV07XHJcbiAgICBjb25zdCBuZXdDaGlsZFZhbHVlID0gbmV3VmFsdWVba2V5XTtcclxuICAgIGNvbnN0IGNoaWxkVmFsdWUgPSBjaGlsZE5vZGUudmFsdWU7XHJcbiAgICBpZiAoY2hpbGRWYWx1ZSA9PT0gbmV3Q2hpbGRWYWx1ZSkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5ld0NoaWxkVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgbmV3Q2hpbGRWYWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICB1cGRhdGVOb2RlKGNoaWxkTm9kZSwgbmV3Q2hpbGRWYWx1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkZWxldGVOb2RlKGNoaWxkTm9kZSk7XHJcbiAgICAgIGRlbGV0ZSBjaGlsZHJlbltrZXldO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBkZWxldGVOb2RlKG5vZGUpIHtcclxuICBpZiAobm9kZS50YWcpIHtcclxuICAgIGRpcnR5VGFnKG5vZGUudGFnLCBudWxsKTtcclxuICB9XHJcbiAgZGlydHlDb2xsZWN0aW9uKG5vZGUpO1xyXG4gIGZvciAoY29uc3Qga2V5IGluIG5vZGUudGFncykge1xyXG4gICAgZGlydHlUYWcobm9kZS50YWdzW2tleV0sIG51bGwpO1xyXG4gIH1cclxuICBmb3IgKGNvbnN0IGtleSBpbiBub2RlLmNoaWxkcmVuKSB7XHJcbiAgICBkZWxldGVOb2RlKG5vZGUuY2hpbGRyZW5ba2V5XSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBzcmMvbHJ1TWVtb2l6ZS50c1xyXG5mdW5jdGlvbiBjcmVhdGVTaW5nbGV0b25DYWNoZShlcXVhbHMpIHtcclxuICBsZXQgZW50cnk7XHJcbiAgcmV0dXJuIHtcclxuICAgIGdldChrZXkpIHtcclxuICAgICAgaWYgKGVudHJ5ICYmIGVxdWFscyhlbnRyeS5rZXksIGtleSkpIHtcclxuICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIE5PVF9GT1VORDtcclxuICAgIH0sXHJcbiAgICBwdXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICBlbnRyeSA9IHsga2V5LCB2YWx1ZSB9O1xyXG4gICAgfSxcclxuICAgIGdldEVudHJpZXMoKSB7XHJcbiAgICAgIHJldHVybiBlbnRyeSA/IFtlbnRyeV0gOiBbXTtcclxuICAgIH0sXHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgZW50cnkgPSB2b2lkIDA7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVMcnVDYWNoZShtYXhTaXplLCBlcXVhbHMpIHtcclxuICBsZXQgZW50cmllcyA9IFtdO1xyXG4gIGZ1bmN0aW9uIGdldChrZXkpIHtcclxuICAgIGNvbnN0IGNhY2hlSW5kZXggPSBlbnRyaWVzLmZpbmRJbmRleCgoZW50cnkpID0+IGVxdWFscyhrZXksIGVudHJ5LmtleSkpO1xyXG4gICAgaWYgKGNhY2hlSW5kZXggPiAtMSkge1xyXG4gICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbY2FjaGVJbmRleF07XHJcbiAgICAgIGlmIChjYWNoZUluZGV4ID4gMCkge1xyXG4gICAgICAgIGVudHJpZXMuc3BsaWNlKGNhY2hlSW5kZXgsIDEpO1xyXG4gICAgICAgIGVudHJpZXMudW5zaGlmdChlbnRyeSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE5PVF9GT1VORDtcclxuICB9XHJcbiAgZnVuY3Rpb24gcHV0KGtleSwgdmFsdWUpIHtcclxuICAgIGlmIChnZXQoa2V5KSA9PT0gTk9UX0ZPVU5EKSB7XHJcbiAgICAgIGVudHJpZXMudW5zaGlmdCh7IGtleSwgdmFsdWUgfSk7XHJcbiAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IG1heFNpemUpIHtcclxuICAgICAgICBlbnRyaWVzLnBvcCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGdldEVudHJpZXMoKSB7XHJcbiAgICByZXR1cm4gZW50cmllcztcclxuICB9XHJcbiAgZnVuY3Rpb24gY2xlYXIoKSB7XHJcbiAgICBlbnRyaWVzID0gW107XHJcbiAgfVxyXG4gIHJldHVybiB7IGdldCwgcHV0LCBnZXRFbnRyaWVzLCBjbGVhciB9O1xyXG59XHJcbnZhciByZWZlcmVuY2VFcXVhbGl0eUNoZWNrID0gKGEsIGIpID0+IGEgPT09IGI7XHJcbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlS2V5Q29tcGFyYXRvcihlcXVhbGl0eUNoZWNrKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIGFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsKHByZXYsIG5leHQpIHtcclxuICAgIGlmIChwcmV2ID09PSBudWxsIHx8IG5leHQgPT09IG51bGwgfHwgcHJldi5sZW5ndGggIT09IG5leHQubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBwcmV2O1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoIWVxdWFsaXR5Q2hlY2socHJldltpXSwgbmV4dFtpXSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gbHJ1TWVtb2l6ZShmdW5jLCBlcXVhbGl0eUNoZWNrT3JPcHRpb25zKSB7XHJcbiAgY29uc3QgcHJvdmlkZWRPcHRpb25zID0gdHlwZW9mIGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMgPT09IFwib2JqZWN0XCIgPyBlcXVhbGl0eUNoZWNrT3JPcHRpb25zIDogeyBlcXVhbGl0eUNoZWNrOiBlcXVhbGl0eUNoZWNrT3JPcHRpb25zIH07XHJcbiAgY29uc3Qge1xyXG4gICAgZXF1YWxpdHlDaGVjayA9IHJlZmVyZW5jZUVxdWFsaXR5Q2hlY2ssXHJcbiAgICBtYXhTaXplID0gMSxcclxuICAgIHJlc3VsdEVxdWFsaXR5Q2hlY2tcclxuICB9ID0gcHJvdmlkZWRPcHRpb25zO1xyXG4gIGNvbnN0IGNvbXBhcmF0b3IgPSBjcmVhdGVDYWNoZUtleUNvbXBhcmF0b3IoZXF1YWxpdHlDaGVjayk7XHJcbiAgbGV0IHJlc3VsdHNDb3VudCA9IDA7XHJcbiAgY29uc3QgY2FjaGUgPSBtYXhTaXplIDw9IDEgPyBjcmVhdGVTaW5nbGV0b25DYWNoZShjb21wYXJhdG9yKSA6IGNyZWF0ZUxydUNhY2hlKG1heFNpemUsIGNvbXBhcmF0b3IpO1xyXG4gIGZ1bmN0aW9uIG1lbW9pemVkKCkge1xyXG4gICAgbGV0IHZhbHVlID0gY2FjaGUuZ2V0KGFyZ3VtZW50cyk7XHJcbiAgICBpZiAodmFsdWUgPT09IE5PVF9GT1VORCkge1xyXG4gICAgICB2YWx1ZSA9IGZ1bmMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgcmVzdWx0c0NvdW50Kys7XHJcbiAgICAgIGlmIChyZXN1bHRFcXVhbGl0eUNoZWNrKSB7XHJcbiAgICAgICAgY29uc3QgZW50cmllcyA9IGNhY2hlLmdldEVudHJpZXMoKTtcclxuICAgICAgICBjb25zdCBtYXRjaGluZ0VudHJ5ID0gZW50cmllcy5maW5kKFxyXG4gICAgICAgICAgKGVudHJ5KSA9PiByZXN1bHRFcXVhbGl0eUNoZWNrKGVudHJ5LnZhbHVlLCB2YWx1ZSlcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmIChtYXRjaGluZ0VudHJ5KSB7XHJcbiAgICAgICAgICB2YWx1ZSA9IG1hdGNoaW5nRW50cnkudmFsdWU7XHJcbiAgICAgICAgICByZXN1bHRzQ291bnQgIT09IDAgJiYgcmVzdWx0c0NvdW50LS07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGNhY2hlLnB1dChhcmd1bWVudHMsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbiAgbWVtb2l6ZWQuY2xlYXJDYWNoZSA9ICgpID0+IHtcclxuICAgIGNhY2hlLmNsZWFyKCk7XHJcbiAgICBtZW1vaXplZC5yZXNldFJlc3VsdHNDb3VudCgpO1xyXG4gIH07XHJcbiAgbWVtb2l6ZWQucmVzdWx0c0NvdW50ID0gKCkgPT4gcmVzdWx0c0NvdW50O1xyXG4gIG1lbW9pemVkLnJlc2V0UmVzdWx0c0NvdW50ID0gKCkgPT4ge1xyXG4gICAgcmVzdWx0c0NvdW50ID0gMDtcclxuICB9O1xyXG4gIHJldHVybiBtZW1vaXplZDtcclxufVxyXG5cclxuLy8gc3JjL2F1dG90cmFja01lbW9pemUvYXV0b3RyYWNrTWVtb2l6ZS50c1xyXG5mdW5jdGlvbiBhdXRvdHJhY2tNZW1vaXplKGZ1bmMpIHtcclxuICBjb25zdCBub2RlID0gY3JlYXRlTm9kZShcclxuICAgIFtdXHJcbiAgKTtcclxuICBsZXQgbGFzdEFyZ3MgPSBudWxsO1xyXG4gIGNvbnN0IHNoYWxsb3dFcXVhbCA9IGNyZWF0ZUNhY2hlS2V5Q29tcGFyYXRvcihyZWZlcmVuY2VFcXVhbGl0eUNoZWNrKTtcclxuICBjb25zdCBjYWNoZSA9IGNyZWF0ZUNhY2hlKCgpID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IGZ1bmMuYXBwbHkobnVsbCwgbm9kZS5wcm94eSk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG4gIH0pO1xyXG4gIGZ1bmN0aW9uIG1lbW9pemVkKCkge1xyXG4gICAgaWYgKCFzaGFsbG93RXF1YWwobGFzdEFyZ3MsIGFyZ3VtZW50cykpIHtcclxuICAgICAgdXBkYXRlTm9kZShub2RlLCBhcmd1bWVudHMpO1xyXG4gICAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcclxuICAgIH1cclxuICAgIHJldHVybiBjYWNoZS52YWx1ZTtcclxuICB9XHJcbiAgbWVtb2l6ZWQuY2xlYXJDYWNoZSA9ICgpID0+IHtcclxuICAgIHJldHVybiBjYWNoZS5jbGVhcigpO1xyXG4gIH07XHJcbiAgcmV0dXJuIG1lbW9pemVkO1xyXG59XHJcblxyXG4vLyBzcmMvd2Vha01hcE1lbW9pemUudHNcclxudmFyIFN0cm9uZ1JlZiA9IGNsYXNzIHtcclxuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xyXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gIH1cclxuICBkZXJlZigpIHtcclxuICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gIH1cclxufTtcclxudmFyIFJlZiA9IHR5cGVvZiBXZWFrUmVmICE9PSBcInVuZGVmaW5lZFwiID8gV2Vha1JlZiA6IFN0cm9uZ1JlZjtcclxudmFyIFVOVEVSTUlOQVRFRCA9IDA7XHJcbnZhciBURVJNSU5BVEVEID0gMTtcclxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVOb2RlKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICBzOiBVTlRFUk1JTkFURUQsXHJcbiAgICB2OiB2b2lkIDAsXHJcbiAgICBvOiBudWxsLFxyXG4gICAgcDogbnVsbFxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gd2Vha01hcE1lbW9pemUoZnVuYywgb3B0aW9ucyA9IHt9KSB7XHJcbiAgbGV0IGZuTm9kZSA9IGNyZWF0ZUNhY2hlTm9kZSgpO1xyXG4gIGNvbnN0IHsgcmVzdWx0RXF1YWxpdHlDaGVjayB9ID0gb3B0aW9ucztcclxuICBsZXQgbGFzdFJlc3VsdDtcclxuICBsZXQgcmVzdWx0c0NvdW50ID0gMDtcclxuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcclxuICAgIGxldCBjYWNoZU5vZGUgPSBmbk5vZGU7XHJcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gYXJndW1lbnRzO1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBsZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgY29uc3QgYXJnID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBhcmcgPT09IFwib2JqZWN0XCIgJiYgYXJnICE9PSBudWxsKSB7XHJcbiAgICAgICAgbGV0IG9iamVjdENhY2hlID0gY2FjaGVOb2RlLm87XHJcbiAgICAgICAgaWYgKG9iamVjdENhY2hlID09PSBudWxsKSB7XHJcbiAgICAgICAgICBjYWNoZU5vZGUubyA9IG9iamVjdENhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9iamVjdE5vZGUgPSBvYmplY3RDYWNoZS5nZXQoYXJnKTtcclxuICAgICAgICBpZiAob2JqZWN0Tm9kZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICBjYWNoZU5vZGUgPSBjcmVhdGVDYWNoZU5vZGUoKTtcclxuICAgICAgICAgIG9iamVjdENhY2hlLnNldChhcmcsIGNhY2hlTm9kZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNhY2hlTm9kZSA9IG9iamVjdE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxldCBwcmltaXRpdmVDYWNoZSA9IGNhY2hlTm9kZS5wO1xyXG4gICAgICAgIGlmIChwcmltaXRpdmVDYWNoZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgY2FjaGVOb2RlLnAgPSBwcmltaXRpdmVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHByaW1pdGl2ZU5vZGUgPSBwcmltaXRpdmVDYWNoZS5nZXQoYXJnKTtcclxuICAgICAgICBpZiAocHJpbWl0aXZlTm9kZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICBjYWNoZU5vZGUgPSBjcmVhdGVDYWNoZU5vZGUoKTtcclxuICAgICAgICAgIHByaW1pdGl2ZUNhY2hlLnNldChhcmcsIGNhY2hlTm9kZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNhY2hlTm9kZSA9IHByaW1pdGl2ZU5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB0ZXJtaW5hdGVkTm9kZSA9IGNhY2hlTm9kZTtcclxuICAgIGxldCByZXN1bHQ7XHJcbiAgICBpZiAoY2FjaGVOb2RlLnMgPT09IFRFUk1JTkFURUQpIHtcclxuICAgICAgcmVzdWx0ID0gY2FjaGVOb2RlLnY7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHJlc3VsdHNDb3VudCsrO1xyXG4gICAgICBpZiAocmVzdWx0RXF1YWxpdHlDaGVjaykge1xyXG4gICAgICAgIGNvbnN0IGxhc3RSZXN1bHRWYWx1ZSA9IGxhc3RSZXN1bHQ/LmRlcmVmPy4oKSA/PyBsYXN0UmVzdWx0O1xyXG4gICAgICAgIGlmIChsYXN0UmVzdWx0VmFsdWUgIT0gbnVsbCAmJiByZXN1bHRFcXVhbGl0eUNoZWNrKGxhc3RSZXN1bHRWYWx1ZSwgcmVzdWx0KSkge1xyXG4gICAgICAgICAgcmVzdWx0ID0gbGFzdFJlc3VsdFZhbHVlO1xyXG4gICAgICAgICAgcmVzdWx0c0NvdW50ICE9PSAwICYmIHJlc3VsdHNDb3VudC0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZWVkc1dlYWtSZWYgPSB0eXBlb2YgcmVzdWx0ID09PSBcIm9iamVjdFwiICYmIHJlc3VsdCAhPT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ID09PSBcImZ1bmN0aW9uXCI7XHJcbiAgICAgICAgbGFzdFJlc3VsdCA9IG5lZWRzV2Vha1JlZiA/IG5ldyBSZWYocmVzdWx0KSA6IHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGVybWluYXRlZE5vZGUucyA9IFRFUk1JTkFURUQ7XHJcbiAgICB0ZXJtaW5hdGVkTm9kZS52ID0gcmVzdWx0O1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgbWVtb2l6ZWQuY2xlYXJDYWNoZSA9ICgpID0+IHtcclxuICAgIGZuTm9kZSA9IGNyZWF0ZUNhY2hlTm9kZSgpO1xyXG4gICAgbWVtb2l6ZWQucmVzZXRSZXN1bHRzQ291bnQoKTtcclxuICB9O1xyXG4gIG1lbW9pemVkLnJlc3VsdHNDb3VudCA9ICgpID0+IHJlc3VsdHNDb3VudDtcclxuICBtZW1vaXplZC5yZXNldFJlc3VsdHNDb3VudCA9ICgpID0+IHtcclxuICAgIHJlc3VsdHNDb3VudCA9IDA7XHJcbiAgfTtcclxuICByZXR1cm4gbWVtb2l6ZWQ7XHJcbn1cclxuXHJcbi8vIHNyYy9jcmVhdGVTZWxlY3RvckNyZWF0b3IudHNcclxuZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JDcmVhdG9yKG1lbW9pemVPck9wdGlvbnMsIC4uLm1lbW9pemVPcHRpb25zRnJvbUFyZ3MpIHtcclxuICBjb25zdCBjcmVhdGVTZWxlY3RvckNyZWF0b3JPcHRpb25zID0gdHlwZW9mIG1lbW9pemVPck9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IHtcclxuICAgIG1lbW9pemU6IG1lbW9pemVPck9wdGlvbnMsXHJcbiAgICBtZW1vaXplT3B0aW9uczogbWVtb2l6ZU9wdGlvbnNGcm9tQXJnc1xyXG4gIH0gOiBtZW1vaXplT3JPcHRpb25zO1xyXG4gIGNvbnN0IGNyZWF0ZVNlbGVjdG9yMiA9ICguLi5jcmVhdGVTZWxlY3RvckFyZ3MpID0+IHtcclxuICAgIGxldCByZWNvbXB1dGF0aW9ucyA9IDA7XHJcbiAgICBsZXQgZGVwZW5kZW5jeVJlY29tcHV0YXRpb25zID0gMDtcclxuICAgIGxldCBsYXN0UmVzdWx0O1xyXG4gICAgbGV0IGRpcmVjdGx5UGFzc2VkT3B0aW9ucyA9IHt9O1xyXG4gICAgbGV0IHJlc3VsdEZ1bmMgPSBjcmVhdGVTZWxlY3RvckFyZ3MucG9wKCk7XHJcbiAgICBpZiAodHlwZW9mIHJlc3VsdEZ1bmMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgZGlyZWN0bHlQYXNzZWRPcHRpb25zID0gcmVzdWx0RnVuYztcclxuICAgICAgcmVzdWx0RnVuYyA9IGNyZWF0ZVNlbGVjdG9yQXJncy5wb3AoKTtcclxuICAgIH1cclxuICAgIGFzc2VydElzRnVuY3Rpb24oXHJcbiAgICAgIHJlc3VsdEZ1bmMsXHJcbiAgICAgIGBjcmVhdGVTZWxlY3RvciBleHBlY3RzIGFuIG91dHB1dCBmdW5jdGlvbiBhZnRlciB0aGUgaW5wdXRzLCBidXQgcmVjZWl2ZWQ6IFske3R5cGVvZiByZXN1bHRGdW5jfV1gXHJcbiAgICApO1xyXG4gICAgY29uc3QgY29tYmluZWRPcHRpb25zID0ge1xyXG4gICAgICAuLi5jcmVhdGVTZWxlY3RvckNyZWF0b3JPcHRpb25zLFxyXG4gICAgICAuLi5kaXJlY3RseVBhc3NlZE9wdGlvbnNcclxuICAgIH07XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIG1lbW9pemUsXHJcbiAgICAgIG1lbW9pemVPcHRpb25zID0gW10sXHJcbiAgICAgIGFyZ3NNZW1vaXplID0gd2Vha01hcE1lbW9pemUsXHJcbiAgICAgIGFyZ3NNZW1vaXplT3B0aW9ucyA9IFtdLFxyXG4gICAgICBkZXZNb2RlQ2hlY2tzID0ge31cclxuICAgIH0gPSBjb21iaW5lZE9wdGlvbnM7XHJcbiAgICBjb25zdCBmaW5hbE1lbW9pemVPcHRpb25zID0gZW5zdXJlSXNBcnJheShtZW1vaXplT3B0aW9ucyk7XHJcbiAgICBjb25zdCBmaW5hbEFyZ3NNZW1vaXplT3B0aW9ucyA9IGVuc3VyZUlzQXJyYXkoYXJnc01lbW9pemVPcHRpb25zKTtcclxuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGdldERlcGVuZGVuY2llcyhjcmVhdGVTZWxlY3RvckFyZ3MpO1xyXG4gICAgY29uc3QgbWVtb2l6ZWRSZXN1bHRGdW5jID0gbWVtb2l6ZShmdW5jdGlvbiByZWNvbXB1dGF0aW9uV3JhcHBlcigpIHtcclxuICAgICAgcmVjb21wdXRhdGlvbnMrKztcclxuICAgICAgcmV0dXJuIHJlc3VsdEZ1bmMuYXBwbHkoXHJcbiAgICAgICAgbnVsbCxcclxuICAgICAgICBhcmd1bWVudHNcclxuICAgICAgKTtcclxuICAgIH0sIC4uLmZpbmFsTWVtb2l6ZU9wdGlvbnMpO1xyXG4gICAgbGV0IGZpcnN0UnVuID0gdHJ1ZTtcclxuICAgIGNvbnN0IHNlbGVjdG9yID0gYXJnc01lbW9pemUoZnVuY3Rpb24gZGVwZW5kZW5jaWVzQ2hlY2tlcigpIHtcclxuICAgICAgZGVwZW5kZW5jeVJlY29tcHV0YXRpb25zKys7XHJcbiAgICAgIGNvbnN0IGlucHV0U2VsZWN0b3JSZXN1bHRzID0gY29sbGVjdElucHV0U2VsZWN0b3JSZXN1bHRzKFxyXG4gICAgICAgIGRlcGVuZGVuY2llcyxcclxuICAgICAgICBhcmd1bWVudHNcclxuICAgICAgKTtcclxuICAgICAgbGFzdFJlc3VsdCA9IG1lbW9pemVkUmVzdWx0RnVuYy5hcHBseShudWxsLCBpbnB1dFNlbGVjdG9yUmVzdWx0cyk7XHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICBjb25zdCB7IGlkZW50aXR5RnVuY3Rpb25DaGVjaywgaW5wdXRTdGFiaWxpdHlDaGVjayB9ID0gZ2V0RGV2TW9kZUNoZWNrc0V4ZWN1dGlvbkluZm8oZmlyc3RSdW4sIGRldk1vZGVDaGVja3MpO1xyXG4gICAgICAgIGlmIChpZGVudGl0eUZ1bmN0aW9uQ2hlY2suc2hvdWxkUnVuKSB7XHJcbiAgICAgICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2sucnVuKFxyXG4gICAgICAgICAgICByZXN1bHRGdW5jLFxyXG4gICAgICAgICAgICBpbnB1dFNlbGVjdG9yUmVzdWx0cyxcclxuICAgICAgICAgICAgbGFzdFJlc3VsdFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlucHV0U3RhYmlsaXR5Q2hlY2suc2hvdWxkUnVuKSB7XHJcbiAgICAgICAgICBjb25zdCBpbnB1dFNlbGVjdG9yUmVzdWx0c0NvcHkgPSBjb2xsZWN0SW5wdXRTZWxlY3RvclJlc3VsdHMoXHJcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcyxcclxuICAgICAgICAgICAgYXJndW1lbnRzXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgaW5wdXRTdGFiaWxpdHlDaGVjay5ydW4oXHJcbiAgICAgICAgICAgIHsgaW5wdXRTZWxlY3RvclJlc3VsdHMsIGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSB9LFxyXG4gICAgICAgICAgICB7IG1lbW9pemUsIG1lbW9pemVPcHRpb25zOiBmaW5hbE1lbW9pemVPcHRpb25zIH0sXHJcbiAgICAgICAgICAgIGFyZ3VtZW50c1xyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZpcnN0UnVuKVxyXG4gICAgICAgICAgZmlyc3RSdW4gPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbGFzdFJlc3VsdDtcclxuICAgIH0sIC4uLmZpbmFsQXJnc01lbW9pemVPcHRpb25zKTtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHNlbGVjdG9yLCB7XHJcbiAgICAgIHJlc3VsdEZ1bmMsXHJcbiAgICAgIG1lbW9pemVkUmVzdWx0RnVuYyxcclxuICAgICAgZGVwZW5kZW5jaWVzLFxyXG4gICAgICBkZXBlbmRlbmN5UmVjb21wdXRhdGlvbnM6ICgpID0+IGRlcGVuZGVuY3lSZWNvbXB1dGF0aW9ucyxcclxuICAgICAgcmVzZXREZXBlbmRlbmN5UmVjb21wdXRhdGlvbnM6ICgpID0+IHtcclxuICAgICAgICBkZXBlbmRlbmN5UmVjb21wdXRhdGlvbnMgPSAwO1xyXG4gICAgICB9LFxyXG4gICAgICBsYXN0UmVzdWx0OiAoKSA9PiBsYXN0UmVzdWx0LFxyXG4gICAgICByZWNvbXB1dGF0aW9uczogKCkgPT4gcmVjb21wdXRhdGlvbnMsXHJcbiAgICAgIHJlc2V0UmVjb21wdXRhdGlvbnM6ICgpID0+IHtcclxuICAgICAgICByZWNvbXB1dGF0aW9ucyA9IDA7XHJcbiAgICAgIH0sXHJcbiAgICAgIG1lbW9pemUsXHJcbiAgICAgIGFyZ3NNZW1vaXplXHJcbiAgICB9KTtcclxuICB9O1xyXG4gIE9iamVjdC5hc3NpZ24oY3JlYXRlU2VsZWN0b3IyLCB7XHJcbiAgICB3aXRoVHlwZXM6ICgpID0+IGNyZWF0ZVNlbGVjdG9yMlxyXG4gIH0pO1xyXG4gIHJldHVybiBjcmVhdGVTZWxlY3RvcjI7XHJcbn1cclxudmFyIGNyZWF0ZVNlbGVjdG9yID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcih3ZWFrTWFwTWVtb2l6ZSk7XHJcblxyXG4vLyBzcmMvY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yLnRzXHJcbnZhciBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgPSBPYmplY3QuYXNzaWduKFxyXG4gIChpbnB1dFNlbGVjdG9yc09iamVjdCwgc2VsZWN0b3JDcmVhdG9yID0gY3JlYXRlU2VsZWN0b3IpID0+IHtcclxuICAgIGFzc2VydElzT2JqZWN0KFxyXG4gICAgICBpbnB1dFNlbGVjdG9yc09iamVjdCxcclxuICAgICAgYGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciBleHBlY3RzIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCB3aGVyZSBlYWNoIHByb3BlcnR5IGlzIGEgc2VsZWN0b3IsIGluc3RlYWQgcmVjZWl2ZWQgYSAke3R5cGVvZiBpbnB1dFNlbGVjdG9yc09iamVjdH1gXHJcbiAgICApO1xyXG4gICAgY29uc3QgaW5wdXRTZWxlY3RvcktleXMgPSBPYmplY3Qua2V5cyhpbnB1dFNlbGVjdG9yc09iamVjdCk7XHJcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBpbnB1dFNlbGVjdG9yS2V5cy5tYXAoXHJcbiAgICAgIChrZXkpID0+IGlucHV0U2VsZWN0b3JzT2JqZWN0W2tleV1cclxuICAgICk7XHJcbiAgICBjb25zdCBzdHJ1Y3R1cmVkU2VsZWN0b3IgPSBzZWxlY3RvckNyZWF0b3IoXHJcbiAgICAgIGRlcGVuZGVuY2llcyxcclxuICAgICAgKC4uLmlucHV0U2VsZWN0b3JSZXN1bHRzKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0U2VsZWN0b3JSZXN1bHRzLnJlZHVjZSgoY29tcG9zaXRpb24sIHZhbHVlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgY29tcG9zaXRpb25baW5wdXRTZWxlY3RvcktleXNbaW5kZXhdXSA9IHZhbHVlO1xyXG4gICAgICAgICAgcmV0dXJuIGNvbXBvc2l0aW9uO1xyXG4gICAgICAgIH0sIHt9KTtcclxuICAgICAgfVxyXG4gICAgKTtcclxuICAgIHJldHVybiBzdHJ1Y3R1cmVkU2VsZWN0b3I7XHJcbiAgfSxcclxuICB7IHdpdGhUeXBlczogKCkgPT4gY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIH1cclxuKTtcclxuZXhwb3J0IHtcclxuICBjcmVhdGVTZWxlY3RvcixcclxuICBjcmVhdGVTZWxlY3RvckNyZWF0b3IsXHJcbiAgY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yLFxyXG4gIGxydU1lbW9pemUsXHJcbiAgcmVmZXJlbmNlRXF1YWxpdHlDaGVjayxcclxuICBzZXRHbG9iYWxEZXZNb2RlQ2hlY2tzLFxyXG4gIGF1dG90cmFja01lbW9pemUgYXMgdW5zdGFibGVfYXV0b3RyYWNrTWVtb2l6ZSxcclxuICB3ZWFrTWFwTWVtb2l6ZVxyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNlbGVjdC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/reselect/dist/reselect.mjs\n");

/***/ })

};
;