"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-redux";
exports.ids = ["vendor-chunks/react-redux"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-redux/dist/react-redux.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/react-redux/dist/react-redux.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider_default),\n/* harmony export */   ReactReduxContext: () => (/* binding */ ReactReduxContext),\n/* harmony export */   batch: () => (/* binding */ batch),\n/* harmony export */   connect: () => (/* binding */ connect_default),\n/* harmony export */   createDispatchHook: () => (/* binding */ createDispatchHook),\n/* harmony export */   createSelectorHook: () => (/* binding */ createSelectorHook),\n/* harmony export */   createStoreHook: () => (/* binding */ createStoreHook),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual),\n/* harmony export */   useDispatch: () => (/* binding */ useDispatch),\n/* harmony export */   useSelector: () => (/* binding */ useSelector),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/with-selector.js\");\n// src/utils/react.ts\r\n\r\n\r\n// src/utils/react-is.ts\r\nvar IS_REACT_19 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.version.startsWith(\"19\");\r\nvar REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for(\r\n  IS_REACT_19 ? \"react.transitional.element\" : \"react.element\"\r\n);\r\nvar REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for(\"react.portal\");\r\nvar REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for(\"react.fragment\");\r\nvar REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for(\"react.strict_mode\");\r\nvar REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for(\"react.profiler\");\r\nvar REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for(\"react.consumer\");\r\nvar REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for(\"react.context\");\r\nvar REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for(\"react.forward_ref\");\r\nvar REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for(\"react.suspense\");\r\nvar REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for(\r\n  \"react.suspense_list\"\r\n);\r\nvar REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for(\"react.memo\");\r\nvar REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for(\"react.lazy\");\r\nvar REACT_OFFSCREEN_TYPE = /* @__PURE__ */ Symbol.for(\"react.offscreen\");\r\nvar REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for(\r\n  \"react.client.reference\"\r\n);\r\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\r\nvar Memo = REACT_MEMO_TYPE;\r\nfunction isValidElementType(type) {\r\n  return typeof type === \"string\" || typeof type === \"function\" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || typeof type === \"object\" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) ? true : false;\r\n}\r\nfunction typeOf(object) {\r\n  if (typeof object === \"object\" && object !== null) {\r\n    const { $$typeof } = object;\r\n    switch ($$typeof) {\r\n      case REACT_ELEMENT_TYPE:\r\n        switch (object = object.type, object) {\r\n          case REACT_FRAGMENT_TYPE:\r\n          case REACT_PROFILER_TYPE:\r\n          case REACT_STRICT_MODE_TYPE:\r\n          case REACT_SUSPENSE_TYPE:\r\n          case REACT_SUSPENSE_LIST_TYPE:\r\n            return object;\r\n          default:\r\n            switch (object = object && object.$$typeof, object) {\r\n              case REACT_CONTEXT_TYPE:\r\n              case REACT_FORWARD_REF_TYPE:\r\n              case REACT_LAZY_TYPE:\r\n              case REACT_MEMO_TYPE:\r\n                return object;\r\n              case REACT_CONSUMER_TYPE:\r\n                return object;\r\n              default:\r\n                return $$typeof;\r\n            }\r\n        }\r\n      case REACT_PORTAL_TYPE:\r\n        return $$typeof;\r\n    }\r\n  }\r\n}\r\nfunction isContextConsumer(object) {\r\n  return IS_REACT_19 ? typeOf(object) === REACT_CONSUMER_TYPE : typeOf(object) === REACT_CONTEXT_TYPE;\r\n}\r\nfunction isMemo(object) {\r\n  return typeOf(object) === REACT_MEMO_TYPE;\r\n}\r\n\r\n// src/utils/warning.ts\r\nfunction warning(message) {\r\n  if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\r\n    console.error(message);\r\n  }\r\n  try {\r\n    throw new Error(message);\r\n  } catch (e) {\r\n  }\r\n}\r\n\r\n// src/connect/verifySubselectors.ts\r\nfunction verify(selector, methodName) {\r\n  if (!selector) {\r\n    throw new Error(`Unexpected value for ${methodName} in connect.`);\r\n  } else if (methodName === \"mapStateToProps\" || methodName === \"mapDispatchToProps\") {\r\n    if (!Object.prototype.hasOwnProperty.call(selector, \"dependsOnOwnProps\")) {\r\n      warning(\r\n        `The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`\r\n      );\r\n    }\r\n  }\r\n}\r\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\r\n  verify(mapStateToProps, \"mapStateToProps\");\r\n  verify(mapDispatchToProps, \"mapDispatchToProps\");\r\n  verify(mergeProps, \"mergeProps\");\r\n}\r\n\r\n// src/connect/selectorFactory.ts\r\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, {\r\n  areStatesEqual,\r\n  areOwnPropsEqual,\r\n  areStatePropsEqual\r\n}) {\r\n  let hasRunAtLeastOnce = false;\r\n  let state;\r\n  let ownProps;\r\n  let stateProps;\r\n  let dispatchProps;\r\n  let mergedProps;\r\n  function handleFirstCall(firstState, firstOwnProps) {\r\n    state = firstState;\r\n    ownProps = firstOwnProps;\r\n    stateProps = mapStateToProps(state, ownProps);\r\n    dispatchProps = mapDispatchToProps(dispatch, ownProps);\r\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\r\n    hasRunAtLeastOnce = true;\r\n    return mergedProps;\r\n  }\r\n  function handleNewPropsAndNewState() {\r\n    stateProps = mapStateToProps(state, ownProps);\r\n    if (mapDispatchToProps.dependsOnOwnProps)\r\n      dispatchProps = mapDispatchToProps(dispatch, ownProps);\r\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\r\n    return mergedProps;\r\n  }\r\n  function handleNewProps() {\r\n    if (mapStateToProps.dependsOnOwnProps)\r\n      stateProps = mapStateToProps(state, ownProps);\r\n    if (mapDispatchToProps.dependsOnOwnProps)\r\n      dispatchProps = mapDispatchToProps(dispatch, ownProps);\r\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\r\n    return mergedProps;\r\n  }\r\n  function handleNewState() {\r\n    const nextStateProps = mapStateToProps(state, ownProps);\r\n    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\r\n    stateProps = nextStateProps;\r\n    if (statePropsChanged)\r\n      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\r\n    return mergedProps;\r\n  }\r\n  function handleSubsequentCalls(nextState, nextOwnProps) {\r\n    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\r\n    const stateChanged = !areStatesEqual(\r\n      nextState,\r\n      state,\r\n      nextOwnProps,\r\n      ownProps\r\n    );\r\n    state = nextState;\r\n    ownProps = nextOwnProps;\r\n    if (propsChanged && stateChanged) return handleNewPropsAndNewState();\r\n    if (propsChanged) return handleNewProps();\r\n    if (stateChanged) return handleNewState();\r\n    return mergedProps;\r\n  }\r\n  return function pureFinalPropsSelector(nextState, nextOwnProps) {\r\n    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\r\n  };\r\n}\r\nfunction finalPropsSelectorFactory(dispatch, {\r\n  initMapStateToProps,\r\n  initMapDispatchToProps,\r\n  initMergeProps,\r\n  ...options\r\n}) {\r\n  const mapStateToProps = initMapStateToProps(dispatch, options);\r\n  const mapDispatchToProps = initMapDispatchToProps(dispatch, options);\r\n  const mergeProps = initMergeProps(dispatch, options);\r\n  if (true) {\r\n    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);\r\n  }\r\n  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\r\n}\r\n\r\n// src/utils/bindActionCreators.ts\r\nfunction bindActionCreators(actionCreators, dispatch) {\r\n  const boundActionCreators = {};\r\n  for (const key in actionCreators) {\r\n    const actionCreator = actionCreators[key];\r\n    if (typeof actionCreator === \"function\") {\r\n      boundActionCreators[key] = (...args) => dispatch(actionCreator(...args));\r\n    }\r\n  }\r\n  return boundActionCreators;\r\n}\r\n\r\n// src/utils/isPlainObject.ts\r\nfunction isPlainObject(obj) {\r\n  if (typeof obj !== \"object\" || obj === null) return false;\r\n  const proto = Object.getPrototypeOf(obj);\r\n  if (proto === null) return true;\r\n  let baseProto = proto;\r\n  while (Object.getPrototypeOf(baseProto) !== null) {\r\n    baseProto = Object.getPrototypeOf(baseProto);\r\n  }\r\n  return proto === baseProto;\r\n}\r\n\r\n// src/utils/verifyPlainObject.ts\r\nfunction verifyPlainObject(value, displayName, methodName) {\r\n  if (!isPlainObject(value)) {\r\n    warning(\r\n      `${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`\r\n    );\r\n  }\r\n}\r\n\r\n// src/connect/wrapMapToProps.ts\r\nfunction wrapMapToPropsConstant(getConstant) {\r\n  return function initConstantSelector(dispatch) {\r\n    const constant = getConstant(dispatch);\r\n    function constantSelector() {\r\n      return constant;\r\n    }\r\n    constantSelector.dependsOnOwnProps = false;\r\n    return constantSelector;\r\n  };\r\n}\r\nfunction getDependsOnOwnProps(mapToProps) {\r\n  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\r\n}\r\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\r\n  return function initProxySelector(dispatch, { displayName }) {\r\n    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\r\n      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);\r\n    };\r\n    proxy.dependsOnOwnProps = true;\r\n    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\r\n      proxy.mapToProps = mapToProps;\r\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\r\n      let props = proxy(stateOrDispatch, ownProps);\r\n      if (typeof props === \"function\") {\r\n        proxy.mapToProps = props;\r\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\r\n        props = proxy(stateOrDispatch, ownProps);\r\n      }\r\n      if (true)\r\n        verifyPlainObject(props, displayName, methodName);\r\n      return props;\r\n    };\r\n    return proxy;\r\n  };\r\n}\r\n\r\n// src/connect/invalidArgFactory.ts\r\nfunction createInvalidArgFactory(arg, name) {\r\n  return (dispatch, options) => {\r\n    throw new Error(\r\n      `Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`\r\n    );\r\n  };\r\n}\r\n\r\n// src/connect/mapDispatchToProps.ts\r\nfunction mapDispatchToPropsFactory(mapDispatchToProps) {\r\n  return mapDispatchToProps && typeof mapDispatchToProps === \"object\" ? wrapMapToPropsConstant(\r\n    (dispatch) => (\r\n      // @ts-ignore\r\n      bindActionCreators(mapDispatchToProps, dispatch)\r\n    )\r\n  ) : !mapDispatchToProps ? wrapMapToPropsConstant((dispatch) => ({\r\n    dispatch\r\n  })) : typeof mapDispatchToProps === \"function\" ? (\r\n    // @ts-ignore\r\n    wrapMapToPropsFunc(mapDispatchToProps, \"mapDispatchToProps\")\r\n  ) : createInvalidArgFactory(mapDispatchToProps, \"mapDispatchToProps\");\r\n}\r\n\r\n// src/connect/mapStateToProps.ts\r\nfunction mapStateToPropsFactory(mapStateToProps) {\r\n  return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps === \"function\" ? (\r\n    // @ts-ignore\r\n    wrapMapToPropsFunc(mapStateToProps, \"mapStateToProps\")\r\n  ) : createInvalidArgFactory(mapStateToProps, \"mapStateToProps\");\r\n}\r\n\r\n// src/connect/mergeProps.ts\r\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\r\n  return { ...ownProps, ...stateProps, ...dispatchProps };\r\n}\r\nfunction wrapMergePropsFunc(mergeProps) {\r\n  return function initMergePropsProxy(dispatch, { displayName, areMergedPropsEqual }) {\r\n    let hasRunOnce = false;\r\n    let mergedProps;\r\n    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\r\n      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\r\n      if (hasRunOnce) {\r\n        if (!areMergedPropsEqual(nextMergedProps, mergedProps))\r\n          mergedProps = nextMergedProps;\r\n      } else {\r\n        hasRunOnce = true;\r\n        mergedProps = nextMergedProps;\r\n        if (true)\r\n          verifyPlainObject(mergedProps, displayName, \"mergeProps\");\r\n      }\r\n      return mergedProps;\r\n    };\r\n  };\r\n}\r\nfunction mergePropsFactory(mergeProps) {\r\n  return !mergeProps ? () => defaultMergeProps : typeof mergeProps === \"function\" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, \"mergeProps\");\r\n}\r\n\r\n// src/utils/batch.ts\r\nfunction defaultNoopBatch(callback) {\r\n  callback();\r\n}\r\n\r\n// src/utils/Subscription.ts\r\nfunction createListenerCollection() {\r\n  let first = null;\r\n  let last = null;\r\n  return {\r\n    clear() {\r\n      first = null;\r\n      last = null;\r\n    },\r\n    notify() {\r\n      defaultNoopBatch(() => {\r\n        let listener = first;\r\n        while (listener) {\r\n          listener.callback();\r\n          listener = listener.next;\r\n        }\r\n      });\r\n    },\r\n    get() {\r\n      const listeners = [];\r\n      let listener = first;\r\n      while (listener) {\r\n        listeners.push(listener);\r\n        listener = listener.next;\r\n      }\r\n      return listeners;\r\n    },\r\n    subscribe(callback) {\r\n      let isSubscribed = true;\r\n      const listener = last = {\r\n        callback,\r\n        next: null,\r\n        prev: last\r\n      };\r\n      if (listener.prev) {\r\n        listener.prev.next = listener;\r\n      } else {\r\n        first = listener;\r\n      }\r\n      return function unsubscribe() {\r\n        if (!isSubscribed || first === null) return;\r\n        isSubscribed = false;\r\n        if (listener.next) {\r\n          listener.next.prev = listener.prev;\r\n        } else {\r\n          last = listener.prev;\r\n        }\r\n        if (listener.prev) {\r\n          listener.prev.next = listener.next;\r\n        } else {\r\n          first = listener.next;\r\n        }\r\n      };\r\n    }\r\n  };\r\n}\r\nvar nullListeners = {\r\n  notify() {\r\n  },\r\n  get: () => []\r\n};\r\nfunction createSubscription(store, parentSub) {\r\n  let unsubscribe;\r\n  let listeners = nullListeners;\r\n  let subscriptionsAmount = 0;\r\n  let selfSubscribed = false;\r\n  function addNestedSub(listener) {\r\n    trySubscribe();\r\n    const cleanupListener = listeners.subscribe(listener);\r\n    let removed = false;\r\n    return () => {\r\n      if (!removed) {\r\n        removed = true;\r\n        cleanupListener();\r\n        tryUnsubscribe();\r\n      }\r\n    };\r\n  }\r\n  function notifyNestedSubs() {\r\n    listeners.notify();\r\n  }\r\n  function handleChangeWrapper() {\r\n    if (subscription.onStateChange) {\r\n      subscription.onStateChange();\r\n    }\r\n  }\r\n  function isSubscribed() {\r\n    return selfSubscribed;\r\n  }\r\n  function trySubscribe() {\r\n    subscriptionsAmount++;\r\n    if (!unsubscribe) {\r\n      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\r\n      listeners = createListenerCollection();\r\n    }\r\n  }\r\n  function tryUnsubscribe() {\r\n    subscriptionsAmount--;\r\n    if (unsubscribe && subscriptionsAmount === 0) {\r\n      unsubscribe();\r\n      unsubscribe = void 0;\r\n      listeners.clear();\r\n      listeners = nullListeners;\r\n    }\r\n  }\r\n  function trySubscribeSelf() {\r\n    if (!selfSubscribed) {\r\n      selfSubscribed = true;\r\n      trySubscribe();\r\n    }\r\n  }\r\n  function tryUnsubscribeSelf() {\r\n    if (selfSubscribed) {\r\n      selfSubscribed = false;\r\n      tryUnsubscribe();\r\n    }\r\n  }\r\n  const subscription = {\r\n    addNestedSub,\r\n    notifyNestedSubs,\r\n    handleChangeWrapper,\r\n    isSubscribed,\r\n    trySubscribe: trySubscribeSelf,\r\n    tryUnsubscribe: tryUnsubscribeSelf,\r\n    getListeners: () => listeners\r\n  };\r\n  return subscription;\r\n}\r\n\r\n// src/utils/useIsomorphicLayoutEffect.ts\r\nvar canUseDOM = () => !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\r\nvar isDOM = /* @__PURE__ */ canUseDOM();\r\nvar isRunningInReactNative = () => typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\";\r\nvar isReactNative = /* @__PURE__ */ isRunningInReactNative();\r\nvar getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\r\nvar useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();\r\n\r\n// src/utils/shallowEqual.ts\r\nfunction is(x, y) {\r\n  if (x === y) {\r\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\r\n  } else {\r\n    return x !== x && y !== y;\r\n  }\r\n}\r\nfunction shallowEqual(objA, objB) {\r\n  if (is(objA, objB)) return true;\r\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\r\n    return false;\r\n  }\r\n  const keysA = Object.keys(objA);\r\n  const keysB = Object.keys(objB);\r\n  if (keysA.length !== keysB.length) return false;\r\n  for (let i = 0; i < keysA.length; i++) {\r\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n// src/utils/hoistStatics.ts\r\nvar REACT_STATICS = {\r\n  childContextTypes: true,\r\n  contextType: true,\r\n  contextTypes: true,\r\n  defaultProps: true,\r\n  displayName: true,\r\n  getDefaultProps: true,\r\n  getDerivedStateFromError: true,\r\n  getDerivedStateFromProps: true,\r\n  mixins: true,\r\n  propTypes: true,\r\n  type: true\r\n};\r\nvar KNOWN_STATICS = {\r\n  name: true,\r\n  length: true,\r\n  prototype: true,\r\n  caller: true,\r\n  callee: true,\r\n  arguments: true,\r\n  arity: true\r\n};\r\nvar FORWARD_REF_STATICS = {\r\n  $$typeof: true,\r\n  render: true,\r\n  defaultProps: true,\r\n  displayName: true,\r\n  propTypes: true\r\n};\r\nvar MEMO_STATICS = {\r\n  $$typeof: true,\r\n  compare: true,\r\n  defaultProps: true,\r\n  displayName: true,\r\n  propTypes: true,\r\n  type: true\r\n};\r\nvar TYPE_STATICS = {\r\n  [ForwardRef]: FORWARD_REF_STATICS,\r\n  [Memo]: MEMO_STATICS\r\n};\r\nfunction getStatics(component) {\r\n  if (isMemo(component)) {\r\n    return MEMO_STATICS;\r\n  }\r\n  return TYPE_STATICS[component[\"$$typeof\"]] || REACT_STATICS;\r\n}\r\nvar defineProperty = Object.defineProperty;\r\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\r\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\r\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\r\nvar getPrototypeOf = Object.getPrototypeOf;\r\nvar objectPrototype = Object.prototype;\r\nfunction hoistNonReactStatics(targetComponent, sourceComponent) {\r\n  if (typeof sourceComponent !== \"string\") {\r\n    if (objectPrototype) {\r\n      const inheritedComponent = getPrototypeOf(sourceComponent);\r\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\r\n        hoistNonReactStatics(targetComponent, inheritedComponent);\r\n      }\r\n    }\r\n    let keys = getOwnPropertyNames(sourceComponent);\r\n    if (getOwnPropertySymbols) {\r\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\r\n    }\r\n    const targetStatics = getStatics(targetComponent);\r\n    const sourceStatics = getStatics(sourceComponent);\r\n    for (let i = 0; i < keys.length; ++i) {\r\n      const key = keys[i];\r\n      if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\r\n        const descriptor = getOwnPropertyDescriptor(sourceComponent, key);\r\n        try {\r\n          defineProperty(targetComponent, key, descriptor);\r\n        } catch (e) {\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return targetComponent;\r\n}\r\n\r\n// src/components/Context.ts\r\nvar ContextKey = /* @__PURE__ */ Symbol.for(`react-redux-context`);\r\nvar gT = typeof globalThis !== \"undefined\" ? globalThis : (\r\n  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */\r\n  {}\r\n);\r\nfunction getContext() {\r\n  if (!react__WEBPACK_IMPORTED_MODULE_0__.createContext) return {};\r\n  const contextMap = gT[ContextKey] ??= /* @__PURE__ */ new Map();\r\n  let realContext = contextMap.get(react__WEBPACK_IMPORTED_MODULE_0__.createContext);\r\n  if (!realContext) {\r\n    realContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(\r\n      null\r\n    );\r\n    if (true) {\r\n      realContext.displayName = \"ReactRedux\";\r\n    }\r\n    contextMap.set(react__WEBPACK_IMPORTED_MODULE_0__.createContext, realContext);\r\n  }\r\n  return realContext;\r\n}\r\nvar ReactReduxContext = /* @__PURE__ */ getContext();\r\n\r\n// src/components/connect.tsx\r\nvar NO_SUBSCRIPTION_ARRAY = [null, null];\r\nvar stringifyComponent = (Comp) => {\r\n  try {\r\n    return JSON.stringify(Comp);\r\n  } catch (err) {\r\n    return String(Comp);\r\n  }\r\n};\r\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\r\n  useIsomorphicLayoutEffect(() => effectFunc(...effectArgs), dependencies);\r\n}\r\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {\r\n  lastWrapperProps.current = wrapperProps;\r\n  renderIsScheduled.current = false;\r\n  if (childPropsFromStoreUpdate.current) {\r\n    childPropsFromStoreUpdate.current = null;\r\n    notifyNestedSubs();\r\n  }\r\n}\r\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {\r\n  if (!shouldHandleStateChanges) return () => {\r\n  };\r\n  let didUnsubscribe = false;\r\n  let lastThrownError = null;\r\n  const checkForUpdates = () => {\r\n    if (didUnsubscribe || !isMounted.current) {\r\n      return;\r\n    }\r\n    const latestStoreState = store.getState();\r\n    let newChildProps, error;\r\n    try {\r\n      newChildProps = childPropsSelector(\r\n        latestStoreState,\r\n        lastWrapperProps.current\r\n      );\r\n    } catch (e) {\r\n      error = e;\r\n      lastThrownError = e;\r\n    }\r\n    if (!error) {\r\n      lastThrownError = null;\r\n    }\r\n    if (newChildProps === lastChildProps.current) {\r\n      if (!renderIsScheduled.current) {\r\n        notifyNestedSubs();\r\n      }\r\n    } else {\r\n      lastChildProps.current = newChildProps;\r\n      childPropsFromStoreUpdate.current = newChildProps;\r\n      renderIsScheduled.current = true;\r\n      additionalSubscribeListener();\r\n    }\r\n  };\r\n  subscription.onStateChange = checkForUpdates;\r\n  subscription.trySubscribe();\r\n  checkForUpdates();\r\n  const unsubscribeWrapper = () => {\r\n    didUnsubscribe = true;\r\n    subscription.tryUnsubscribe();\r\n    subscription.onStateChange = null;\r\n    if (lastThrownError) {\r\n      throw lastThrownError;\r\n    }\r\n  };\r\n  return unsubscribeWrapper;\r\n}\r\nfunction strictEqual(a, b) {\r\n  return a === b;\r\n}\r\nvar hasWarnedAboutDeprecatedPureOption = false;\r\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps, {\r\n  // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\r\n  // @ts-ignore\r\n  pure,\r\n  areStatesEqual = strictEqual,\r\n  areOwnPropsEqual = shallowEqual,\r\n  areStatePropsEqual = shallowEqual,\r\n  areMergedPropsEqual = shallowEqual,\r\n  // use React's forwardRef to expose a ref of the wrapped component\r\n  forwardRef = false,\r\n  // the context consumer to use\r\n  context = ReactReduxContext\r\n} = {}) {\r\n  if (true) {\r\n    if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {\r\n      hasWarnedAboutDeprecatedPureOption = true;\r\n      warning(\r\n        'The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component'\r\n      );\r\n    }\r\n  }\r\n  const Context = context;\r\n  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\r\n  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\r\n  const initMergeProps = mergePropsFactory(mergeProps);\r\n  const shouldHandleStateChanges = Boolean(mapStateToProps);\r\n  const wrapWithConnect = (WrappedComponent) => {\r\n    if (true) {\r\n      const isValid = /* @__PURE__ */ isValidElementType(WrappedComponent);\r\n      if (!isValid)\r\n        throw new Error(\r\n          `You must pass a component to the function returned by connect. Instead received ${stringifyComponent(\r\n            WrappedComponent\r\n          )}`\r\n        );\r\n    }\r\n    const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \"Component\";\r\n    const displayName = `Connect(${wrappedComponentName})`;\r\n    const selectorFactoryOptions = {\r\n      shouldHandleStateChanges,\r\n      displayName,\r\n      wrappedComponentName,\r\n      WrappedComponent,\r\n      // @ts-ignore\r\n      initMapStateToProps,\r\n      initMapDispatchToProps,\r\n      initMergeProps,\r\n      areStatesEqual,\r\n      areStatePropsEqual,\r\n      areOwnPropsEqual,\r\n      areMergedPropsEqual\r\n    };\r\n    function ConnectFunction(props) {\r\n      const [propsContext, reactReduxForwardedRef, wrapperProps] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n        const { reactReduxForwardedRef: reactReduxForwardedRef2, ...wrapperProps2 } = props;\r\n        return [props.context, reactReduxForwardedRef2, wrapperProps2];\r\n      }, [props]);\r\n      const ContextToUse = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n        let ResultContext = Context;\r\n        if (propsContext?.Consumer) {\r\n          if (true) {\r\n            const isValid = /* @__PURE__ */ isContextConsumer(\r\n              // @ts-ignore\r\n              /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(propsContext.Consumer, null)\r\n            );\r\n            if (!isValid) {\r\n              throw new Error(\r\n                \"You must pass a valid React context consumer as `props.context`\"\r\n              );\r\n            }\r\n            ResultContext = propsContext;\r\n          }\r\n        }\r\n        return ResultContext;\r\n      }, [propsContext, Context]);\r\n      const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ContextToUse);\r\n      const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\r\n      const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\r\n      if ( true && !didStoreComeFromProps && !didStoreComeFromContext) {\r\n        throw new Error(\r\n          `Could not find \"store\" in the context of \"${displayName}\". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`\r\n        );\r\n      }\r\n      const store = didStoreComeFromProps ? props.store : contextValue.store;\r\n      const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\r\n      const childPropsSelector = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n        return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);\r\n      }, [store]);\r\n      const [subscription, notifyNestedSubs] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;\r\n        const subscription2 = createSubscription(\r\n          store,\r\n          didStoreComeFromProps ? void 0 : contextValue.subscription\r\n        );\r\n        const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);\r\n        return [subscription2, notifyNestedSubs2];\r\n      }, [store, didStoreComeFromProps, contextValue]);\r\n      const overriddenContextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n        if (didStoreComeFromProps) {\r\n          return contextValue;\r\n        }\r\n        return {\r\n          ...contextValue,\r\n          subscription\r\n        };\r\n      }, [didStoreComeFromProps, contextValue, subscription]);\r\n      const lastChildProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\r\n      const lastWrapperProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(wrapperProps);\r\n      const childPropsFromStoreUpdate = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\r\n      const renderIsScheduled = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\r\n      const isMounted = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\r\n      const latestSubscriptionCallbackError = react__WEBPACK_IMPORTED_MODULE_0__.useRef(\r\n        void 0\r\n      );\r\n      useIsomorphicLayoutEffect(() => {\r\n        isMounted.current = true;\r\n        return () => {\r\n          isMounted.current = false;\r\n        };\r\n      }, []);\r\n      const actualChildPropsSelector = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n        const selector = () => {\r\n          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\r\n            return childPropsFromStoreUpdate.current;\r\n          }\r\n          return childPropsSelector(store.getState(), wrapperProps);\r\n        };\r\n        return selector;\r\n      }, [store, wrapperProps]);\r\n      const subscribeForReact = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n        const subscribe = (reactListener) => {\r\n          if (!subscription) {\r\n            return () => {\r\n            };\r\n          }\r\n          return subscribeUpdates(\r\n            shouldHandleStateChanges,\r\n            store,\r\n            subscription,\r\n            // @ts-ignore\r\n            childPropsSelector,\r\n            lastWrapperProps,\r\n            lastChildProps,\r\n            renderIsScheduled,\r\n            isMounted,\r\n            childPropsFromStoreUpdate,\r\n            notifyNestedSubs,\r\n            reactListener\r\n          );\r\n        };\r\n        return subscribe;\r\n      }, [subscription]);\r\n      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [\r\n        lastWrapperProps,\r\n        lastChildProps,\r\n        renderIsScheduled,\r\n        wrapperProps,\r\n        childPropsFromStoreUpdate,\r\n        notifyNestedSubs\r\n      ]);\r\n      let actualChildProps;\r\n      try {\r\n        actualChildProps = react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore(\r\n          // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\r\n          subscribeForReact,\r\n          // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\r\n          // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\r\n          actualChildPropsSelector,\r\n          getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector\r\n        );\r\n      } catch (err) {\r\n        if (latestSubscriptionCallbackError.current) {\r\n          ;\r\n          err.message += `\r\nThe error may be correlated with this previous error:\r\n${latestSubscriptionCallbackError.current.stack}\r\n\r\n`;\r\n        }\r\n        throw err;\r\n      }\r\n      useIsomorphicLayoutEffect(() => {\r\n        latestSubscriptionCallbackError.current = void 0;\r\n        childPropsFromStoreUpdate.current = void 0;\r\n        lastChildProps.current = actualChildProps;\r\n      });\r\n      const renderedWrappedComponent = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n        return (\r\n          // @ts-ignore\r\n          /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\r\n            WrappedComponent,\r\n            {\r\n              ...actualChildProps,\r\n              ref: reactReduxForwardedRef\r\n            }\r\n          )\r\n        );\r\n      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);\r\n      const renderedChild = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n        if (shouldHandleStateChanges) {\r\n          return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextToUse.Provider, { value: overriddenContextValue }, renderedWrappedComponent);\r\n        }\r\n        return renderedWrappedComponent;\r\n      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);\r\n      return renderedChild;\r\n    }\r\n    const _Connect = react__WEBPACK_IMPORTED_MODULE_0__.memo(ConnectFunction);\r\n    const Connect = _Connect;\r\n    Connect.WrappedComponent = WrappedComponent;\r\n    Connect.displayName = ConnectFunction.displayName = displayName;\r\n    if (forwardRef) {\r\n      const _forwarded = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\r\n        function forwardConnectRef(props, ref) {\r\n          return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Connect, { ...props, reactReduxForwardedRef: ref });\r\n        }\r\n      );\r\n      const forwarded = _forwarded;\r\n      forwarded.displayName = displayName;\r\n      forwarded.WrappedComponent = WrappedComponent;\r\n      return /* @__PURE__ */ hoistNonReactStatics(forwarded, WrappedComponent);\r\n    }\r\n    return /* @__PURE__ */ hoistNonReactStatics(Connect, WrappedComponent);\r\n  };\r\n  return wrapWithConnect;\r\n}\r\nvar connect_default = connect;\r\n\r\n// src/components/Provider.tsx\r\nfunction Provider(providerProps) {\r\n  const { children, context, serverState, store } = providerProps;\r\n  const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\r\n    const subscription = createSubscription(store);\r\n    const baseContextValue = {\r\n      store,\r\n      subscription,\r\n      getServerState: serverState ? () => serverState : void 0\r\n    };\r\n    if (false) {} else {\r\n      const { identityFunctionCheck = \"once\", stabilityCheck = \"once\" } = providerProps;\r\n      return /* @__PURE__ */ Object.assign(baseContextValue, {\r\n        stabilityCheck,\r\n        identityFunctionCheck\r\n      });\r\n    }\r\n  }, [store, serverState]);\r\n  const previousState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => store.getState(), [store]);\r\n  useIsomorphicLayoutEffect(() => {\r\n    const { subscription } = contextValue;\r\n    subscription.onStateChange = subscription.notifyNestedSubs;\r\n    subscription.trySubscribe();\r\n    if (previousState !== store.getState()) {\r\n      subscription.notifyNestedSubs();\r\n    }\r\n    return () => {\r\n      subscription.tryUnsubscribe();\r\n      subscription.onStateChange = void 0;\r\n    };\r\n  }, [contextValue, previousState]);\r\n  const Context = context || ReactReduxContext;\r\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Context.Provider, { value: contextValue }, children);\r\n}\r\nvar Provider_default = Provider;\r\n\r\n// src/hooks/useReduxContext.ts\r\nfunction createReduxContextHook(context = ReactReduxContext) {\r\n  return function useReduxContext2() {\r\n    const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\r\n    if ( true && !contextValue) {\r\n      throw new Error(\r\n        \"could not find react-redux context value; please ensure the component is wrapped in a <Provider>\"\r\n      );\r\n    }\r\n    return contextValue;\r\n  };\r\n}\r\nvar useReduxContext = /* @__PURE__ */ createReduxContextHook();\r\n\r\n// src/hooks/useStore.ts\r\nfunction createStoreHook(context = ReactReduxContext) {\r\n  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : (\r\n    // @ts-ignore\r\n    createReduxContextHook(context)\r\n  );\r\n  const useStore2 = () => {\r\n    const { store } = useReduxContext2();\r\n    return store;\r\n  };\r\n  Object.assign(useStore2, {\r\n    withTypes: () => useStore2\r\n  });\r\n  return useStore2;\r\n}\r\nvar useStore = /* @__PURE__ */ createStoreHook();\r\n\r\n// src/hooks/useDispatch.ts\r\nfunction createDispatchHook(context = ReactReduxContext) {\r\n  const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);\r\n  const useDispatch2 = () => {\r\n    const store = useStore2();\r\n    return store.dispatch;\r\n  };\r\n  Object.assign(useDispatch2, {\r\n    withTypes: () => useDispatch2\r\n  });\r\n  return useDispatch2;\r\n}\r\nvar useDispatch = /* @__PURE__ */ createDispatchHook();\r\n\r\n// src/hooks/useSelector.ts\r\n\r\nvar refEquality = (a, b) => a === b;\r\nfunction createSelectorHook(context = ReactReduxContext) {\r\n  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);\r\n  const useSelector2 = (selector, equalityFnOrOptions = {}) => {\r\n    const { equalityFn = refEquality } = typeof equalityFnOrOptions === \"function\" ? { equalityFn: equalityFnOrOptions } : equalityFnOrOptions;\r\n    if (true) {\r\n      if (!selector) {\r\n        throw new Error(`You must pass a selector to useSelector`);\r\n      }\r\n      if (typeof selector !== \"function\") {\r\n        throw new Error(`You must pass a function as a selector to useSelector`);\r\n      }\r\n      if (typeof equalityFn !== \"function\") {\r\n        throw new Error(\r\n          `You must pass a function as an equality function to useSelector`\r\n        );\r\n      }\r\n    }\r\n    const reduxContext = useReduxContext2();\r\n    const { store, subscription, getServerState } = reduxContext;\r\n    const firstRun = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\r\n    const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\r\n      {\r\n        [selector.name](state) {\r\n          const selected = selector(state);\r\n          if (true) {\r\n            const { devModeChecks = {} } = typeof equalityFnOrOptions === \"function\" ? {} : equalityFnOrOptions;\r\n            const { identityFunctionCheck, stabilityCheck } = reduxContext;\r\n            const {\r\n              identityFunctionCheck: finalIdentityFunctionCheck,\r\n              stabilityCheck: finalStabilityCheck\r\n            } = {\r\n              stabilityCheck,\r\n              identityFunctionCheck,\r\n              ...devModeChecks\r\n            };\r\n            if (finalStabilityCheck === \"always\" || finalStabilityCheck === \"once\" && firstRun.current) {\r\n              const toCompare = selector(state);\r\n              if (!equalityFn(selected, toCompare)) {\r\n                let stack = void 0;\r\n                try {\r\n                  throw new Error();\r\n                } catch (e) {\r\n                  ;\r\n                  ({ stack } = e);\r\n                }\r\n                console.warn(\r\n                  \"Selector \" + (selector.name || \"unknown\") + \" returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization\",\r\n                  {\r\n                    state,\r\n                    selected,\r\n                    selected2: toCompare,\r\n                    stack\r\n                  }\r\n                );\r\n              }\r\n            }\r\n            if (finalIdentityFunctionCheck === \"always\" || finalIdentityFunctionCheck === \"once\" && firstRun.current) {\r\n              if (selected === state) {\r\n                let stack = void 0;\r\n                try {\r\n                  throw new Error();\r\n                } catch (e) {\r\n                  ;\r\n                  ({ stack } = e);\r\n                }\r\n                console.warn(\r\n                  \"Selector \" + (selector.name || \"unknown\") + \" returned the root state when called. This can lead to unnecessary rerenders.\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.\",\r\n                  { stack }\r\n                );\r\n              }\r\n            }\r\n            if (firstRun.current) firstRun.current = false;\r\n          }\r\n          return selected;\r\n        }\r\n      }[selector.name],\r\n      [selector]\r\n    );\r\n    const selectedState = (0,use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(\r\n      subscription.addNestedSub,\r\n      store.getState,\r\n      getServerState || store.getState,\r\n      wrappedSelector,\r\n      equalityFn\r\n    );\r\n    react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue(selectedState);\r\n    return selectedState;\r\n  };\r\n  Object.assign(useSelector2, {\r\n    withTypes: () => useSelector2\r\n  });\r\n  return useSelector2;\r\n}\r\nvar useSelector = /* @__PURE__ */ createSelectorHook();\r\n\r\n// src/exports.ts\r\nvar batch = defaultNoopBatch;\r\n\r\n//# sourceMappingURL=react-redux.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZGlzdC9yZWFjdC1yZWR1eC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQytCO0FBQy9CO0FBQ0E7QUFDQSxrQ0FBa0MsMENBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQsSUFBSTtBQUNKO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVyxRQUFRLGFBQWEsK0NBQStDLE1BQU07QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixZQUFZLE1BQU0sTUFBTSxxQ0FBcUMsNkJBQTZCO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxrREFBa0Qsa0NBQWtDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGtEQUFxQixHQUFHLDRDQUFlO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0RBQW1CO0FBQzFCO0FBQ0EsbUNBQW1DLGdEQUFtQjtBQUN0RDtBQUNBLGtCQUFrQixnREFBbUI7QUFDckM7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBLG1CQUFtQixnREFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTixNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFCQUFxQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsMENBQWE7QUFDaEYsZ0JBQWdCLG9FQUFvRTtBQUNwRjtBQUNBLE9BQU87QUFDUCwyQkFBMkIsMENBQWE7QUFDeEM7QUFDQTtBQUNBLGNBQWMsSUFBcUM7QUFDbkQ7QUFDQTtBQUNBLDhCQUE4QixnREFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMkJBQTJCLDZDQUFnQjtBQUMzQztBQUNBO0FBQ0EsVUFBVSxLQUFxQztBQUMvQztBQUNBLHVEQUF1RCxZQUFZLDJKQUEySixhQUFhO0FBQzNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBDQUFhO0FBQzlDO0FBQ0EsT0FBTztBQUNQLCtDQUErQywwQ0FBYTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxxQ0FBcUMsMENBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCLHlDQUFZO0FBQ3pDLCtCQUErQix5Q0FBWTtBQUMzQyx3Q0FBd0MseUNBQVk7QUFDcEQsZ0NBQWdDLHlDQUFZO0FBQzVDLHdCQUF3Qix5Q0FBWTtBQUNwQyw4Q0FBOEMseUNBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsdUNBQXVDLDBDQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGdDQUFnQywwQ0FBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdURBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx1Q0FBdUMsMENBQWE7QUFDcEQ7QUFDQTtBQUNBLDBCQUEwQixnREFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNEJBQTRCLDBDQUFhO0FBQ3pDO0FBQ0EsaUNBQWlDLGdEQUFtQiwwQkFBMEIsK0JBQStCO0FBQzdHO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHFCQUFxQix1Q0FBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2Q0FBZ0I7QUFDekM7QUFDQSxpQ0FBaUMsZ0RBQW1CLFlBQVksdUNBQXVDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0NBQXdDO0FBQ2xELHVCQUF1QiwwQ0FBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNOLGNBQWMsMERBQTBEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCx3QkFBd0IsMENBQWE7QUFDckM7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EseUJBQXlCLGdEQUFtQixxQkFBcUIscUJBQXFCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2Q0FBZ0I7QUFDekMsUUFBUSxLQUFxQztBQUM3QztBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELFlBQVksMkJBQTJCLGdEQUFnRCxrQ0FBa0M7QUFDekgsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0NBQXNDO0FBQ2xELHFCQUFxQix5Q0FBWTtBQUNqQyw0QkFBNEIsOENBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBcUM7QUFDbkQsb0JBQW9CLHFCQUFxQixpREFBaUQ7QUFDMUYsb0JBQW9CLHdDQUF3QztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwwQkFBMEIsMEdBQWdDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWFFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9kaXN0L3JlYWN0LXJlZHV4Lm1qcz84NWI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91dGlscy9yZWFjdC50c1xyXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcclxuXHJcbi8vIHNyYy91dGlscy9yZWFjdC1pcy50c1xyXG52YXIgSVNfUkVBQ1RfMTkgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QudmVyc2lvbi5zdGFydHNXaXRoKFwiMTlcIik7XHJcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcclxuICBJU19SRUFDVF8xOSA/IFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiA6IFwicmVhY3QuZWxlbWVudFwiXHJcbik7XHJcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpO1xyXG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIik7XHJcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTtcclxudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xyXG52YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIik7XHJcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIik7XHJcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKTtcclxudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpO1xyXG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXHJcbiAgXCJyZWFjdC5zdXNwZW5zZV9saXN0XCJcclxuKTtcclxudmFyIFJFQUNUX01FTU9fVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKTtcclxudmFyIFJFQUNUX0xBWllfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKTtcclxudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIik7XHJcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXHJcbiAgXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCJcclxuKTtcclxudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xyXG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcclxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcclxuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05TVU1FUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB2b2lkIDApID8gdHJ1ZSA6IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcclxuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIiAmJiBvYmplY3QgIT09IG51bGwpIHtcclxuICAgIGNvbnN0IHsgJCR0eXBlb2YgfSA9IG9iamVjdDtcclxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcclxuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XHJcbiAgICAgICAgc3dpdGNoIChvYmplY3QgPSBvYmplY3QudHlwZSwgb2JqZWN0KSB7XHJcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XHJcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XHJcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XHJcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XHJcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcclxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHN3aXRjaCAob2JqZWN0ID0gb2JqZWN0ICYmIG9iamVjdC4kJHR5cGVvZiwgb2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XHJcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxyXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxyXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XHJcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcclxuICByZXR1cm4gSVNfUkVBQ1RfMTkgPyB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRSA6IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XHJcbn1cclxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xyXG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xyXG59XHJcblxyXG4vLyBzcmMvdXRpbHMvd2FybmluZy50c1xyXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcclxuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcclxuICB9XHJcbiAgdHJ5IHtcclxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBzcmMvY29ubmVjdC92ZXJpZnlTdWJzZWxlY3RvcnMudHNcclxuZnVuY3Rpb24gdmVyaWZ5KHNlbGVjdG9yLCBtZXRob2ROYW1lKSB7XHJcbiAgaWYgKCFzZWxlY3Rvcikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHZhbHVlIGZvciAke21ldGhvZE5hbWV9IGluIGNvbm5lY3QuYCk7XHJcbiAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSBcIm1hcFN0YXRlVG9Qcm9wc1wiIHx8IG1ldGhvZE5hbWUgPT09IFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpIHtcclxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGVjdG9yLCBcImRlcGVuZHNPbk93blByb3BzXCIpKSB7XHJcbiAgICAgIHdhcm5pbmcoXHJcbiAgICAgICAgYFRoZSBzZWxlY3RvciBmb3IgJHttZXRob2ROYW1lfSBvZiBjb25uZWN0IGRpZCBub3Qgc3BlY2lmeSBhIHZhbHVlIGZvciBkZXBlbmRzT25Pd25Qcm9wcy5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHZlcmlmeVN1YnNlbGVjdG9ycyhtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcykge1xyXG4gIHZlcmlmeShtYXBTdGF0ZVRvUHJvcHMsIFwibWFwU3RhdGVUb1Byb3BzXCIpO1xyXG4gIHZlcmlmeShtYXBEaXNwYXRjaFRvUHJvcHMsIFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpO1xyXG4gIHZlcmlmeShtZXJnZVByb3BzLCBcIm1lcmdlUHJvcHNcIik7XHJcbn1cclxuXHJcbi8vIHNyYy9jb25uZWN0L3NlbGVjdG9yRmFjdG9yeS50c1xyXG5mdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIHtcclxuICBhcmVTdGF0ZXNFcXVhbCxcclxuICBhcmVPd25Qcm9wc0VxdWFsLFxyXG4gIGFyZVN0YXRlUHJvcHNFcXVhbFxyXG59KSB7XHJcbiAgbGV0IGhhc1J1bkF0TGVhc3RPbmNlID0gZmFsc2U7XHJcbiAgbGV0IHN0YXRlO1xyXG4gIGxldCBvd25Qcm9wcztcclxuICBsZXQgc3RhdGVQcm9wcztcclxuICBsZXQgZGlzcGF0Y2hQcm9wcztcclxuICBsZXQgbWVyZ2VkUHJvcHM7XHJcbiAgZnVuY3Rpb24gaGFuZGxlRmlyc3RDYWxsKGZpcnN0U3RhdGUsIGZpcnN0T3duUHJvcHMpIHtcclxuICAgIHN0YXRlID0gZmlyc3RTdGF0ZTtcclxuICAgIG93blByb3BzID0gZmlyc3RPd25Qcm9wcztcclxuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcclxuICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcclxuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XHJcbiAgICBoYXNSdW5BdExlYXN0T25jZSA9IHRydWU7XHJcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKSB7XHJcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XHJcbiAgICBpZiAobWFwRGlzcGF0Y2hUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKVxyXG4gICAgICBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XHJcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xyXG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xyXG4gIH1cclxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wcygpIHtcclxuICAgIGlmIChtYXBTdGF0ZVRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpXHJcbiAgICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcclxuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpXHJcbiAgICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcclxuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XHJcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1N0YXRlKCkge1xyXG4gICAgY29uc3QgbmV4dFN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcclxuICAgIGNvbnN0IHN0YXRlUHJvcHNDaGFuZ2VkID0gIWFyZVN0YXRlUHJvcHNFcXVhbChuZXh0U3RhdGVQcm9wcywgc3RhdGVQcm9wcyk7XHJcbiAgICBzdGF0ZVByb3BzID0gbmV4dFN0YXRlUHJvcHM7XHJcbiAgICBpZiAoc3RhdGVQcm9wc0NoYW5nZWQpXHJcbiAgICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XHJcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGhhbmRsZVN1YnNlcXVlbnRDYWxscyhuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xyXG4gICAgY29uc3QgcHJvcHNDaGFuZ2VkID0gIWFyZU93blByb3BzRXF1YWwobmV4dE93blByb3BzLCBvd25Qcm9wcyk7XHJcbiAgICBjb25zdCBzdGF0ZUNoYW5nZWQgPSAhYXJlU3RhdGVzRXF1YWwoXHJcbiAgICAgIG5leHRTdGF0ZSxcclxuICAgICAgc3RhdGUsXHJcbiAgICAgIG5leHRPd25Qcm9wcyxcclxuICAgICAgb3duUHJvcHNcclxuICAgICk7XHJcbiAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcclxuICAgIG93blByb3BzID0gbmV4dE93blByb3BzO1xyXG4gICAgaWYgKHByb3BzQ2hhbmdlZCAmJiBzdGF0ZUNoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCk7XHJcbiAgICBpZiAocHJvcHNDaGFuZ2VkKSByZXR1cm4gaGFuZGxlTmV3UHJvcHMoKTtcclxuICAgIGlmIChzdGF0ZUNoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdTdGF0ZSgpO1xyXG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xyXG4gIH1cclxuICByZXR1cm4gZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvcihuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xyXG4gICAgcmV0dXJuIGhhc1J1bkF0TGVhc3RPbmNlID8gaGFuZGxlU3Vic2VxdWVudENhbGxzKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSA6IGhhbmRsZUZpcnN0Q2FsbChuZXh0U3RhdGUsIG5leHRPd25Qcm9wcyk7XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBmaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KGRpc3BhdGNoLCB7XHJcbiAgaW5pdE1hcFN0YXRlVG9Qcm9wcyxcclxuICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxyXG4gIGluaXRNZXJnZVByb3BzLFxyXG4gIC4uLm9wdGlvbnNcclxufSkge1xyXG4gIGNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IGluaXRNYXBTdGF0ZVRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xyXG4gIGNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xyXG4gIGNvbnN0IG1lcmdlUHJvcHMgPSBpbml0TWVyZ2VQcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKTtcclxuICB9XHJcbiAgcmV0dXJuIHB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwYXRjaCwgb3B0aW9ucyk7XHJcbn1cclxuXHJcbi8vIHNyYy91dGlscy9iaW5kQWN0aW9uQ3JlYXRvcnMudHNcclxuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCkge1xyXG4gIGNvbnN0IGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcclxuICBmb3IgKGNvbnN0IGtleSBpbiBhY3Rpb25DcmVhdG9ycykge1xyXG4gICAgY29uc3QgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XHJcbiAgICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3IgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICBib3VuZEFjdGlvbkNyZWF0b3JzW2tleV0gPSAoLi4uYXJncykgPT4gZGlzcGF0Y2goYWN0aW9uQ3JlYXRvciguLi5hcmdzKSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xyXG59XHJcblxyXG4vLyBzcmMvdXRpbHMvaXNQbGFpbk9iamVjdC50c1xyXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xyXG4gIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xyXG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XHJcbiAgaWYgKHByb3RvID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcclxuICBsZXQgYmFzZVByb3RvID0gcHJvdG87XHJcbiAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlUHJvdG8pICE9PSBudWxsKSB7XHJcbiAgICBiYXNlUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZVByb3RvKTtcclxuICB9XHJcbiAgcmV0dXJuIHByb3RvID09PSBiYXNlUHJvdG87XHJcbn1cclxuXHJcbi8vIHNyYy91dGlscy92ZXJpZnlQbGFpbk9iamVjdC50c1xyXG5mdW5jdGlvbiB2ZXJpZnlQbGFpbk9iamVjdCh2YWx1ZSwgZGlzcGxheU5hbWUsIG1ldGhvZE5hbWUpIHtcclxuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XHJcbiAgICB3YXJuaW5nKFxyXG4gICAgICBgJHttZXRob2ROYW1lfSgpIGluICR7ZGlzcGxheU5hbWV9IG11c3QgcmV0dXJuIGEgcGxhaW4gb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkICR7dmFsdWV9LmBcclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBzcmMvY29ubmVjdC93cmFwTWFwVG9Qcm9wcy50c1xyXG5mdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGdldENvbnN0YW50KSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRDb25zdGFudFNlbGVjdG9yKGRpc3BhdGNoKSB7XHJcbiAgICBjb25zdCBjb25zdGFudCA9IGdldENvbnN0YW50KGRpc3BhdGNoKTtcclxuICAgIGZ1bmN0aW9uIGNvbnN0YW50U2VsZWN0b3IoKSB7XHJcbiAgICAgIHJldHVybiBjb25zdGFudDtcclxuICAgIH1cclxuICAgIGNvbnN0YW50U2VsZWN0b3IuZGVwZW5kc09uT3duUHJvcHMgPSBmYWxzZTtcclxuICAgIHJldHVybiBjb25zdGFudFNlbGVjdG9yO1xyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcykge1xyXG4gIHJldHVybiBtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzID8gQm9vbGVhbihtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSA6IG1hcFRvUHJvcHMubGVuZ3RoICE9PSAxO1xyXG59XHJcbmZ1bmN0aW9uIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBUb1Byb3BzLCBtZXRob2ROYW1lKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRQcm94eVNlbGVjdG9yKGRpc3BhdGNoLCB7IGRpc3BsYXlOYW1lIH0pIHtcclxuICAgIGNvbnN0IHByb3h5ID0gZnVuY3Rpb24gbWFwVG9Qcm9wc1Byb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcclxuICAgICAgcmV0dXJuIHByb3h5LmRlcGVuZHNPbk93blByb3BzID8gcHJveHkubWFwVG9Qcm9wcyhzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSA6IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoLCB2b2lkIDApO1xyXG4gICAgfTtcclxuICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gdHJ1ZTtcclxuICAgIHByb3h5Lm1hcFRvUHJvcHMgPSBmdW5jdGlvbiBkZXRlY3RGYWN0b3J5QW5kVmVyaWZ5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcclxuICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IG1hcFRvUHJvcHM7XHJcbiAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcyk7XHJcbiAgICAgIGxldCBwcm9wcyA9IHByb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpO1xyXG4gICAgICBpZiAodHlwZW9mIHByb3BzID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBwcm94eS5tYXBUb1Byb3BzID0gcHJvcHM7XHJcbiAgICAgICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSBnZXREZXBlbmRzT25Pd25Qcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKVxyXG4gICAgICAgIHZlcmlmeVBsYWluT2JqZWN0KHByb3BzLCBkaXNwbGF5TmFtZSwgbWV0aG9kTmFtZSk7XHJcbiAgICAgIHJldHVybiBwcm9wcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gcHJveHk7XHJcbiAgfTtcclxufVxyXG5cclxuLy8gc3JjL2Nvbm5lY3QvaW52YWxpZEFyZ0ZhY3RvcnkudHNcclxuZnVuY3Rpb24gY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkoYXJnLCBuYW1lKSB7XHJcbiAgcmV0dXJuIChkaXNwYXRjaCwgb3B0aW9ucykgPT4ge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICBgSW52YWxpZCB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGFyZ30gZm9yICR7bmFtZX0gYXJndW1lbnQgd2hlbiBjb25uZWN0aW5nIGNvbXBvbmVudCAke29wdGlvbnMud3JhcHBlZENvbXBvbmVudE5hbWV9LmBcclxuICAgICk7XHJcbiAgfTtcclxufVxyXG5cclxuLy8gc3JjL2Nvbm5lY3QvbWFwRGlzcGF0Y2hUb1Byb3BzLnRzXHJcbmZ1bmN0aW9uIG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkobWFwRGlzcGF0Y2hUb1Byb3BzKSB7XHJcbiAgcmV0dXJuIG1hcERpc3BhdGNoVG9Qcm9wcyAmJiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSBcIm9iamVjdFwiID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChcclxuICAgIChkaXNwYXRjaCkgPT4gKFxyXG4gICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgIGJpbmRBY3Rpb25DcmVhdG9ycyhtYXBEaXNwYXRjaFRvUHJvcHMsIGRpc3BhdGNoKVxyXG4gICAgKVxyXG4gICkgOiAhbWFwRGlzcGF0Y2hUb1Byb3BzID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudCgoZGlzcGF0Y2gpID0+ICh7XHJcbiAgICBkaXNwYXRjaFxyXG4gIH0pKSA6IHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09IFwiZnVuY3Rpb25cIiA/IChcclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBEaXNwYXRjaFRvUHJvcHMsIFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpXHJcbiAgKSA6IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcywgXCJtYXBEaXNwYXRjaFRvUHJvcHNcIik7XHJcbn1cclxuXHJcbi8vIHNyYy9jb25uZWN0L21hcFN0YXRlVG9Qcm9wcy50c1xyXG5mdW5jdGlvbiBtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcykge1xyXG4gIHJldHVybiAhbWFwU3RhdGVUb1Byb3BzID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudCgoKSA9PiAoe30pKSA6IHR5cGVvZiBtYXBTdGF0ZVRvUHJvcHMgPT09IFwiZnVuY3Rpb25cIiA/IChcclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBTdGF0ZVRvUHJvcHMsIFwibWFwU3RhdGVUb1Byb3BzXCIpXHJcbiAgKSA6IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgXCJtYXBTdGF0ZVRvUHJvcHNcIik7XHJcbn1cclxuXHJcbi8vIHNyYy9jb25uZWN0L21lcmdlUHJvcHMudHNcclxuZnVuY3Rpb24gZGVmYXVsdE1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcclxuICByZXR1cm4geyAuLi5vd25Qcm9wcywgLi4uc3RhdGVQcm9wcywgLi4uZGlzcGF0Y2hQcm9wcyB9O1xyXG59XHJcbmZ1bmN0aW9uIHdyYXBNZXJnZVByb3BzRnVuYyhtZXJnZVByb3BzKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRNZXJnZVByb3BzUHJveHkoZGlzcGF0Y2gsIHsgZGlzcGxheU5hbWUsIGFyZU1lcmdlZFByb3BzRXF1YWwgfSkge1xyXG4gICAgbGV0IGhhc1J1bk9uY2UgPSBmYWxzZTtcclxuICAgIGxldCBtZXJnZWRQcm9wcztcclxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZVByb3BzUHJveHkoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcclxuICAgICAgY29uc3QgbmV4dE1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XHJcbiAgICAgIGlmIChoYXNSdW5PbmNlKSB7XHJcbiAgICAgICAgaWYgKCFhcmVNZXJnZWRQcm9wc0VxdWFsKG5leHRNZXJnZWRQcm9wcywgbWVyZ2VkUHJvcHMpKVxyXG4gICAgICAgICAgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaGFzUnVuT25jZSA9IHRydWU7XHJcbiAgICAgICAgbWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIilcclxuICAgICAgICAgIHZlcmlmeVBsYWluT2JqZWN0KG1lcmdlZFByb3BzLCBkaXNwbGF5TmFtZSwgXCJtZXJnZVByb3BzXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBtZXJnZWRQcm9wcztcclxuICAgIH07XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZVByb3BzRmFjdG9yeShtZXJnZVByb3BzKSB7XHJcbiAgcmV0dXJuICFtZXJnZVByb3BzID8gKCkgPT4gZGVmYXVsdE1lcmdlUHJvcHMgOiB0eXBlb2YgbWVyZ2VQcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWVyZ2VQcm9wcywgXCJtZXJnZVByb3BzXCIpO1xyXG59XHJcblxyXG4vLyBzcmMvdXRpbHMvYmF0Y2gudHNcclxuZnVuY3Rpb24gZGVmYXVsdE5vb3BCYXRjaChjYWxsYmFjaykge1xyXG4gIGNhbGxiYWNrKCk7XHJcbn1cclxuXHJcbi8vIHNyYy91dGlscy9TdWJzY3JpcHRpb24udHNcclxuZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCkge1xyXG4gIGxldCBmaXJzdCA9IG51bGw7XHJcbiAgbGV0IGxhc3QgPSBudWxsO1xyXG4gIHJldHVybiB7XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgZmlyc3QgPSBudWxsO1xyXG4gICAgICBsYXN0ID0gbnVsbDtcclxuICAgIH0sXHJcbiAgICBub3RpZnkoKSB7XHJcbiAgICAgIGRlZmF1bHROb29wQmF0Y2goKCkgPT4ge1xyXG4gICAgICAgIGxldCBsaXN0ZW5lciA9IGZpcnN0O1xyXG4gICAgICAgIHdoaWxlIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2soKTtcclxuICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGdldCgpIHtcclxuICAgICAgY29uc3QgbGlzdGVuZXJzID0gW107XHJcbiAgICAgIGxldCBsaXN0ZW5lciA9IGZpcnN0O1xyXG4gICAgICB3aGlsZSAobGlzdGVuZXIpIHtcclxuICAgICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBsaXN0ZW5lcnM7XHJcbiAgICB9LFxyXG4gICAgc3Vic2NyaWJlKGNhbGxiYWNrKSB7XHJcbiAgICAgIGxldCBpc1N1YnNjcmliZWQgPSB0cnVlO1xyXG4gICAgICBjb25zdCBsaXN0ZW5lciA9IGxhc3QgPSB7XHJcbiAgICAgICAgY2FsbGJhY2ssXHJcbiAgICAgICAgbmV4dDogbnVsbCxcclxuICAgICAgICBwcmV2OiBsYXN0XHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChsaXN0ZW5lci5wcmV2KSB7XHJcbiAgICAgICAgbGlzdGVuZXIucHJldi5uZXh0ID0gbGlzdGVuZXI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZmlyc3QgPSBsaXN0ZW5lcjtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XHJcbiAgICAgICAgaWYgKCFpc1N1YnNjcmliZWQgfHwgZmlyc3QgPT09IG51bGwpIHJldHVybjtcclxuICAgICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcclxuICAgICAgICBpZiAobGlzdGVuZXIubmV4dCkge1xyXG4gICAgICAgICAgbGlzdGVuZXIubmV4dC5wcmV2ID0gbGlzdGVuZXIucHJldjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbGFzdCA9IGxpc3RlbmVyLnByZXY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaXN0ZW5lci5wcmV2KSB7XHJcbiAgICAgICAgICBsaXN0ZW5lci5wcmV2Lm5leHQgPSBsaXN0ZW5lci5uZXh0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmaXJzdCA9IGxpc3RlbmVyLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxudmFyIG51bGxMaXN0ZW5lcnMgPSB7XHJcbiAgbm90aWZ5KCkge1xyXG4gIH0sXHJcbiAgZ2V0OiAoKSA9PiBbXVxyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVTdWJzY3JpcHRpb24oc3RvcmUsIHBhcmVudFN1Yikge1xyXG4gIGxldCB1bnN1YnNjcmliZTtcclxuICBsZXQgbGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcclxuICBsZXQgc3Vic2NyaXB0aW9uc0Ftb3VudCA9IDA7XHJcbiAgbGV0IHNlbGZTdWJzY3JpYmVkID0gZmFsc2U7XHJcbiAgZnVuY3Rpb24gYWRkTmVzdGVkU3ViKGxpc3RlbmVyKSB7XHJcbiAgICB0cnlTdWJzY3JpYmUoKTtcclxuICAgIGNvbnN0IGNsZWFudXBMaXN0ZW5lciA9IGxpc3RlbmVycy5zdWJzY3JpYmUobGlzdGVuZXIpO1xyXG4gICAgbGV0IHJlbW92ZWQgPSBmYWxzZTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGlmICghcmVtb3ZlZCkge1xyXG4gICAgICAgIHJlbW92ZWQgPSB0cnVlO1xyXG4gICAgICAgIGNsZWFudXBMaXN0ZW5lcigpO1xyXG4gICAgICAgIHRyeVVuc3Vic2NyaWJlKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIG5vdGlmeU5lc3RlZFN1YnMoKSB7XHJcbiAgICBsaXN0ZW5lcnMubm90aWZ5KCk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGhhbmRsZUNoYW5nZVdyYXBwZXIoKSB7XHJcbiAgICBpZiAoc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UpIHtcclxuICAgICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UoKTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xyXG4gICAgcmV0dXJuIHNlbGZTdWJzY3JpYmVkO1xyXG4gIH1cclxuICBmdW5jdGlvbiB0cnlTdWJzY3JpYmUoKSB7XHJcbiAgICBzdWJzY3JpcHRpb25zQW1vdW50Kys7XHJcbiAgICBpZiAoIXVuc3Vic2NyaWJlKSB7XHJcbiAgICAgIHVuc3Vic2NyaWJlID0gcGFyZW50U3ViID8gcGFyZW50U3ViLmFkZE5lc3RlZFN1YihoYW5kbGVDaGFuZ2VXcmFwcGVyKSA6IHN0b3JlLnN1YnNjcmliZShoYW5kbGVDaGFuZ2VXcmFwcGVyKTtcclxuICAgICAgbGlzdGVuZXJzID0gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlKCkge1xyXG4gICAgc3Vic2NyaXB0aW9uc0Ftb3VudC0tO1xyXG4gICAgaWYgKHVuc3Vic2NyaWJlICYmIHN1YnNjcmlwdGlvbnNBbW91bnQgPT09IDApIHtcclxuICAgICAgdW5zdWJzY3JpYmUoKTtcclxuICAgICAgdW5zdWJzY3JpYmUgPSB2b2lkIDA7XHJcbiAgICAgIGxpc3RlbmVycy5jbGVhcigpO1xyXG4gICAgICBsaXN0ZW5lcnMgPSBudWxsTGlzdGVuZXJzO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiB0cnlTdWJzY3JpYmVTZWxmKCkge1xyXG4gICAgaWYgKCFzZWxmU3Vic2NyaWJlZCkge1xyXG4gICAgICBzZWxmU3Vic2NyaWJlZCA9IHRydWU7XHJcbiAgICAgIHRyeVN1YnNjcmliZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZVNlbGYoKSB7XHJcbiAgICBpZiAoc2VsZlN1YnNjcmliZWQpIHtcclxuICAgICAgc2VsZlN1YnNjcmliZWQgPSBmYWxzZTtcclxuICAgICAgdHJ5VW5zdWJzY3JpYmUoKTtcclxuICAgIH1cclxuICB9XHJcbiAgY29uc3Qgc3Vic2NyaXB0aW9uID0ge1xyXG4gICAgYWRkTmVzdGVkU3ViLFxyXG4gICAgbm90aWZ5TmVzdGVkU3VicyxcclxuICAgIGhhbmRsZUNoYW5nZVdyYXBwZXIsXHJcbiAgICBpc1N1YnNjcmliZWQsXHJcbiAgICB0cnlTdWJzY3JpYmU6IHRyeVN1YnNjcmliZVNlbGYsXHJcbiAgICB0cnlVbnN1YnNjcmliZTogdHJ5VW5zdWJzY3JpYmVTZWxmLFxyXG4gICAgZ2V0TGlzdGVuZXJzOiAoKSA9PiBsaXN0ZW5lcnNcclxuICB9O1xyXG4gIHJldHVybiBzdWJzY3JpcHRpb247XHJcbn1cclxuXHJcbi8vIHNyYy91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LnRzXHJcbnZhciBjYW5Vc2VET00gPSAoKSA9PiAhISh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiKTtcclxudmFyIGlzRE9NID0gLyogQF9fUFVSRV9fICovIGNhblVzZURPTSgpO1xyXG52YXIgaXNSdW5uaW5nSW5SZWFjdE5hdGl2ZSA9ICgpID0+IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwiUmVhY3ROYXRpdmVcIjtcclxudmFyIGlzUmVhY3ROYXRpdmUgPSAvKiBAX19QVVJFX18gKi8gaXNSdW5uaW5nSW5SZWFjdE5hdGl2ZSgpO1xyXG52YXIgZ2V0VXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9ICgpID0+IGlzRE9NIHx8IGlzUmVhY3ROYXRpdmUgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XHJcbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gLyogQF9fUFVSRV9fICovIGdldFVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKTtcclxuXHJcbi8vIHNyYy91dGlscy9zaGFsbG93RXF1YWwudHNcclxuZnVuY3Rpb24gaXMoeCwgeSkge1xyXG4gIGlmICh4ID09PSB5KSB7XHJcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcclxuICBpZiAoaXMob2JqQSwgb2JqQikpIHJldHVybiB0cnVlO1xyXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gXCJvYmplY3RcIiB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSBcIm9iamVjdFwiIHx8IG9iakIgPT09IG51bGwpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcclxuICBjb25zdCBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xyXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG4vLyBzcmMvdXRpbHMvaG9pc3RTdGF0aWNzLnRzXHJcbnZhciBSRUFDVF9TVEFUSUNTID0ge1xyXG4gIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxyXG4gIGNvbnRleHRUeXBlOiB0cnVlLFxyXG4gIGNvbnRleHRUeXBlczogdHJ1ZSxcclxuICBkZWZhdWx0UHJvcHM6IHRydWUsXHJcbiAgZGlzcGxheU5hbWU6IHRydWUsXHJcbiAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxyXG4gIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogdHJ1ZSxcclxuICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHRydWUsXHJcbiAgbWl4aW5zOiB0cnVlLFxyXG4gIHByb3BUeXBlczogdHJ1ZSxcclxuICB0eXBlOiB0cnVlXHJcbn07XHJcbnZhciBLTk9XTl9TVEFUSUNTID0ge1xyXG4gIG5hbWU6IHRydWUsXHJcbiAgbGVuZ3RoOiB0cnVlLFxyXG4gIHByb3RvdHlwZTogdHJ1ZSxcclxuICBjYWxsZXI6IHRydWUsXHJcbiAgY2FsbGVlOiB0cnVlLFxyXG4gIGFyZ3VtZW50czogdHJ1ZSxcclxuICBhcml0eTogdHJ1ZVxyXG59O1xyXG52YXIgRk9SV0FSRF9SRUZfU1RBVElDUyA9IHtcclxuICAkJHR5cGVvZjogdHJ1ZSxcclxuICByZW5kZXI6IHRydWUsXHJcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxyXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxyXG4gIHByb3BUeXBlczogdHJ1ZVxyXG59O1xyXG52YXIgTUVNT19TVEFUSUNTID0ge1xyXG4gICQkdHlwZW9mOiB0cnVlLFxyXG4gIGNvbXBhcmU6IHRydWUsXHJcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxyXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxyXG4gIHByb3BUeXBlczogdHJ1ZSxcclxuICB0eXBlOiB0cnVlXHJcbn07XHJcbnZhciBUWVBFX1NUQVRJQ1MgPSB7XHJcbiAgW0ZvcndhcmRSZWZdOiBGT1JXQVJEX1JFRl9TVEFUSUNTLFxyXG4gIFtNZW1vXTogTUVNT19TVEFUSUNTXHJcbn07XHJcbmZ1bmN0aW9uIGdldFN0YXRpY3MoY29tcG9uZW50KSB7XHJcbiAgaWYgKGlzTWVtbyhjb21wb25lbnQpKSB7XHJcbiAgICByZXR1cm4gTUVNT19TVEFUSUNTO1xyXG4gIH1cclxuICByZXR1cm4gVFlQRV9TVEFUSUNTW2NvbXBvbmVudFtcIiQkdHlwZW9mXCJdXSB8fCBSRUFDVF9TVEFUSUNTO1xyXG59XHJcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcclxudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcclxudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XHJcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xyXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XHJcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xyXG5mdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCkge1xyXG4gIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICBpZiAob2JqZWN0UHJvdG90eXBlKSB7XHJcbiAgICAgIGNvbnN0IGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XHJcbiAgICAgIGlmIChpbmhlcml0ZWRDb21wb25lbnQgJiYgaW5oZXJpdGVkQ29tcG9uZW50ICE9PSBvYmplY3RQcm90b3R5cGUpIHtcclxuICAgICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xyXG4gICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xyXG4gICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGFyZ2V0U3RhdGljcyA9IGdldFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50KTtcclxuICAgIGNvbnN0IHNvdXJjZVN0YXRpY3MgPSBnZXRTdGF0aWNzKHNvdXJjZUNvbXBvbmVudCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcclxuICAgICAgaWYgKCFLTk9XTl9TVEFUSUNTW2tleV0gJiYgIShzb3VyY2VTdGF0aWNzICYmIHNvdXJjZVN0YXRpY3Nba2V5XSkgJiYgISh0YXJnZXRTdGF0aWNzICYmIHRhcmdldFN0YXRpY3Nba2V5XSkpIHtcclxuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0Q29tcG9uZW50LCBrZXksIGRlc2NyaXB0b3IpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcclxufVxyXG5cclxuLy8gc3JjL2NvbXBvbmVudHMvQ29udGV4dC50c1xyXG52YXIgQ29udGV4dEtleSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKGByZWFjdC1yZWR1eC1jb250ZXh0YCk7XHJcbnZhciBnVCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IChcclxuICAvKiBmYWxsIGJhY2sgdG8gYSBwZXItbW9kdWxlIHNjb3BlIChwcmUtOC4xIGJlaGF2aW91cikgaWYgYGdsb2JhbFRoaXNgIGlzIG5vdCBhdmFpbGFibGUgKi9cclxuICB7fVxyXG4pO1xyXG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xyXG4gIGlmICghUmVhY3QuY3JlYXRlQ29udGV4dCkgcmV0dXJuIHt9O1xyXG4gIGNvbnN0IGNvbnRleHRNYXAgPSBnVFtDb250ZXh0S2V5XSA/Pz0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcclxuICBsZXQgcmVhbENvbnRleHQgPSBjb250ZXh0TWFwLmdldChSZWFjdC5jcmVhdGVDb250ZXh0KTtcclxuICBpZiAoIXJlYWxDb250ZXh0KSB7XHJcbiAgICByZWFsQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoXHJcbiAgICAgIG51bGxcclxuICAgICk7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgIHJlYWxDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSZWFjdFJlZHV4XCI7XHJcbiAgICB9XHJcbiAgICBjb250ZXh0TWFwLnNldChSZWFjdC5jcmVhdGVDb250ZXh0LCByZWFsQ29udGV4dCk7XHJcbiAgfVxyXG4gIHJldHVybiByZWFsQ29udGV4dDtcclxufVxyXG52YXIgUmVhY3RSZWR1eENvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gZ2V0Q29udGV4dCgpO1xyXG5cclxuLy8gc3JjL2NvbXBvbmVudHMvY29ubmVjdC50c3hcclxudmFyIE5PX1NVQlNDUklQVElPTl9BUlJBWSA9IFtudWxsLCBudWxsXTtcclxudmFyIHN0cmluZ2lmeUNvbXBvbmVudCA9IChDb21wKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShDb21wKTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIHJldHVybiBTdHJpbmcoQ29tcCk7XHJcbiAgfVxyXG59O1xyXG5mdW5jdGlvbiB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0V2l0aEFyZ3MoZWZmZWN0RnVuYywgZWZmZWN0QXJncywgZGVwZW5kZW5jaWVzKSB7XHJcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiBlZmZlY3RGdW5jKC4uLmVmZmVjdEFyZ3MpLCBkZXBlbmRlbmNpZXMpO1xyXG59XHJcbmZ1bmN0aW9uIGNhcHR1cmVXcmFwcGVyUHJvcHMobGFzdFdyYXBwZXJQcm9wcywgbGFzdENoaWxkUHJvcHMsIHJlbmRlcklzU2NoZWR1bGVkLCB3cmFwcGVyUHJvcHMsIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsIG5vdGlmeU5lc3RlZFN1YnMpIHtcclxuICBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnQgPSB3cmFwcGVyUHJvcHM7XHJcbiAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IGZhbHNlO1xyXG4gIGlmIChjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQpIHtcclxuICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IG51bGw7XHJcbiAgICBub3RpZnlOZXN0ZWRTdWJzKCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHN1YnNjcmliZVVwZGF0ZXMoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLCBzdG9yZSwgc3Vic2NyaXB0aW9uLCBjaGlsZFByb3BzU2VsZWN0b3IsIGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgaXNNb3VudGVkLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzLCBhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIpIHtcclxuICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuICgpID0+IHtcclxuICB9O1xyXG4gIGxldCBkaWRVbnN1YnNjcmliZSA9IGZhbHNlO1xyXG4gIGxldCBsYXN0VGhyb3duRXJyb3IgPSBudWxsO1xyXG4gIGNvbnN0IGNoZWNrRm9yVXBkYXRlcyA9ICgpID0+IHtcclxuICAgIGlmIChkaWRVbnN1YnNjcmliZSB8fCAhaXNNb3VudGVkLmN1cnJlbnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGF0ZXN0U3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICBsZXQgbmV3Q2hpbGRQcm9wcywgZXJyb3I7XHJcbiAgICB0cnkge1xyXG4gICAgICBuZXdDaGlsZFByb3BzID0gY2hpbGRQcm9wc1NlbGVjdG9yKFxyXG4gICAgICAgIGxhdGVzdFN0b3JlU3RhdGUsXHJcbiAgICAgICAgbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50XHJcbiAgICAgICk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGVycm9yID0gZTtcclxuICAgICAgbGFzdFRocm93bkVycm9yID0gZTtcclxuICAgIH1cclxuICAgIGlmICghZXJyb3IpIHtcclxuICAgICAgbGFzdFRocm93bkVycm9yID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmIChuZXdDaGlsZFByb3BzID09PSBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50KSB7XHJcbiAgICAgIGlmICghcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCkge1xyXG4gICAgICAgIG5vdGlmeU5lc3RlZFN1YnMoKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGFzdENoaWxkUHJvcHMuY3VycmVudCA9IG5ld0NoaWxkUHJvcHM7XHJcbiAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IG5ld0NoaWxkUHJvcHM7XHJcbiAgICAgIHJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICBhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIoKTtcclxuICAgIH1cclxuICB9O1xyXG4gIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gY2hlY2tGb3JVcGRhdGVzO1xyXG4gIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcclxuICBjaGVja0ZvclVwZGF0ZXMoKTtcclxuICBjb25zdCB1bnN1YnNjcmliZVdyYXBwZXIgPSAoKSA9PiB7XHJcbiAgICBkaWRVbnN1YnNjcmliZSA9IHRydWU7XHJcbiAgICBzdWJzY3JpcHRpb24udHJ5VW5zdWJzY3JpYmUoKTtcclxuICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gbnVsbDtcclxuICAgIGlmIChsYXN0VGhyb3duRXJyb3IpIHtcclxuICAgICAgdGhyb3cgbGFzdFRocm93bkVycm9yO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgcmV0dXJuIHVuc3Vic2NyaWJlV3JhcHBlcjtcclxufVxyXG5mdW5jdGlvbiBzdHJpY3RFcXVhbChhLCBiKSB7XHJcbiAgcmV0dXJuIGEgPT09IGI7XHJcbn1cclxudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24gPSBmYWxzZTtcclxuZnVuY3Rpb24gY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywge1xyXG4gIC8vIFRoZSBgcHVyZWAgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQsIHNvIFRTIGRvZXNuJ3QgbGlrZSB1cyBkZXN0cnVjdHVyaW5nIHRoaXMgdG8gY2hlY2sgaXRzIGV4aXN0ZW5jZS5cclxuICAvLyBAdHMtaWdub3JlXHJcbiAgcHVyZSxcclxuICBhcmVTdGF0ZXNFcXVhbCA9IHN0cmljdEVxdWFsLFxyXG4gIGFyZU93blByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXHJcbiAgYXJlU3RhdGVQcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxyXG4gIGFyZU1lcmdlZFByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXHJcbiAgLy8gdXNlIFJlYWN0J3MgZm9yd2FyZFJlZiB0byBleHBvc2UgYSByZWYgb2YgdGhlIHdyYXBwZWQgY29tcG9uZW50XHJcbiAgZm9yd2FyZFJlZiA9IGZhbHNlLFxyXG4gIC8vIHRoZSBjb250ZXh0IGNvbnN1bWVyIHRvIHVzZVxyXG4gIGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dFxyXG59ID0ge30pIHtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICBpZiAocHVyZSAhPT0gdm9pZCAwICYmICFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uKSB7XHJcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24gPSB0cnVlO1xyXG4gICAgICB3YXJuaW5nKFxyXG4gICAgICAgICdUaGUgYHB1cmVgIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkLiBgY29ubmVjdGAgaXMgbm93IGFsd2F5cyBhIFwicHVyZS9tZW1vaXplZFwiIGNvbXBvbmVudCdcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbiAgY29uc3QgQ29udGV4dCA9IGNvbnRleHQ7XHJcbiAgY29uc3QgaW5pdE1hcFN0YXRlVG9Qcm9wcyA9IG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzKTtcclxuICBjb25zdCBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeShtYXBEaXNwYXRjaFRvUHJvcHMpO1xyXG4gIGNvbnN0IGluaXRNZXJnZVByb3BzID0gbWVyZ2VQcm9wc0ZhY3RvcnkobWVyZ2VQcm9wcyk7XHJcbiAgY29uc3Qgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzID0gQm9vbGVhbihtYXBTdGF0ZVRvUHJvcHMpO1xyXG4gIGNvbnN0IHdyYXBXaXRoQ29ubmVjdCA9IChXcmFwcGVkQ29tcG9uZW50KSA9PiB7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSAvKiBAX19QVVJFX18gKi8gaXNWYWxpZEVsZW1lbnRUeXBlKFdyYXBwZWRDb21wb25lbnQpO1xyXG4gICAgICBpZiAoIWlzVmFsaWQpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgYFlvdSBtdXN0IHBhc3MgYSBjb21wb25lbnQgdG8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IGNvbm5lY3QuIEluc3RlYWQgcmVjZWl2ZWQgJHtzdHJpbmdpZnlDb21wb25lbnQoXHJcbiAgICAgICAgICAgIFdyYXBwZWRDb21wb25lbnRcclxuICAgICAgICAgICl9YFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB3cmFwcGVkQ29tcG9uZW50TmFtZSA9IFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8IFwiQ29tcG9uZW50XCI7XHJcbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGBDb25uZWN0KCR7d3JhcHBlZENvbXBvbmVudE5hbWV9KWA7XHJcbiAgICBjb25zdCBzZWxlY3RvckZhY3RvcnlPcHRpb25zID0ge1xyXG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXHJcbiAgICAgIGRpc3BsYXlOYW1lLFxyXG4gICAgICB3cmFwcGVkQ29tcG9uZW50TmFtZSxcclxuICAgICAgV3JhcHBlZENvbXBvbmVudCxcclxuICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICBpbml0TWFwU3RhdGVUb1Byb3BzLFxyXG4gICAgICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxyXG4gICAgICBpbml0TWVyZ2VQcm9wcyxcclxuICAgICAgYXJlU3RhdGVzRXF1YWwsXHJcbiAgICAgIGFyZVN0YXRlUHJvcHNFcXVhbCxcclxuICAgICAgYXJlT3duUHJvcHNFcXVhbCxcclxuICAgICAgYXJlTWVyZ2VkUHJvcHNFcXVhbFxyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIENvbm5lY3RGdW5jdGlvbihwcm9wcykge1xyXG4gICAgICBjb25zdCBbcHJvcHNDb250ZXh0LCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmLCB3cmFwcGVyUHJvcHNdID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmOiByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmMiwgLi4ud3JhcHBlclByb3BzMiB9ID0gcHJvcHM7XHJcbiAgICAgICAgcmV0dXJuIFtwcm9wcy5jb250ZXh0LCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmMiwgd3JhcHBlclByb3BzMl07XHJcbiAgICAgIH0sIFtwcm9wc10pO1xyXG4gICAgICBjb25zdCBDb250ZXh0VG9Vc2UgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcclxuICAgICAgICBsZXQgUmVzdWx0Q29udGV4dCA9IENvbnRleHQ7XHJcbiAgICAgICAgaWYgKHByb3BzQ29udGV4dD8uQ29uc3VtZXIpIHtcclxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IC8qIEBfX1BVUkVfXyAqLyBpc0NvbnRleHRDb25zdW1lcihcclxuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQocHJvcHNDb250ZXh0LkNvbnN1bWVyLCBudWxsKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICBcIllvdSBtdXN0IHBhc3MgYSB2YWxpZCBSZWFjdCBjb250ZXh0IGNvbnN1bWVyIGFzIGBwcm9wcy5jb250ZXh0YFwiXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBSZXN1bHRDb250ZXh0ID0gcHJvcHNDb250ZXh0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmVzdWx0Q29udGV4dDtcclxuICAgICAgfSwgW3Byb3BzQ29udGV4dCwgQ29udGV4dF0pO1xyXG4gICAgICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KENvbnRleHRUb1VzZSk7XHJcbiAgICAgIGNvbnN0IGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA9IEJvb2xlYW4ocHJvcHMuc3RvcmUpICYmIEJvb2xlYW4ocHJvcHMuc3RvcmUuZ2V0U3RhdGUpICYmIEJvb2xlYW4ocHJvcHMuc3RvcmUuZGlzcGF0Y2gpO1xyXG4gICAgICBjb25zdCBkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCA9IEJvb2xlYW4oY29udGV4dFZhbHVlKSAmJiBCb29sZWFuKGNvbnRleHRWYWx1ZS5zdG9yZSk7XHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWRpZFN0b3JlQ29tZUZyb21Qcm9wcyAmJiAhZGlkU3RvcmVDb21lRnJvbUNvbnRleHQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICBgQ291bGQgbm90IGZpbmQgXCJzdG9yZVwiIGluIHRoZSBjb250ZXh0IG9mIFwiJHtkaXNwbGF5TmFtZX1cIi4gRWl0aGVyIHdyYXAgdGhlIHJvb3QgY29tcG9uZW50IGluIGEgPFByb3ZpZGVyPiwgb3IgcGFzcyBhIGN1c3RvbSBSZWFjdCBjb250ZXh0IHByb3ZpZGVyIHRvIDxQcm92aWRlcj4gYW5kIHRoZSBjb3JyZXNwb25kaW5nIFJlYWN0IGNvbnRleHQgY29uc3VtZXIgdG8gJHtkaXNwbGF5TmFtZX0gaW4gY29ubmVjdCBvcHRpb25zLmBcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHN0b3JlID0gZGlkU3RvcmVDb21lRnJvbVByb3BzID8gcHJvcHMuc3RvcmUgOiBjb250ZXh0VmFsdWUuc3RvcmU7XHJcbiAgICAgIGNvbnN0IGdldFNlcnZlclN0YXRlID0gZGlkU3RvcmVDb21lRnJvbUNvbnRleHQgPyBjb250ZXh0VmFsdWUuZ2V0U2VydmVyU3RhdGUgOiBzdG9yZS5nZXRTdGF0ZTtcclxuICAgICAgY29uc3QgY2hpbGRQcm9wc1NlbGVjdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGZpbmFsUHJvcHNTZWxlY3RvckZhY3Rvcnkoc3RvcmUuZGlzcGF0Y2gsIHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMpO1xyXG4gICAgICB9LCBbc3RvcmVdKTtcclxuICAgICAgY29uc3QgW3N1YnNjcmlwdGlvbiwgbm90aWZ5TmVzdGVkU3Vic10gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcclxuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuIE5PX1NVQlNDUklQVElPTl9BUlJBWTtcclxuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24yID0gY3JlYXRlU3Vic2NyaXB0aW9uKFxyXG4gICAgICAgICAgc3RvcmUsXHJcbiAgICAgICAgICBkaWRTdG9yZUNvbWVGcm9tUHJvcHMgPyB2b2lkIDAgOiBjb250ZXh0VmFsdWUuc3Vic2NyaXB0aW9uXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zdCBub3RpZnlOZXN0ZWRTdWJzMiA9IHN1YnNjcmlwdGlvbjIubm90aWZ5TmVzdGVkU3Vicy5iaW5kKHN1YnNjcmlwdGlvbjIpO1xyXG4gICAgICAgIHJldHVybiBbc3Vic2NyaXB0aW9uMiwgbm90aWZ5TmVzdGVkU3ViczJdO1xyXG4gICAgICB9LCBbc3RvcmUsIGRpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlXSk7XHJcbiAgICAgIGNvbnN0IG92ZXJyaWRkZW5Db250ZXh0VmFsdWUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcclxuICAgICAgICBpZiAoZGlkU3RvcmVDb21lRnJvbVByb3BzKSB7XHJcbiAgICAgICAgICByZXR1cm4gY29udGV4dFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgLi4uY29udGV4dFZhbHVlLFxyXG4gICAgICAgICAgc3Vic2NyaXB0aW9uXHJcbiAgICAgICAgfTtcclxuICAgICAgfSwgW2RpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlLCBzdWJzY3JpcHRpb25dKTtcclxuICAgICAgY29uc3QgbGFzdENoaWxkUHJvcHMgPSBSZWFjdC51c2VSZWYodm9pZCAwKTtcclxuICAgICAgY29uc3QgbGFzdFdyYXBwZXJQcm9wcyA9IFJlYWN0LnVzZVJlZih3cmFwcGVyUHJvcHMpO1xyXG4gICAgICBjb25zdCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlID0gUmVhY3QudXNlUmVmKHZvaWQgMCk7XHJcbiAgICAgIGNvbnN0IHJlbmRlcklzU2NoZWR1bGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcclxuICAgICAgY29uc3QgaXNNb3VudGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcclxuICAgICAgY29uc3QgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciA9IFJlYWN0LnVzZVJlZihcclxuICAgICAgICB2b2lkIDBcclxuICAgICAgKTtcclxuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH0sIFtdKTtcclxuICAgICAgY29uc3QgYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAoKSA9PiB7XHJcbiAgICAgICAgICBpZiAoY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ICYmIHdyYXBwZXJQcm9wcyA9PT0gbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gY2hpbGRQcm9wc1NlbGVjdG9yKHN0b3JlLmdldFN0YXRlKCksIHdyYXBwZXJQcm9wcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XHJcbiAgICAgIH0sIFtzdG9yZSwgd3JhcHBlclByb3BzXSk7XHJcbiAgICAgIGNvbnN0IHN1YnNjcmliZUZvclJlYWN0ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlID0gKHJlYWN0TGlzdGVuZXIpID0+IHtcclxuICAgICAgICAgIGlmICghc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlVXBkYXRlcyhcclxuICAgICAgICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLFxyXG4gICAgICAgICAgICBzdG9yZSxcclxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLFxyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIGNoaWxkUHJvcHNTZWxlY3RvcixcclxuICAgICAgICAgICAgbGFzdFdyYXBwZXJQcm9wcyxcclxuICAgICAgICAgICAgbGFzdENoaWxkUHJvcHMsXHJcbiAgICAgICAgICAgIHJlbmRlcklzU2NoZWR1bGVkLFxyXG4gICAgICAgICAgICBpc01vdW50ZWQsXHJcbiAgICAgICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsXHJcbiAgICAgICAgICAgIG5vdGlmeU5lc3RlZFN1YnMsXHJcbiAgICAgICAgICAgIHJlYWN0TGlzdGVuZXJcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlO1xyXG4gICAgICB9LCBbc3Vic2NyaXB0aW9uXSk7XHJcbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyhjYXB0dXJlV3JhcHBlclByb3BzLCBbXHJcbiAgICAgICAgbGFzdFdyYXBwZXJQcm9wcyxcclxuICAgICAgICBsYXN0Q2hpbGRQcm9wcyxcclxuICAgICAgICByZW5kZXJJc1NjaGVkdWxlZCxcclxuICAgICAgICB3cmFwcGVyUHJvcHMsXHJcbiAgICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSxcclxuICAgICAgICBub3RpZnlOZXN0ZWRTdWJzXHJcbiAgICAgIF0pO1xyXG4gICAgICBsZXQgYWN0dWFsQ2hpbGRQcm9wcztcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhY3R1YWxDaGlsZFByb3BzID0gUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUoXHJcbiAgICAgICAgICAvLyBUT0RPIFdlJ3JlIHBhc3NpbmcgdGhyb3VnaCBhIGJpZyB3cmFwcGVyIHRoYXQgZG9lcyBhIGJ1bmNoIG9mIGV4dHJhIHNpZGUgZWZmZWN0cyBiZXNpZGVzIHN1YnNjcmliaW5nXHJcbiAgICAgICAgICBzdWJzY3JpYmVGb3JSZWFjdCxcclxuICAgICAgICAgIC8vIFRPRE8gVGhpcyBpcyBpbmNyZWRpYmx5IGhhY2t5LiBXZSd2ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGUgc3RvcmUgdXBkYXRlIGFuZCBjYWxjdWxhdGVkIG5ldyBjaGlsZCBwcm9wcyxcclxuICAgICAgICAgIC8vIFRPRE8gYW5kIHdlJ3JlIGp1c3QgcGFzc2luZyB0aGF0IHRocm91Z2ggc28gaXQgdHJpZ2dlcnMgYSByZS1yZW5kZXIgZm9yIHVzIHJhdGhlciB0aGFuIHJlbHlpbmcgb24gYHVTRVNgLlxyXG4gICAgICAgICAgYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yLFxyXG4gICAgICAgICAgZ2V0U2VydmVyU3RhdGUgPyAoKSA9PiBjaGlsZFByb3BzU2VsZWN0b3IoZ2V0U2VydmVyU3RhdGUoKSwgd3JhcHBlclByb3BzKSA6IGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvclxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGlmIChsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQpIHtcclxuICAgICAgICAgIDtcclxuICAgICAgICAgIGVyci5tZXNzYWdlICs9IGBcclxuVGhlIGVycm9yIG1heSBiZSBjb3JyZWxhdGVkIHdpdGggdGhpcyBwcmV2aW91cyBlcnJvcjpcclxuJHtsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQuc3RhY2t9XHJcblxyXG5gO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgIH1cclxuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ID0gdm9pZCAwO1xyXG4gICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IHZvaWQgMDtcclxuICAgICAgICBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50ID0gYWN0dWFsQ2hpbGRQcm9wcztcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcclxuICAgICAgICAgICAgV3JhcHBlZENvbXBvbmVudCxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIC4uLmFjdHVhbENoaWxkUHJvcHMsXHJcbiAgICAgICAgICAgICAgcmVmOiByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIClcclxuICAgICAgICApO1xyXG4gICAgICB9LCBbcmVhY3RSZWR1eEZvcndhcmRlZFJlZiwgV3JhcHBlZENvbXBvbmVudCwgYWN0dWFsQ2hpbGRQcm9wc10pO1xyXG4gICAgICBjb25zdCByZW5kZXJlZENoaWxkID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XHJcbiAgICAgICAgaWYgKHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykge1xyXG4gICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRUb1VzZS5Qcm92aWRlciwgeyB2YWx1ZTogb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZSB9LCByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50O1xyXG4gICAgICB9LCBbQ29udGV4dFRvVXNlLCByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQsIG92ZXJyaWRkZW5Db250ZXh0VmFsdWVdKTtcclxuICAgICAgcmV0dXJuIHJlbmRlcmVkQ2hpbGQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBfQ29ubmVjdCA9IFJlYWN0Lm1lbW8oQ29ubmVjdEZ1bmN0aW9uKTtcclxuICAgIGNvbnN0IENvbm5lY3QgPSBfQ29ubmVjdDtcclxuICAgIENvbm5lY3QuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XHJcbiAgICBDb25uZWN0LmRpc3BsYXlOYW1lID0gQ29ubmVjdEZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XHJcbiAgICBpZiAoZm9yd2FyZFJlZikge1xyXG4gICAgICBjb25zdCBfZm9yd2FyZGVkID0gUmVhY3QuZm9yd2FyZFJlZihcclxuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkQ29ubmVjdFJlZihwcm9wcywgcmVmKSB7XHJcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29ubmVjdCwgeyAuLi5wcm9wcywgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjogcmVmIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgKTtcclxuICAgICAgY29uc3QgZm9yd2FyZGVkID0gX2ZvcndhcmRlZDtcclxuICAgICAgZm9yd2FyZGVkLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XHJcbiAgICAgIGZvcndhcmRlZC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcclxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBob2lzdE5vblJlYWN0U3RhdGljcyhmb3J3YXJkZWQsIFdyYXBwZWRDb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBob2lzdE5vblJlYWN0U3RhdGljcyhDb25uZWN0LCBXcmFwcGVkQ29tcG9uZW50KTtcclxuICB9O1xyXG4gIHJldHVybiB3cmFwV2l0aENvbm5lY3Q7XHJcbn1cclxudmFyIGNvbm5lY3RfZGVmYXVsdCA9IGNvbm5lY3Q7XHJcblxyXG4vLyBzcmMvY29tcG9uZW50cy9Qcm92aWRlci50c3hcclxuZnVuY3Rpb24gUHJvdmlkZXIocHJvdmlkZXJQcm9wcykge1xyXG4gIGNvbnN0IHsgY2hpbGRyZW4sIGNvbnRleHQsIHNlcnZlclN0YXRlLCBzdG9yZSB9ID0gcHJvdmlkZXJQcm9wcztcclxuICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcclxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGNyZWF0ZVN1YnNjcmlwdGlvbihzdG9yZSk7XHJcbiAgICBjb25zdCBiYXNlQ29udGV4dFZhbHVlID0ge1xyXG4gICAgICBzdG9yZSxcclxuICAgICAgc3Vic2NyaXB0aW9uLFxyXG4gICAgICBnZXRTZXJ2ZXJTdGF0ZTogc2VydmVyU3RhdGUgPyAoKSA9PiBzZXJ2ZXJTdGF0ZSA6IHZvaWQgMFxyXG4gICAgfTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgcmV0dXJuIGJhc2VDb250ZXh0VmFsdWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCB7IGlkZW50aXR5RnVuY3Rpb25DaGVjayA9IFwib25jZVwiLCBzdGFiaWxpdHlDaGVjayA9IFwib25jZVwiIH0gPSBwcm92aWRlclByb3BzO1xyXG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIE9iamVjdC5hc3NpZ24oYmFzZUNvbnRleHRWYWx1ZSwge1xyXG4gICAgICAgIHN0YWJpbGl0eUNoZWNrLFxyXG4gICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVja1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCBbc3RvcmUsIHNlcnZlclN0YXRlXSk7XHJcbiAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKSwgW3N0b3JlXSk7XHJcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCB7IHN1YnNjcmlwdGlvbiB9ID0gY29udGV4dFZhbHVlO1xyXG4gICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBzdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3VicztcclxuICAgIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcclxuICAgIGlmIChwcmV2aW91c1N0YXRlICE9PSBzdG9yZS5nZXRTdGF0ZSgpKSB7XHJcbiAgICAgIHN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBzdWJzY3JpcHRpb24udHJ5VW5zdWJzY3JpYmUoKTtcclxuICAgICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSB2b2lkIDA7XHJcbiAgICB9O1xyXG4gIH0sIFtjb250ZXh0VmFsdWUsIHByZXZpb3VzU3RhdGVdKTtcclxuICBjb25zdCBDb250ZXh0ID0gY29udGV4dCB8fCBSZWFjdFJlZHV4Q29udGV4dDtcclxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dFZhbHVlIH0sIGNoaWxkcmVuKTtcclxufVxyXG52YXIgUHJvdmlkZXJfZGVmYXVsdCA9IFByb3ZpZGVyO1xyXG5cclxuLy8gc3JjL2hvb2tzL3VzZVJlZHV4Q29udGV4dC50c1xyXG5mdW5jdGlvbiBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xyXG4gIHJldHVybiBmdW5jdGlvbiB1c2VSZWR1eENvbnRleHQyKCkge1xyXG4gICAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlQ29udGV4dChjb250ZXh0KTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWNvbnRleHRWYWx1ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgXCJjb3VsZCBub3QgZmluZCByZWFjdC1yZWR1eCBjb250ZXh0IHZhbHVlOyBwbGVhc2UgZW5zdXJlIHRoZSBjb21wb25lbnQgaXMgd3JhcHBlZCBpbiBhIDxQcm92aWRlcj5cIlxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnRleHRWYWx1ZTtcclxuICB9O1xyXG59XHJcbnZhciB1c2VSZWR1eENvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlUmVkdXhDb250ZXh0SG9vaygpO1xyXG5cclxuLy8gc3JjL2hvb2tzL3VzZVN0b3JlLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlSG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcclxuICBjb25zdCB1c2VSZWR1eENvbnRleHQyID0gY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VSZWR1eENvbnRleHQgOiAoXHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQpXHJcbiAgKTtcclxuICBjb25zdCB1c2VTdG9yZTIgPSAoKSA9PiB7XHJcbiAgICBjb25zdCB7IHN0b3JlIH0gPSB1c2VSZWR1eENvbnRleHQyKCk7XHJcbiAgICByZXR1cm4gc3RvcmU7XHJcbiAgfTtcclxuICBPYmplY3QuYXNzaWduKHVzZVN0b3JlMiwge1xyXG4gICAgd2l0aFR5cGVzOiAoKSA9PiB1c2VTdG9yZTJcclxuICB9KTtcclxuICByZXR1cm4gdXNlU3RvcmUyO1xyXG59XHJcbnZhciB1c2VTdG9yZSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTdG9yZUhvb2soKTtcclxuXHJcbi8vIHNyYy9ob29rcy91c2VEaXNwYXRjaC50c1xyXG5mdW5jdGlvbiBjcmVhdGVEaXNwYXRjaEhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XHJcbiAgY29uc3QgdXNlU3RvcmUyID0gY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VTdG9yZSA6IGNyZWF0ZVN0b3JlSG9vayhjb250ZXh0KTtcclxuICBjb25zdCB1c2VEaXNwYXRjaDIgPSAoKSA9PiB7XHJcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlMigpO1xyXG4gICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoO1xyXG4gIH07XHJcbiAgT2JqZWN0LmFzc2lnbih1c2VEaXNwYXRjaDIsIHtcclxuICAgIHdpdGhUeXBlczogKCkgPT4gdXNlRGlzcGF0Y2gyXHJcbiAgfSk7XHJcbiAgcmV0dXJuIHVzZURpc3BhdGNoMjtcclxufVxyXG52YXIgdXNlRGlzcGF0Y2ggPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRGlzcGF0Y2hIb29rKCk7XHJcblxyXG4vLyBzcmMvaG9va3MvdXNlU2VsZWN0b3IudHNcclxuaW1wb3J0IHsgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgfSBmcm9tIFwidXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvd2l0aC1zZWxlY3Rvci5qc1wiO1xyXG52YXIgcmVmRXF1YWxpdHkgPSAoYSwgYikgPT4gYSA9PT0gYjtcclxuZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xyXG4gIGNvbnN0IHVzZVJlZHV4Q29udGV4dDIgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZVJlZHV4Q29udGV4dCA6IGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dCk7XHJcbiAgY29uc3QgdXNlU2VsZWN0b3IyID0gKHNlbGVjdG9yLCBlcXVhbGl0eUZuT3JPcHRpb25zID0ge30pID0+IHtcclxuICAgIGNvbnN0IHsgZXF1YWxpdHlGbiA9IHJlZkVxdWFsaXR5IH0gPSB0eXBlb2YgZXF1YWxpdHlGbk9yT3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8geyBlcXVhbGl0eUZuOiBlcXVhbGl0eUZuT3JPcHRpb25zIH0gOiBlcXVhbGl0eUZuT3JPcHRpb25zO1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICBpZiAoIXNlbGVjdG9yKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgc2VsZWN0b3IgdG8gdXNlU2VsZWN0b3JgKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhIHNlbGVjdG9yIHRvIHVzZVNlbGVjdG9yYCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiBlcXVhbGl0eUZuICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICBgWW91IG11c3QgcGFzcyBhIGZ1bmN0aW9uIGFzIGFuIGVxdWFsaXR5IGZ1bmN0aW9uIHRvIHVzZVNlbGVjdG9yYFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHJlZHV4Q29udGV4dCA9IHVzZVJlZHV4Q29udGV4dDIoKTtcclxuICAgIGNvbnN0IHsgc3RvcmUsIHN1YnNjcmlwdGlvbiwgZ2V0U2VydmVyU3RhdGUgfSA9IHJlZHV4Q29udGV4dDtcclxuICAgIGNvbnN0IGZpcnN0UnVuID0gUmVhY3QudXNlUmVmKHRydWUpO1xyXG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gUmVhY3QudXNlQ2FsbGJhY2soXHJcbiAgICAgIHtcclxuICAgICAgICBbc2VsZWN0b3IubmFtZV0oc3RhdGUpIHtcclxuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkID0gc2VsZWN0b3Ioc3RhdGUpO1xyXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgICAgICBjb25zdCB7IGRldk1vZGVDaGVja3MgPSB7fSB9ID0gdHlwZW9mIGVxdWFsaXR5Rm5Pck9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IHt9IDogZXF1YWxpdHlGbk9yT3B0aW9ucztcclxuICAgICAgICAgICAgY29uc3QgeyBpZGVudGl0eUZ1bmN0aW9uQ2hlY2ssIHN0YWJpbGl0eUNoZWNrIH0gPSByZWR1eENvbnRleHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2s6IGZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrLFxyXG4gICAgICAgICAgICAgIHN0YWJpbGl0eUNoZWNrOiBmaW5hbFN0YWJpbGl0eUNoZWNrXHJcbiAgICAgICAgICAgIH0gPSB7XHJcbiAgICAgICAgICAgICAgc3RhYmlsaXR5Q2hlY2ssXHJcbiAgICAgICAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrLFxyXG4gICAgICAgICAgICAgIC4uLmRldk1vZGVDaGVja3NcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGZpbmFsU3RhYmlsaXR5Q2hlY2sgPT09IFwiYWx3YXlzXCIgfHwgZmluYWxTdGFiaWxpdHlDaGVjayA9PT0gXCJvbmNlXCIgJiYgZmlyc3RSdW4uY3VycmVudCkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHRvQ29tcGFyZSA9IHNlbGVjdG9yKHN0YXRlKTtcclxuICAgICAgICAgICAgICBpZiAoIWVxdWFsaXR5Rm4oc2VsZWN0ZWQsIHRvQ29tcGFyZSkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICAgICh7IHN0YWNrIH0gPSBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgICAgICAgICAgXCJTZWxlY3RvciBcIiArIChzZWxlY3Rvci5uYW1lIHx8IFwidW5rbm93blwiKSArIFwiIHJldHVybmVkIGEgZGlmZmVyZW50IHJlc3VsdCB3aGVuIGNhbGxlZCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcmVyZW5kZXJzLlxcblNlbGVjdG9ycyB0aGF0IHJldHVybiBhIG5ldyByZWZlcmVuY2UgKHN1Y2ggYXMgYW4gb2JqZWN0IG9yIGFuIGFycmF5KSBzaG91bGQgYmUgbWVtb2l6ZWQ6IGh0dHBzOi8vcmVkdXguanMub3JnL3VzYWdlL2Rlcml2aW5nLWRhdGEtc2VsZWN0b3JzI29wdGltaXppbmctc2VsZWN0b3JzLXdpdGgtbWVtb2l6YXRpb25cIixcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkMjogdG9Db21wYXJlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmaW5hbElkZW50aXR5RnVuY3Rpb25DaGVjayA9PT0gXCJhbHdheXNcIiB8fCBmaW5hbElkZW50aXR5RnVuY3Rpb25DaGVjayA9PT0gXCJvbmNlXCIgJiYgZmlyc3RSdW4uY3VycmVudCkge1xyXG4gICAgICAgICAgICAgIGlmIChzZWxlY3RlZCA9PT0gc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICAgICh7IHN0YWNrIH0gPSBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgICAgICAgICAgXCJTZWxlY3RvciBcIiArIChzZWxlY3Rvci5uYW1lIHx8IFwidW5rbm93blwiKSArIFwiIHJldHVybmVkIHRoZSByb290IHN0YXRlIHdoZW4gY2FsbGVkLiBUaGlzIGNhbiBsZWFkIHRvIHVubmVjZXNzYXJ5IHJlcmVuZGVycy5cXG5TZWxlY3RvcnMgdGhhdCByZXR1cm4gdGhlIGVudGlyZSBzdGF0ZSBhcmUgYWxtb3N0IGNlcnRhaW5seSBhIG1pc3Rha2UsIGFzIHRoZXkgd2lsbCBjYXVzZSBhIHJlcmVuZGVyIHdoZW5ldmVyICphbnl0aGluZyogaW4gc3RhdGUgY2hhbmdlcy5cIixcclxuICAgICAgICAgICAgICAgICAgeyBzdGFjayB9XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmlyc3RSdW4uY3VycmVudCkgZmlyc3RSdW4uY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfVtzZWxlY3Rvci5uYW1lXSxcclxuICAgICAgW3NlbGVjdG9yXVxyXG4gICAgKTtcclxuICAgIGNvbnN0IHNlbGVjdGVkU3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcclxuICAgICAgc3Vic2NyaXB0aW9uLmFkZE5lc3RlZFN1YixcclxuICAgICAgc3RvcmUuZ2V0U3RhdGUsXHJcbiAgICAgIGdldFNlcnZlclN0YXRlIHx8IHN0b3JlLmdldFN0YXRlLFxyXG4gICAgICB3cmFwcGVkU2VsZWN0b3IsXHJcbiAgICAgIGVxdWFsaXR5Rm5cclxuICAgICk7XHJcbiAgICBSZWFjdC51c2VEZWJ1Z1ZhbHVlKHNlbGVjdGVkU3RhdGUpO1xyXG4gICAgcmV0dXJuIHNlbGVjdGVkU3RhdGU7XHJcbiAgfTtcclxuICBPYmplY3QuYXNzaWduKHVzZVNlbGVjdG9yMiwge1xyXG4gICAgd2l0aFR5cGVzOiAoKSA9PiB1c2VTZWxlY3RvcjJcclxuICB9KTtcclxuICByZXR1cm4gdXNlU2VsZWN0b3IyO1xyXG59XHJcbnZhciB1c2VTZWxlY3RvciA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTZWxlY3Rvckhvb2soKTtcclxuXHJcbi8vIHNyYy9leHBvcnRzLnRzXHJcbnZhciBiYXRjaCA9IGRlZmF1bHROb29wQmF0Y2g7XHJcbmV4cG9ydCB7XHJcbiAgUHJvdmlkZXJfZGVmYXVsdCBhcyBQcm92aWRlcixcclxuICBSZWFjdFJlZHV4Q29udGV4dCxcclxuICBiYXRjaCxcclxuICBjb25uZWN0X2RlZmF1bHQgYXMgY29ubmVjdCxcclxuICBjcmVhdGVEaXNwYXRjaEhvb2ssXHJcbiAgY3JlYXRlU2VsZWN0b3JIb29rLFxyXG4gIGNyZWF0ZVN0b3JlSG9vayxcclxuICBzaGFsbG93RXF1YWwsXHJcbiAgdXNlRGlzcGF0Y2gsXHJcbiAgdXNlU2VsZWN0b3IsXHJcbiAgdXNlU3RvcmVcclxufTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtcmVkdXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-redux/dist/react-redux.mjs\n");

/***/ })

};
;