"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@reduxjs";
exports.ids = ["vendor-chunks/@reduxjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReducerType: () => (/* binding */ ReducerType),\n/* harmony export */   SHOULD_AUTOBATCH: () => (/* binding */ SHOULD_AUTOBATCH),\n/* harmony export */   TaskAbortError: () => (/* binding */ TaskAbortError),\n/* harmony export */   Tuple: () => (/* binding */ Tuple),\n/* harmony export */   __DO_NOT_USE__ActionTypes: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes),\n/* harmony export */   addListener: () => (/* binding */ addListener),\n/* harmony export */   applyMiddleware: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware),\n/* harmony export */   asyncThunkCreator: () => (/* binding */ asyncThunkCreator),\n/* harmony export */   autoBatchEnhancer: () => (/* binding */ autoBatchEnhancer),\n/* harmony export */   bindActionCreators: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators),\n/* harmony export */   buildCreateSlice: () => (/* binding */ buildCreateSlice),\n/* harmony export */   clearAllListeners: () => (/* binding */ clearAllListeners),\n/* harmony export */   combineReducers: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers),\n/* harmony export */   combineSlices: () => (/* binding */ combineSlices),\n/* harmony export */   compose: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose),\n/* harmony export */   configureStore: () => (/* binding */ configureStore),\n/* harmony export */   createAction: () => (/* binding */ createAction),\n/* harmony export */   createActionCreatorInvariantMiddleware: () => (/* binding */ createActionCreatorInvariantMiddleware),\n/* harmony export */   createAsyncThunk: () => (/* binding */ createAsyncThunk),\n/* harmony export */   createDraftSafeSelector: () => (/* binding */ createDraftSafeSelector),\n/* harmony export */   createDraftSafeSelectorCreator: () => (/* binding */ createDraftSafeSelectorCreator),\n/* harmony export */   createDynamicMiddleware: () => (/* binding */ createDynamicMiddleware),\n/* harmony export */   createEntityAdapter: () => (/* binding */ createEntityAdapter),\n/* harmony export */   createImmutableStateInvariantMiddleware: () => (/* binding */ createImmutableStateInvariantMiddleware),\n/* harmony export */   createListenerMiddleware: () => (/* binding */ createListenerMiddleware),\n/* harmony export */   createNextState: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.produce),\n/* harmony export */   createReducer: () => (/* binding */ createReducer),\n/* harmony export */   createSelector: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector),\n/* harmony export */   createSelectorCreator: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator),\n/* harmony export */   createSerializableStateInvariantMiddleware: () => (/* binding */ createSerializableStateInvariantMiddleware),\n/* harmony export */   createSlice: () => (/* binding */ createSlice),\n/* harmony export */   createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore),\n/* harmony export */   current: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current),\n/* harmony export */   findNonSerializableValue: () => (/* binding */ findNonSerializableValue),\n/* harmony export */   formatProdErrorMessage: () => (/* binding */ formatProdErrorMessage),\n/* harmony export */   freeze: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze),\n/* harmony export */   isAction: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isAction),\n/* harmony export */   isActionCreator: () => (/* binding */ isActionCreator),\n/* harmony export */   isAllOf: () => (/* binding */ isAllOf),\n/* harmony export */   isAnyOf: () => (/* binding */ isAnyOf),\n/* harmony export */   isAsyncThunkAction: () => (/* binding */ isAsyncThunkAction),\n/* harmony export */   isDraft: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft),\n/* harmony export */   isFluxStandardAction: () => (/* binding */ isFSA),\n/* harmony export */   isFulfilled: () => (/* binding */ isFulfilled),\n/* harmony export */   isImmutableDefault: () => (/* binding */ isImmutableDefault),\n/* harmony export */   isPending: () => (/* binding */ isPending),\n/* harmony export */   isPlain: () => (/* binding */ isPlain),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject),\n/* harmony export */   isRejected: () => (/* binding */ isRejected),\n/* harmony export */   isRejectedWithValue: () => (/* binding */ isRejectedWithValue),\n/* harmony export */   legacy_createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore),\n/* harmony export */   lruMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.lruMemoize),\n/* harmony export */   miniSerializeError: () => (/* binding */ miniSerializeError),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   original: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original),\n/* harmony export */   prepareAutoBatched: () => (/* binding */ prepareAutoBatched),\n/* harmony export */   removeListener: () => (/* binding */ removeListener),\n/* harmony export */   unwrapResult: () => (/* binding */ unwrapResult),\n/* harmony export */   weakMapMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize)\n/* harmony export */ });\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ \"(ssr)/./node_modules/redux-thunk/dist/redux-thunk.mjs\");\n// src/index.ts\r\n\r\n\r\n\r\n\r\n// src/createDraftSafeSelector.ts\r\n\r\n\r\nvar createDraftSafeSelectorCreator = (...args) => {\r\n  const createSelector2 = (0,reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator)(...args);\r\n  const createDraftSafeSelector2 = Object.assign((...args2) => {\r\n    const selector = createSelector2(...args2);\r\n    const wrappedSelector = (value, ...rest) => selector((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value, ...rest);\r\n    Object.assign(wrappedSelector, selector);\r\n    return wrappedSelector;\r\n  }, {\r\n    withTypes: () => createDraftSafeSelector2\r\n  });\r\n  return createDraftSafeSelector2;\r\n};\r\nvar createDraftSafeSelector = /* @__PURE__ */ createDraftSafeSelectorCreator(reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize);\r\n\r\n// src/configureStore.ts\r\n\r\n\r\n// src/devtoolsExtension.ts\r\n\r\nvar composeWithDevTools = typeof window !== \"undefined\" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {\r\n  if (arguments.length === 0) return void 0;\r\n  if (typeof arguments[0] === \"object\") return redux__WEBPACK_IMPORTED_MODULE_0__.compose;\r\n  return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);\r\n};\r\nvar devToolsEnhancer = typeof window !== \"undefined\" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {\r\n  return function(noop3) {\r\n    return noop3;\r\n  };\r\n};\r\n\r\n// src/getDefaultMiddleware.ts\r\n\r\n\r\n// src/createAction.ts\r\n\r\n\r\n// src/tsHelpers.ts\r\nvar hasMatchFunction = (v) => {\r\n  return v && typeof v.match === \"function\";\r\n};\r\n\r\n// src/createAction.ts\r\nfunction createAction(type, prepareAction) {\r\n  function actionCreator(...args) {\r\n    if (prepareAction) {\r\n      let prepared = prepareAction(...args);\r\n      if (!prepared) {\r\n        throw new Error( false ? 0 : \"prepareAction did not return an object\");\r\n      }\r\n      return {\r\n        type,\r\n        payload: prepared.payload,\r\n        ...\"meta\" in prepared && {\r\n          meta: prepared.meta\r\n        },\r\n        ...\"error\" in prepared && {\r\n          error: prepared.error\r\n        }\r\n      };\r\n    }\r\n    return {\r\n      type,\r\n      payload: args[0]\r\n    };\r\n  }\r\n  actionCreator.toString = () => `${type}`;\r\n  actionCreator.type = type;\r\n  actionCreator.match = (action) => (0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && action.type === type;\r\n  return actionCreator;\r\n}\r\nfunction isActionCreator(action) {\r\n  return typeof action === \"function\" && \"type\" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it\r\n  hasMatchFunction(action);\r\n}\r\nfunction isFSA(action) {\r\n  return (0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && Object.keys(action).every(isValidKey);\r\n}\r\nfunction isValidKey(key) {\r\n  return [\"type\", \"payload\", \"error\", \"meta\"].indexOf(key) > -1;\r\n}\r\n\r\n// src/actionCreatorInvariantMiddleware.ts\r\nfunction getMessage(type) {\r\n  const splitType = type ? `${type}`.split(\"/\") : [];\r\n  const actionName = splitType[splitType.length - 1] || \"actionCreator\";\r\n  return `Detected an action creator with type \"${type || \"unknown\"}\" being dispatched. \r\nMake sure you're calling the action creator before dispatching, i.e. \\`dispatch(${actionName}())\\` instead of \\`dispatch(${actionName})\\`. This is necessary even if the action has no payload.`;\r\n}\r\nfunction createActionCreatorInvariantMiddleware(options = {}) {\r\n  if (false) {}\r\n  const {\r\n    isActionCreator: isActionCreator2 = isActionCreator\r\n  } = options;\r\n  return () => (next) => (action) => {\r\n    if (isActionCreator2(action)) {\r\n      console.warn(getMessage(action.type));\r\n    }\r\n    return next(action);\r\n  };\r\n}\r\n\r\n// src/utils.ts\r\n\r\nfunction getTimeMeasureUtils(maxDelay, fnName) {\r\n  let elapsed = 0;\r\n  return {\r\n    measureTime(fn) {\r\n      const started = Date.now();\r\n      try {\r\n        return fn();\r\n      } finally {\r\n        const finished = Date.now();\r\n        elapsed += finished - started;\r\n      }\r\n    },\r\n    warnIfExceeded() {\r\n      if (elapsed > maxDelay) {\r\n        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \r\nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\r\nIt is disabled in production builds, so you don't need to worry about that.`);\r\n      }\r\n    }\r\n  };\r\n}\r\nvar Tuple = class _Tuple extends Array {\r\n  constructor(...items) {\r\n    super(...items);\r\n    Object.setPrototypeOf(this, _Tuple.prototype);\r\n  }\r\n  static get [Symbol.species]() {\r\n    return _Tuple;\r\n  }\r\n  concat(...arr) {\r\n    return super.concat.apply(this, arr);\r\n  }\r\n  prepend(...arr) {\r\n    if (arr.length === 1 && Array.isArray(arr[0])) {\r\n      return new _Tuple(...arr[0].concat(this));\r\n    }\r\n    return new _Tuple(...arr.concat(this));\r\n  }\r\n};\r\nfunction freezeDraftable(val) {\r\n  return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(val) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(val, () => {\r\n  }) : val;\r\n}\r\nfunction getOrInsertComputed(map, key, compute) {\r\n  if (map.has(key)) return map.get(key);\r\n  return map.set(key, compute(key)).get(key);\r\n}\r\n\r\n// src/immutableStateInvariantMiddleware.ts\r\nfunction isImmutableDefault(value) {\r\n  return typeof value !== \"object\" || value == null || Object.isFrozen(value);\r\n}\r\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\r\n  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\r\n  return {\r\n    detectMutations() {\r\n      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\r\n    }\r\n  };\r\n}\r\nfunction trackProperties(isImmutable, ignorePaths = [], obj, path = \"\", checkedObjects = /* @__PURE__ */ new Set()) {\r\n  const tracked = {\r\n    value: obj\r\n  };\r\n  if (!isImmutable(obj) && !checkedObjects.has(obj)) {\r\n    checkedObjects.add(obj);\r\n    tracked.children = {};\r\n    for (const key in obj) {\r\n      const childPath = path ? path + \".\" + key : key;\r\n      if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\r\n        continue;\r\n      }\r\n      tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\r\n    }\r\n  }\r\n  return tracked;\r\n}\r\nfunction detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = \"\") {\r\n  const prevObj = trackedProperty ? trackedProperty.value : void 0;\r\n  const sameRef = prevObj === obj;\r\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\r\n    return {\r\n      wasMutated: true,\r\n      path\r\n    };\r\n  }\r\n  if (isImmutable(prevObj) || isImmutable(obj)) {\r\n    return {\r\n      wasMutated: false\r\n    };\r\n  }\r\n  const keysToDetect = {};\r\n  for (let key in trackedProperty.children) {\r\n    keysToDetect[key] = true;\r\n  }\r\n  for (let key in obj) {\r\n    keysToDetect[key] = true;\r\n  }\r\n  const hasIgnoredPaths = ignoredPaths.length > 0;\r\n  for (let key in keysToDetect) {\r\n    const nestedPath = path ? path + \".\" + key : key;\r\n    if (hasIgnoredPaths) {\r\n      const hasMatches = ignoredPaths.some((ignored) => {\r\n        if (ignored instanceof RegExp) {\r\n          return ignored.test(nestedPath);\r\n        }\r\n        return nestedPath === ignored;\r\n      });\r\n      if (hasMatches) {\r\n        continue;\r\n      }\r\n    }\r\n    const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\r\n    if (result.wasMutated) {\r\n      return result;\r\n    }\r\n  }\r\n  return {\r\n    wasMutated: false\r\n  };\r\n}\r\nfunction createImmutableStateInvariantMiddleware(options = {}) {\r\n  if (false) {} else {\r\n    let stringify2 = function(obj, serializer, indent, decycler) {\r\n      return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);\r\n    }, getSerialize2 = function(serializer, decycler) {\r\n      let stack = [], keys = [];\r\n      if (!decycler) decycler = function(_, value) {\r\n        if (stack[0] === value) return \"[Circular ~]\";\r\n        return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\r\n      };\r\n      return function(key, value) {\r\n        if (stack.length > 0) {\r\n          var thisPos = stack.indexOf(this);\r\n          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\r\n          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\r\n          if (~stack.indexOf(value)) value = decycler.call(this, key, value);\r\n        } else stack.push(value);\r\n        return serializer == null ? value : serializer.call(this, key, value);\r\n      };\r\n    };\r\n    var stringify = stringify2, getSerialize = getSerialize2;\r\n    let {\r\n      isImmutable = isImmutableDefault,\r\n      ignoredPaths,\r\n      warnAfter = 32\r\n    } = options;\r\n    const track = trackForMutations.bind(null, isImmutable, ignoredPaths);\r\n    return ({\r\n      getState\r\n    }) => {\r\n      let state = getState();\r\n      let tracker = track(state);\r\n      let result;\r\n      return (next) => (action) => {\r\n        const measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\r\n        measureUtils.measureTime(() => {\r\n          state = getState();\r\n          result = tracker.detectMutations();\r\n          tracker = track(state);\r\n          if (result.wasMutated) {\r\n            throw new Error( false ? 0 : `A state mutation was detected between dispatches, in the path '${result.path || \"\"}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\r\n          }\r\n        });\r\n        const dispatchedAction = next(action);\r\n        measureUtils.measureTime(() => {\r\n          state = getState();\r\n          result = tracker.detectMutations();\r\n          tracker = track(state);\r\n          if (result.wasMutated) {\r\n            throw new Error( false ? 0 : `A state mutation was detected inside a dispatch, in the path: ${result.path || \"\"}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\r\n          }\r\n        });\r\n        measureUtils.warnIfExceeded();\r\n        return dispatchedAction;\r\n      };\r\n    };\r\n  }\r\n}\r\n\r\n// src/serializableStateInvariantMiddleware.ts\r\n\r\nfunction isPlain(val) {\r\n  const type = typeof val;\r\n  return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || (0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(val);\r\n}\r\nfunction findNonSerializableValue(value, path = \"\", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {\r\n  let foundNestedSerializable;\r\n  if (!isSerializable(value)) {\r\n    return {\r\n      keyPath: path || \"<root>\",\r\n      value\r\n    };\r\n  }\r\n  if (typeof value !== \"object\" || value === null) {\r\n    return false;\r\n  }\r\n  if (cache?.has(value)) return false;\r\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value);\r\n  const hasIgnoredPaths = ignoredPaths.length > 0;\r\n  for (const [key, nestedValue] of entries) {\r\n    const nestedPath = path ? path + \".\" + key : key;\r\n    if (hasIgnoredPaths) {\r\n      const hasMatches = ignoredPaths.some((ignored) => {\r\n        if (ignored instanceof RegExp) {\r\n          return ignored.test(nestedPath);\r\n        }\r\n        return nestedPath === ignored;\r\n      });\r\n      if (hasMatches) {\r\n        continue;\r\n      }\r\n    }\r\n    if (!isSerializable(nestedValue)) {\r\n      return {\r\n        keyPath: nestedPath,\r\n        value: nestedValue\r\n      };\r\n    }\r\n    if (typeof nestedValue === \"object\") {\r\n      foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\r\n      if (foundNestedSerializable) {\r\n        return foundNestedSerializable;\r\n      }\r\n    }\r\n  }\r\n  if (cache && isNestedFrozen(value)) cache.add(value);\r\n  return false;\r\n}\r\nfunction isNestedFrozen(value) {\r\n  if (!Object.isFrozen(value)) return false;\r\n  for (const nestedValue of Object.values(value)) {\r\n    if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\r\n    if (!isNestedFrozen(nestedValue)) return false;\r\n  }\r\n  return true;\r\n}\r\nfunction createSerializableStateInvariantMiddleware(options = {}) {\r\n  if (false) {} else {\r\n    const {\r\n      isSerializable = isPlain,\r\n      getEntries,\r\n      ignoredActions = [],\r\n      ignoredActionPaths = [\"meta.arg\", \"meta.baseQueryMeta\"],\r\n      ignoredPaths = [],\r\n      warnAfter = 32,\r\n      ignoreState = false,\r\n      ignoreActions = false,\r\n      disableCache = false\r\n    } = options;\r\n    const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;\r\n    return (storeAPI) => (next) => (action) => {\r\n      if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\r\n        return next(action);\r\n      }\r\n      const result = next(action);\r\n      const measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\r\n      if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\r\n        measureUtils.measureTime(() => {\r\n          const foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\r\n          if (foundActionNonSerializableValue) {\r\n            const {\r\n              keyPath,\r\n              value\r\n            } = foundActionNonSerializableValue;\r\n            console.error(`A non-serializable value was detected in an action, in the path: \\`${keyPath}\\`. Value:`, value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\r\n          }\r\n        });\r\n      }\r\n      if (!ignoreState) {\r\n        measureUtils.measureTime(() => {\r\n          const state = storeAPI.getState();\r\n          const foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\r\n          if (foundStateNonSerializableValue) {\r\n            const {\r\n              keyPath,\r\n              value\r\n            } = foundStateNonSerializableValue;\r\n            console.error(`A non-serializable value was detected in the state, in the path: \\`${keyPath}\\`. Value:`, value, `\r\nTake a look at the reducer(s) handling this action type: ${action.type}.\r\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);\r\n          }\r\n        });\r\n        measureUtils.warnIfExceeded();\r\n      }\r\n      return result;\r\n    };\r\n  }\r\n}\r\n\r\n// src/getDefaultMiddleware.ts\r\nfunction isBoolean(x) {\r\n  return typeof x === \"boolean\";\r\n}\r\nvar buildGetDefaultMiddleware = () => function getDefaultMiddleware(options) {\r\n  const {\r\n    thunk = true,\r\n    immutableCheck = true,\r\n    serializableCheck = true,\r\n    actionCreatorCheck = true\r\n  } = options ?? {};\r\n  let middlewareArray = new Tuple();\r\n  if (thunk) {\r\n    if (isBoolean(thunk)) {\r\n      middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__.thunk);\r\n    } else {\r\n      middlewareArray.push((0,redux_thunk__WEBPACK_IMPORTED_MODULE_3__.withExtraArgument)(thunk.extraArgument));\r\n    }\r\n  }\r\n  if (true) {\r\n    if (immutableCheck) {\r\n      let immutableOptions = {};\r\n      if (!isBoolean(immutableCheck)) {\r\n        immutableOptions = immutableCheck;\r\n      }\r\n      middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\r\n    }\r\n    if (serializableCheck) {\r\n      let serializableOptions = {};\r\n      if (!isBoolean(serializableCheck)) {\r\n        serializableOptions = serializableCheck;\r\n      }\r\n      middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\r\n    }\r\n    if (actionCreatorCheck) {\r\n      let actionCreatorOptions = {};\r\n      if (!isBoolean(actionCreatorCheck)) {\r\n        actionCreatorOptions = actionCreatorCheck;\r\n      }\r\n      middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\r\n    }\r\n  }\r\n  return middlewareArray;\r\n};\r\n\r\n// src/autoBatchEnhancer.ts\r\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\r\nvar prepareAutoBatched = () => (payload) => ({\r\n  payload,\r\n  meta: {\r\n    [SHOULD_AUTOBATCH]: true\r\n  }\r\n});\r\nvar createQueueWithTimer = (timeout) => {\r\n  return (notify) => {\r\n    setTimeout(notify, timeout);\r\n  };\r\n};\r\nvar autoBatchEnhancer = (options = {\r\n  type: \"raf\"\r\n}) => (next) => (...args) => {\r\n  const store = next(...args);\r\n  let notifying = true;\r\n  let shouldNotifyAtEndOfTick = false;\r\n  let notificationQueued = false;\r\n  const listeners = /* @__PURE__ */ new Set();\r\n  const queueCallback = options.type === \"tick\" ? queueMicrotask : options.type === \"raf\" ? (\r\n    // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.\r\n    typeof window !== \"undefined\" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10)\r\n  ) : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\r\n  const notifyListeners = () => {\r\n    notificationQueued = false;\r\n    if (shouldNotifyAtEndOfTick) {\r\n      shouldNotifyAtEndOfTick = false;\r\n      listeners.forEach((l) => l());\r\n    }\r\n  };\r\n  return Object.assign({}, store, {\r\n    // Override the base `store.subscribe` method to keep original listeners\r\n    // from running if we're delaying notifications\r\n    subscribe(listener2) {\r\n      const wrappedListener = () => notifying && listener2();\r\n      const unsubscribe = store.subscribe(wrappedListener);\r\n      listeners.add(listener2);\r\n      return () => {\r\n        unsubscribe();\r\n        listeners.delete(listener2);\r\n      };\r\n    },\r\n    // Override the base `store.dispatch` method so that we can check actions\r\n    // for the `shouldAutoBatch` flag and determine if batching is active\r\n    dispatch(action) {\r\n      try {\r\n        notifying = !action?.meta?.[SHOULD_AUTOBATCH];\r\n        shouldNotifyAtEndOfTick = !notifying;\r\n        if (shouldNotifyAtEndOfTick) {\r\n          if (!notificationQueued) {\r\n            notificationQueued = true;\r\n            queueCallback(notifyListeners);\r\n          }\r\n        }\r\n        return store.dispatch(action);\r\n      } finally {\r\n        notifying = true;\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\n// src/getDefaultEnhancers.ts\r\nvar buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options) {\r\n  const {\r\n    autoBatch = true\r\n  } = options ?? {};\r\n  let enhancerArray = new Tuple(middlewareEnhancer);\r\n  if (autoBatch) {\r\n    enhancerArray.push(autoBatchEnhancer(typeof autoBatch === \"object\" ? autoBatch : void 0));\r\n  }\r\n  return enhancerArray;\r\n};\r\n\r\n// src/configureStore.ts\r\nfunction configureStore(options) {\r\n  const getDefaultMiddleware = buildGetDefaultMiddleware();\r\n  const {\r\n    reducer = void 0,\r\n    middleware,\r\n    devTools = true,\r\n    duplicateMiddlewareCheck = true,\r\n    preloadedState = void 0,\r\n    enhancers = void 0\r\n  } = options || {};\r\n  let rootReducer;\r\n  if (typeof reducer === \"function\") {\r\n    rootReducer = reducer;\r\n  } else if ((0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(reducer)) {\r\n    rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);\r\n  } else {\r\n    throw new Error( false ? 0 : \"`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers\");\r\n  }\r\n  if ( true && middleware && typeof middleware !== \"function\") {\r\n    throw new Error( false ? 0 : \"`middleware` field must be a callback\");\r\n  }\r\n  let finalMiddleware;\r\n  if (typeof middleware === \"function\") {\r\n    finalMiddleware = middleware(getDefaultMiddleware);\r\n    if ( true && !Array.isArray(finalMiddleware)) {\r\n      throw new Error( false ? 0 : \"when using a middleware builder function, an array of middleware must be returned\");\r\n    }\r\n  } else {\r\n    finalMiddleware = getDefaultMiddleware();\r\n  }\r\n  if ( true && finalMiddleware.some((item) => typeof item !== \"function\")) {\r\n    throw new Error( false ? 0 : \"each middleware provided to configureStore must be a function\");\r\n  }\r\n  if ( true && duplicateMiddlewareCheck) {\r\n    let middlewareReferences = /* @__PURE__ */ new Set();\r\n    finalMiddleware.forEach((middleware2) => {\r\n      if (middlewareReferences.has(middleware2)) {\r\n        throw new Error( false ? 0 : \"Duplicate middleware references found when creating the store. Ensure that each middleware is only included once.\");\r\n      }\r\n      middlewareReferences.add(middleware2);\r\n    });\r\n  }\r\n  let finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;\r\n  if (devTools) {\r\n    finalCompose = composeWithDevTools({\r\n      // Enable capture of stack traces for dispatched Redux actions\r\n      trace: \"development\" !== \"production\",\r\n      ...typeof devTools === \"object\" && devTools\r\n    });\r\n  }\r\n  const middlewareEnhancer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware)(...finalMiddleware);\r\n  const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);\r\n  if ( true && enhancers && typeof enhancers !== \"function\") {\r\n    throw new Error( false ? 0 : \"`enhancers` field must be a callback\");\r\n  }\r\n  let storeEnhancers = typeof enhancers === \"function\" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();\r\n  if ( true && !Array.isArray(storeEnhancers)) {\r\n    throw new Error( false ? 0 : \"`enhancers` callback must return an array\");\r\n  }\r\n  if ( true && storeEnhancers.some((item) => typeof item !== \"function\")) {\r\n    throw new Error( false ? 0 : \"each enhancer provided to configureStore must be a function\");\r\n  }\r\n  if ( true && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {\r\n    console.error(\"middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`\");\r\n  }\r\n  const composedEnhancer = finalCompose(...storeEnhancers);\r\n  return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);\r\n}\r\n\r\n// src/createReducer.ts\r\n\r\n\r\n// src/mapBuilders.ts\r\nfunction executeReducerBuilderCallback(builderCallback) {\r\n  const actionsMap = {};\r\n  const actionMatchers = [];\r\n  let defaultCaseReducer;\r\n  const builder = {\r\n    addCase(typeOrActionCreator, reducer) {\r\n      if (true) {\r\n        if (actionMatchers.length > 0) {\r\n          throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addMatcher`\");\r\n        }\r\n        if (defaultCaseReducer) {\r\n          throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\r\n        }\r\n      }\r\n      const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\r\n      if (!type) {\r\n        throw new Error( false ? 0 : \"`builder.addCase` cannot be called with an empty action type\");\r\n      }\r\n      if (type in actionsMap) {\r\n        throw new Error( false ? 0 : `\\`builder.addCase\\` cannot be called with two reducers for the same action type '${type}'`);\r\n      }\r\n      actionsMap[type] = reducer;\r\n      return builder;\r\n    },\r\n    addMatcher(matcher, reducer) {\r\n      if (true) {\r\n        if (defaultCaseReducer) {\r\n          throw new Error( false ? 0 : \"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\r\n        }\r\n      }\r\n      actionMatchers.push({\r\n        matcher,\r\n        reducer\r\n      });\r\n      return builder;\r\n    },\r\n    addDefaultCase(reducer) {\r\n      if (true) {\r\n        if (defaultCaseReducer) {\r\n          throw new Error( false ? 0 : \"`builder.addDefaultCase` can only be called once\");\r\n        }\r\n      }\r\n      defaultCaseReducer = reducer;\r\n      return builder;\r\n    }\r\n  };\r\n  builderCallback(builder);\r\n  return [actionsMap, actionMatchers, defaultCaseReducer];\r\n}\r\n\r\n// src/createReducer.ts\r\nfunction isStateFunction(x) {\r\n  return typeof x === \"function\";\r\n}\r\nfunction createReducer(initialState, mapOrBuilderCallback) {\r\n  if (true) {\r\n    if (typeof mapOrBuilderCallback === \"object\") {\r\n      throw new Error( false ? 0 : \"The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\r\n    }\r\n  }\r\n  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);\r\n  let getInitialState;\r\n  if (isStateFunction(initialState)) {\r\n    getInitialState = () => freezeDraftable(initialState());\r\n  } else {\r\n    const frozenInitialState = freezeDraftable(initialState);\r\n    getInitialState = () => frozenInitialState;\r\n  }\r\n  function reducer(state = getInitialState(), action) {\r\n    let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({\r\n      matcher\r\n    }) => matcher(action)).map(({\r\n      reducer: reducer2\r\n    }) => reducer2)];\r\n    if (caseReducers.filter((cr) => !!cr).length === 0) {\r\n      caseReducers = [finalDefaultCaseReducer];\r\n    }\r\n    return caseReducers.reduce((previousState, caseReducer) => {\r\n      if (caseReducer) {\r\n        if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {\r\n          const draft = previousState;\r\n          const result = caseReducer(draft, action);\r\n          if (result === void 0) {\r\n            return previousState;\r\n          }\r\n          return result;\r\n        } else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {\r\n          const result = caseReducer(previousState, action);\r\n          if (result === void 0) {\r\n            if (previousState === null) {\r\n              return previousState;\r\n            }\r\n            throw Error(\"A case reducer on a non-draftable value must not return undefined\");\r\n          }\r\n          return result;\r\n        } else {\r\n          return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(previousState, (draft) => {\r\n            return caseReducer(draft, action);\r\n          });\r\n        }\r\n      }\r\n      return previousState;\r\n    }, state);\r\n  }\r\n  reducer.getInitialState = getInitialState;\r\n  return reducer;\r\n}\r\n\r\n// src/matchers.ts\r\nvar matches = (matcher, action) => {\r\n  if (hasMatchFunction(matcher)) {\r\n    return matcher.match(action);\r\n  } else {\r\n    return matcher(action);\r\n  }\r\n};\r\nfunction isAnyOf(...matchers) {\r\n  return (action) => {\r\n    return matchers.some((matcher) => matches(matcher, action));\r\n  };\r\n}\r\nfunction isAllOf(...matchers) {\r\n  return (action) => {\r\n    return matchers.every((matcher) => matches(matcher, action));\r\n  };\r\n}\r\nfunction hasExpectedRequestMetadata(action, validStatus) {\r\n  if (!action || !action.meta) return false;\r\n  const hasValidRequestId = typeof action.meta.requestId === \"string\";\r\n  const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\r\n  return hasValidRequestId && hasValidRequestStatus;\r\n}\r\nfunction isAsyncThunkArray(a) {\r\n  return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\r\n}\r\nfunction isPending(...asyncThunks) {\r\n  if (asyncThunks.length === 0) {\r\n    return (action) => hasExpectedRequestMetadata(action, [\"pending\"]);\r\n  }\r\n  if (!isAsyncThunkArray(asyncThunks)) {\r\n    return isPending()(asyncThunks[0]);\r\n  }\r\n  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.pending));\r\n}\r\nfunction isRejected(...asyncThunks) {\r\n  if (asyncThunks.length === 0) {\r\n    return (action) => hasExpectedRequestMetadata(action, [\"rejected\"]);\r\n  }\r\n  if (!isAsyncThunkArray(asyncThunks)) {\r\n    return isRejected()(asyncThunks[0]);\r\n  }\r\n  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.rejected));\r\n}\r\nfunction isRejectedWithValue(...asyncThunks) {\r\n  const hasFlag = (action) => {\r\n    return action && action.meta && action.meta.rejectedWithValue;\r\n  };\r\n  if (asyncThunks.length === 0) {\r\n    return isAllOf(isRejected(...asyncThunks), hasFlag);\r\n  }\r\n  if (!isAsyncThunkArray(asyncThunks)) {\r\n    return isRejectedWithValue()(asyncThunks[0]);\r\n  }\r\n  return isAllOf(isRejected(...asyncThunks), hasFlag);\r\n}\r\nfunction isFulfilled(...asyncThunks) {\r\n  if (asyncThunks.length === 0) {\r\n    return (action) => hasExpectedRequestMetadata(action, [\"fulfilled\"]);\r\n  }\r\n  if (!isAsyncThunkArray(asyncThunks)) {\r\n    return isFulfilled()(asyncThunks[0]);\r\n  }\r\n  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.fulfilled));\r\n}\r\nfunction isAsyncThunkAction(...asyncThunks) {\r\n  if (asyncThunks.length === 0) {\r\n    return (action) => hasExpectedRequestMetadata(action, [\"pending\", \"fulfilled\", \"rejected\"]);\r\n  }\r\n  if (!isAsyncThunkArray(asyncThunks)) {\r\n    return isAsyncThunkAction()(asyncThunks[0]);\r\n  }\r\n  return isAnyOf(...asyncThunks.flatMap((asyncThunk) => [asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled]));\r\n}\r\n\r\n// src/nanoid.ts\r\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\r\nvar nanoid = (size = 21) => {\r\n  let id = \"\";\r\n  let i = size;\r\n  while (i--) {\r\n    id += urlAlphabet[Math.random() * 64 | 0];\r\n  }\r\n  return id;\r\n};\r\n\r\n// src/createAsyncThunk.ts\r\nvar commonProperties = [\"name\", \"message\", \"stack\", \"code\"];\r\nvar RejectWithValue = class {\r\n  constructor(payload, meta) {\r\n    this.payload = payload;\r\n    this.meta = meta;\r\n  }\r\n  /*\r\n  type-only property to distinguish between RejectWithValue and FulfillWithMeta\r\n  does not exist at runtime\r\n  */\r\n  _type;\r\n};\r\nvar FulfillWithMeta = class {\r\n  constructor(payload, meta) {\r\n    this.payload = payload;\r\n    this.meta = meta;\r\n  }\r\n  /*\r\n  type-only property to distinguish between RejectWithValue and FulfillWithMeta\r\n  does not exist at runtime\r\n  */\r\n  _type;\r\n};\r\nvar miniSerializeError = (value) => {\r\n  if (typeof value === \"object\" && value !== null) {\r\n    const simpleError = {};\r\n    for (const property of commonProperties) {\r\n      if (typeof value[property] === \"string\") {\r\n        simpleError[property] = value[property];\r\n      }\r\n    }\r\n    return simpleError;\r\n  }\r\n  return {\r\n    message: String(value)\r\n  };\r\n};\r\nvar externalAbortMessage = \"External signal was aborted\";\r\nvar createAsyncThunk = /* @__PURE__ */ (() => {\r\n  function createAsyncThunk2(typePrefix, payloadCreator, options) {\r\n    const fulfilled = createAction(typePrefix + \"/fulfilled\", (payload, requestId, arg, meta) => ({\r\n      payload,\r\n      meta: {\r\n        ...meta || {},\r\n        arg,\r\n        requestId,\r\n        requestStatus: \"fulfilled\"\r\n      }\r\n    }));\r\n    const pending = createAction(typePrefix + \"/pending\", (requestId, arg, meta) => ({\r\n      payload: void 0,\r\n      meta: {\r\n        ...meta || {},\r\n        arg,\r\n        requestId,\r\n        requestStatus: \"pending\"\r\n      }\r\n    }));\r\n    const rejected = createAction(typePrefix + \"/rejected\", (error, requestId, arg, payload, meta) => ({\r\n      payload,\r\n      error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\r\n      meta: {\r\n        ...meta || {},\r\n        arg,\r\n        requestId,\r\n        rejectedWithValue: !!payload,\r\n        requestStatus: \"rejected\",\r\n        aborted: error?.name === \"AbortError\",\r\n        condition: error?.name === \"ConditionError\"\r\n      }\r\n    }));\r\n    function actionCreator(arg, {\r\n      signal\r\n    } = {}) {\r\n      return (dispatch, getState, extra) => {\r\n        const requestId = options?.idGenerator ? options.idGenerator(arg) : nanoid();\r\n        const abortController = new AbortController();\r\n        let abortHandler;\r\n        let abortReason;\r\n        function abort(reason) {\r\n          abortReason = reason;\r\n          abortController.abort();\r\n        }\r\n        if (signal) {\r\n          if (signal.aborted) {\r\n            abort(externalAbortMessage);\r\n          } else {\r\n            signal.addEventListener(\"abort\", () => abort(externalAbortMessage), {\r\n              once: true\r\n            });\r\n          }\r\n        }\r\n        const promise = async function() {\r\n          let finalAction;\r\n          try {\r\n            let conditionResult = options?.condition?.(arg, {\r\n              getState,\r\n              extra\r\n            });\r\n            if (isThenable(conditionResult)) {\r\n              conditionResult = await conditionResult;\r\n            }\r\n            if (conditionResult === false || abortController.signal.aborted) {\r\n              throw {\r\n                name: \"ConditionError\",\r\n                message: \"Aborted due to condition callback returning false.\"\r\n              };\r\n            }\r\n            const abortedPromise = new Promise((_, reject) => {\r\n              abortHandler = () => {\r\n                reject({\r\n                  name: \"AbortError\",\r\n                  message: abortReason || \"Aborted\"\r\n                });\r\n              };\r\n              abortController.signal.addEventListener(\"abort\", abortHandler);\r\n            });\r\n            dispatch(pending(requestId, arg, options?.getPendingMeta?.({\r\n              requestId,\r\n              arg\r\n            }, {\r\n              getState,\r\n              extra\r\n            })));\r\n            finalAction = await Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {\r\n              dispatch,\r\n              getState,\r\n              extra,\r\n              requestId,\r\n              signal: abortController.signal,\r\n              abort,\r\n              rejectWithValue: (value, meta) => {\r\n                return new RejectWithValue(value, meta);\r\n              },\r\n              fulfillWithValue: (value, meta) => {\r\n                return new FulfillWithMeta(value, meta);\r\n              }\r\n            })).then((result) => {\r\n              if (result instanceof RejectWithValue) {\r\n                throw result;\r\n              }\r\n              if (result instanceof FulfillWithMeta) {\r\n                return fulfilled(result.payload, requestId, arg, result.meta);\r\n              }\r\n              return fulfilled(result, requestId, arg);\r\n            })]);\r\n          } catch (err) {\r\n            finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);\r\n          } finally {\r\n            if (abortHandler) {\r\n              abortController.signal.removeEventListener(\"abort\", abortHandler);\r\n            }\r\n          }\r\n          const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\r\n          if (!skipDispatch) {\r\n            dispatch(finalAction);\r\n          }\r\n          return finalAction;\r\n        }();\r\n        return Object.assign(promise, {\r\n          abort,\r\n          requestId,\r\n          arg,\r\n          unwrap() {\r\n            return promise.then(unwrapResult);\r\n          }\r\n        });\r\n      };\r\n    }\r\n    return Object.assign(actionCreator, {\r\n      pending,\r\n      rejected,\r\n      fulfilled,\r\n      settled: isAnyOf(rejected, fulfilled),\r\n      typePrefix\r\n    });\r\n  }\r\n  createAsyncThunk2.withTypes = () => createAsyncThunk2;\r\n  return createAsyncThunk2;\r\n})();\r\nfunction unwrapResult(action) {\r\n  if (action.meta && action.meta.rejectedWithValue) {\r\n    throw action.payload;\r\n  }\r\n  if (action.error) {\r\n    throw action.error;\r\n  }\r\n  return action.payload;\r\n}\r\nfunction isThenable(value) {\r\n  return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\r\n}\r\n\r\n// src/createSlice.ts\r\nvar asyncThunkSymbol = /* @__PURE__ */ Symbol.for(\"rtk-slice-createasyncthunk\");\r\nvar asyncThunkCreator = {\r\n  [asyncThunkSymbol]: createAsyncThunk\r\n};\r\nvar ReducerType = /* @__PURE__ */ ((ReducerType2) => {\r\n  ReducerType2[\"reducer\"] = \"reducer\";\r\n  ReducerType2[\"reducerWithPrepare\"] = \"reducerWithPrepare\";\r\n  ReducerType2[\"asyncThunk\"] = \"asyncThunk\";\r\n  return ReducerType2;\r\n})(ReducerType || {});\r\nfunction getType(slice, actionKey) {\r\n  return `${slice}/${actionKey}`;\r\n}\r\nfunction buildCreateSlice({\r\n  creators\r\n} = {}) {\r\n  const cAT = creators?.asyncThunk?.[asyncThunkSymbol];\r\n  return function createSlice2(options) {\r\n    const {\r\n      name,\r\n      reducerPath = name\r\n    } = options;\r\n    if (!name) {\r\n      throw new Error( false ? 0 : \"`name` is a required option for createSlice\");\r\n    }\r\n    if (typeof process !== \"undefined\" && \"development\" === \"development\") {\r\n      if (options.initialState === void 0) {\r\n        console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\r\n      }\r\n    }\r\n    const reducers = (typeof options.reducers === \"function\" ? options.reducers(buildReducerCreators()) : options.reducers) || {};\r\n    const reducerNames = Object.keys(reducers);\r\n    const context = {\r\n      sliceCaseReducersByName: {},\r\n      sliceCaseReducersByType: {},\r\n      actionCreators: {},\r\n      sliceMatchers: []\r\n    };\r\n    const contextMethods = {\r\n      addCase(typeOrActionCreator, reducer2) {\r\n        const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\r\n        if (!type) {\r\n          throw new Error( false ? 0 : \"`context.addCase` cannot be called with an empty action type\");\r\n        }\r\n        if (type in context.sliceCaseReducersByType) {\r\n          throw new Error( false ? 0 : \"`context.addCase` cannot be called with two reducers for the same action type: \" + type);\r\n        }\r\n        context.sliceCaseReducersByType[type] = reducer2;\r\n        return contextMethods;\r\n      },\r\n      addMatcher(matcher, reducer2) {\r\n        context.sliceMatchers.push({\r\n          matcher,\r\n          reducer: reducer2\r\n        });\r\n        return contextMethods;\r\n      },\r\n      exposeAction(name2, actionCreator) {\r\n        context.actionCreators[name2] = actionCreator;\r\n        return contextMethods;\r\n      },\r\n      exposeCaseReducer(name2, reducer2) {\r\n        context.sliceCaseReducersByName[name2] = reducer2;\r\n        return contextMethods;\r\n      }\r\n    };\r\n    reducerNames.forEach((reducerName) => {\r\n      const reducerDefinition = reducers[reducerName];\r\n      const reducerDetails = {\r\n        reducerName,\r\n        type: getType(name, reducerName),\r\n        createNotation: typeof options.reducers === \"function\"\r\n      };\r\n      if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {\r\n        handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);\r\n      } else {\r\n        handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);\r\n      }\r\n    });\r\n    function buildReducer() {\r\n      if (true) {\r\n        if (typeof options.extraReducers === \"object\") {\r\n          throw new Error( false ? 0 : \"The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\r\n        }\r\n      }\r\n      const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers];\r\n      const finalCaseReducers = {\r\n        ...extraReducers,\r\n        ...context.sliceCaseReducersByType\r\n      };\r\n      return createReducer(options.initialState, (builder) => {\r\n        for (let key in finalCaseReducers) {\r\n          builder.addCase(key, finalCaseReducers[key]);\r\n        }\r\n        for (let sM of context.sliceMatchers) {\r\n          builder.addMatcher(sM.matcher, sM.reducer);\r\n        }\r\n        for (let m of actionMatchers) {\r\n          builder.addMatcher(m.matcher, m.reducer);\r\n        }\r\n        if (defaultCaseReducer) {\r\n          builder.addDefaultCase(defaultCaseReducer);\r\n        }\r\n      });\r\n    }\r\n    const selectSelf = (state) => state;\r\n    const injectedSelectorCache = /* @__PURE__ */ new Map();\r\n    const injectedStateCache = /* @__PURE__ */ new WeakMap();\r\n    let _reducer;\r\n    function reducer(state, action) {\r\n      if (!_reducer) _reducer = buildReducer();\r\n      return _reducer(state, action);\r\n    }\r\n    function getInitialState() {\r\n      if (!_reducer) _reducer = buildReducer();\r\n      return _reducer.getInitialState();\r\n    }\r\n    function makeSelectorProps(reducerPath2, injected = false) {\r\n      function selectSlice(state) {\r\n        let sliceState = state[reducerPath2];\r\n        if (typeof sliceState === \"undefined\") {\r\n          if (injected) {\r\n            sliceState = getOrInsertComputed(injectedStateCache, selectSlice, getInitialState);\r\n          } else if (true) {\r\n            throw new Error( false ? 0 : \"selectSlice returned undefined for an uninjected slice reducer\");\r\n          }\r\n        }\r\n        return sliceState;\r\n      }\r\n      function getSelectors(selectState = selectSelf) {\r\n        const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, () => /* @__PURE__ */ new WeakMap());\r\n        return getOrInsertComputed(selectorCache, selectState, () => {\r\n          const map = {};\r\n          for (const [name2, selector] of Object.entries(options.selectors ?? {})) {\r\n            map[name2] = wrapSelector(selector, selectState, () => getOrInsertComputed(injectedStateCache, selectState, getInitialState), injected);\r\n          }\r\n          return map;\r\n        });\r\n      }\r\n      return {\r\n        reducerPath: reducerPath2,\r\n        getSelectors,\r\n        get selectors() {\r\n          return getSelectors(selectSlice);\r\n        },\r\n        selectSlice\r\n      };\r\n    }\r\n    const slice = {\r\n      name,\r\n      reducer,\r\n      actions: context.actionCreators,\r\n      caseReducers: context.sliceCaseReducersByName,\r\n      getInitialState,\r\n      ...makeSelectorProps(reducerPath),\r\n      injectInto(injectable, {\r\n        reducerPath: pathOpt,\r\n        ...config\r\n      } = {}) {\r\n        const newReducerPath = pathOpt ?? reducerPath;\r\n        injectable.inject({\r\n          reducerPath: newReducerPath,\r\n          reducer\r\n        }, config);\r\n        return {\r\n          ...slice,\r\n          ...makeSelectorProps(newReducerPath, true)\r\n        };\r\n      }\r\n    };\r\n    return slice;\r\n  };\r\n}\r\nfunction wrapSelector(selector, selectState, getInitialState, injected) {\r\n  function wrapper(rootState, ...args) {\r\n    let sliceState = selectState(rootState);\r\n    if (typeof sliceState === \"undefined\") {\r\n      if (injected) {\r\n        sliceState = getInitialState();\r\n      } else if (true) {\r\n        throw new Error( false ? 0 : \"selectState returned undefined for an uninjected slice reducer\");\r\n      }\r\n    }\r\n    return selector(sliceState, ...args);\r\n  }\r\n  wrapper.unwrapped = selector;\r\n  return wrapper;\r\n}\r\nvar createSlice = /* @__PURE__ */ buildCreateSlice();\r\nfunction buildReducerCreators() {\r\n  function asyncThunk(payloadCreator, config) {\r\n    return {\r\n      _reducerDefinitionType: \"asyncThunk\" /* asyncThunk */,\r\n      payloadCreator,\r\n      ...config\r\n    };\r\n  }\r\n  asyncThunk.withTypes = () => asyncThunk;\r\n  return {\r\n    reducer(caseReducer) {\r\n      return Object.assign({\r\n        // hack so the wrapping function has the same name as the original\r\n        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original\r\n        [caseReducer.name](...args) {\r\n          return caseReducer(...args);\r\n        }\r\n      }[caseReducer.name], {\r\n        _reducerDefinitionType: \"reducer\" /* reducer */\r\n      });\r\n    },\r\n    preparedReducer(prepare, reducer) {\r\n      return {\r\n        _reducerDefinitionType: \"reducerWithPrepare\" /* reducerWithPrepare */,\r\n        prepare,\r\n        reducer\r\n      };\r\n    },\r\n    asyncThunk\r\n  };\r\n}\r\nfunction handleNormalReducerDefinition({\r\n  type,\r\n  reducerName,\r\n  createNotation\r\n}, maybeReducerWithPrepare, context) {\r\n  let caseReducer;\r\n  let prepareCallback;\r\n  if (\"reducer\" in maybeReducerWithPrepare) {\r\n    if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {\r\n      throw new Error( false ? 0 : \"Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.\");\r\n    }\r\n    caseReducer = maybeReducerWithPrepare.reducer;\r\n    prepareCallback = maybeReducerWithPrepare.prepare;\r\n  } else {\r\n    caseReducer = maybeReducerWithPrepare;\r\n  }\r\n  context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));\r\n}\r\nfunction isAsyncThunkSliceReducerDefinition(reducerDefinition) {\r\n  return reducerDefinition._reducerDefinitionType === \"asyncThunk\" /* asyncThunk */;\r\n}\r\nfunction isCaseReducerWithPrepareDefinition(reducerDefinition) {\r\n  return reducerDefinition._reducerDefinitionType === \"reducerWithPrepare\" /* reducerWithPrepare */;\r\n}\r\nfunction handleThunkCaseReducerDefinition({\r\n  type,\r\n  reducerName\r\n}, reducerDefinition, context, cAT) {\r\n  if (!cAT) {\r\n    throw new Error( false ? 0 : \"Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.\");\r\n  }\r\n  const {\r\n    payloadCreator,\r\n    fulfilled,\r\n    pending,\r\n    rejected,\r\n    settled,\r\n    options\r\n  } = reducerDefinition;\r\n  const thunk = cAT(type, payloadCreator, options);\r\n  context.exposeAction(reducerName, thunk);\r\n  if (fulfilled) {\r\n    context.addCase(thunk.fulfilled, fulfilled);\r\n  }\r\n  if (pending) {\r\n    context.addCase(thunk.pending, pending);\r\n  }\r\n  if (rejected) {\r\n    context.addCase(thunk.rejected, rejected);\r\n  }\r\n  if (settled) {\r\n    context.addMatcher(thunk.settled, settled);\r\n  }\r\n  context.exposeCaseReducer(reducerName, {\r\n    fulfilled: fulfilled || noop,\r\n    pending: pending || noop,\r\n    rejected: rejected || noop,\r\n    settled: settled || noop\r\n  });\r\n}\r\nfunction noop() {\r\n}\r\n\r\n// src/entities/entity_state.ts\r\nfunction getInitialEntityState() {\r\n  return {\r\n    ids: [],\r\n    entities: {}\r\n  };\r\n}\r\nfunction createInitialStateFactory(stateAdapter) {\r\n  function getInitialState(additionalState = {}, entities) {\r\n    const state = Object.assign(getInitialEntityState(), additionalState);\r\n    return entities ? stateAdapter.setAll(state, entities) : state;\r\n  }\r\n  return {\r\n    getInitialState\r\n  };\r\n}\r\n\r\n// src/entities/state_selectors.ts\r\nfunction createSelectorsFactory() {\r\n  function getSelectors(selectState, options = {}) {\r\n    const {\r\n      createSelector: createSelector2 = createDraftSafeSelector\r\n    } = options;\r\n    const selectIds = (state) => state.ids;\r\n    const selectEntities = (state) => state.entities;\r\n    const selectAll = createSelector2(selectIds, selectEntities, (ids, entities) => ids.map((id) => entities[id]));\r\n    const selectId = (_, id) => id;\r\n    const selectById = (entities, id) => entities[id];\r\n    const selectTotal = createSelector2(selectIds, (ids) => ids.length);\r\n    if (!selectState) {\r\n      return {\r\n        selectIds,\r\n        selectEntities,\r\n        selectAll,\r\n        selectTotal,\r\n        selectById: createSelector2(selectEntities, selectId, selectById)\r\n      };\r\n    }\r\n    const selectGlobalizedEntities = createSelector2(selectState, selectEntities);\r\n    return {\r\n      selectIds: createSelector2(selectState, selectIds),\r\n      selectEntities: selectGlobalizedEntities,\r\n      selectAll: createSelector2(selectState, selectAll),\r\n      selectTotal: createSelector2(selectState, selectTotal),\r\n      selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)\r\n    };\r\n  }\r\n  return {\r\n    getSelectors\r\n  };\r\n}\r\n\r\n// src/entities/state_adapter.ts\r\n\r\nvar isDraftTyped = immer__WEBPACK_IMPORTED_MODULE_2__.isDraft;\r\nfunction createSingleArgumentStateOperator(mutator) {\r\n  const operator = createStateOperator((_, state) => mutator(state));\r\n  return function operation(state) {\r\n    return operator(state, void 0);\r\n  };\r\n}\r\nfunction createStateOperator(mutator) {\r\n  return function operation(state, arg) {\r\n    function isPayloadActionArgument(arg2) {\r\n      return isFSA(arg2);\r\n    }\r\n    const runMutator = (draft) => {\r\n      if (isPayloadActionArgument(arg)) {\r\n        mutator(arg.payload, draft);\r\n      } else {\r\n        mutator(arg, draft);\r\n      }\r\n    };\r\n    if (isDraftTyped(state)) {\r\n      runMutator(state);\r\n      return state;\r\n    }\r\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(state, runMutator);\r\n  };\r\n}\r\n\r\n// src/entities/utils.ts\r\n\r\nfunction selectIdValue(entity, selectId) {\r\n  const key = selectId(entity);\r\n  if ( true && key === void 0) {\r\n    console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\r\n  }\r\n  return key;\r\n}\r\nfunction ensureEntitiesArray(entities) {\r\n  if (!Array.isArray(entities)) {\r\n    entities = Object.values(entities);\r\n  }\r\n  return entities;\r\n}\r\nfunction getCurrent(value) {\r\n  return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value;\r\n}\r\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\r\n  newEntities = ensureEntitiesArray(newEntities);\r\n  const existingIdsArray = getCurrent(state.ids);\r\n  const existingIds = new Set(existingIdsArray);\r\n  const added = [];\r\n  const addedIds = /* @__PURE__ */ new Set([]);\r\n  const updated = [];\r\n  for (const entity of newEntities) {\r\n    const id = selectIdValue(entity, selectId);\r\n    if (existingIds.has(id) || addedIds.has(id)) {\r\n      updated.push({\r\n        id,\r\n        changes: entity\r\n      });\r\n    } else {\r\n      addedIds.add(id);\r\n      added.push(entity);\r\n    }\r\n  }\r\n  return [added, updated, existingIdsArray];\r\n}\r\n\r\n// src/entities/unsorted_state_adapter.ts\r\nfunction createUnsortedStateAdapter(selectId) {\r\n  function addOneMutably(entity, state) {\r\n    const key = selectIdValue(entity, selectId);\r\n    if (key in state.entities) {\r\n      return;\r\n    }\r\n    state.ids.push(key);\r\n    state.entities[key] = entity;\r\n  }\r\n  function addManyMutably(newEntities, state) {\r\n    newEntities = ensureEntitiesArray(newEntities);\r\n    for (const entity of newEntities) {\r\n      addOneMutably(entity, state);\r\n    }\r\n  }\r\n  function setOneMutably(entity, state) {\r\n    const key = selectIdValue(entity, selectId);\r\n    if (!(key in state.entities)) {\r\n      state.ids.push(key);\r\n    }\r\n    ;\r\n    state.entities[key] = entity;\r\n  }\r\n  function setManyMutably(newEntities, state) {\r\n    newEntities = ensureEntitiesArray(newEntities);\r\n    for (const entity of newEntities) {\r\n      setOneMutably(entity, state);\r\n    }\r\n  }\r\n  function setAllMutably(newEntities, state) {\r\n    newEntities = ensureEntitiesArray(newEntities);\r\n    state.ids = [];\r\n    state.entities = {};\r\n    addManyMutably(newEntities, state);\r\n  }\r\n  function removeOneMutably(key, state) {\r\n    return removeManyMutably([key], state);\r\n  }\r\n  function removeManyMutably(keys, state) {\r\n    let didMutate = false;\r\n    keys.forEach((key) => {\r\n      if (key in state.entities) {\r\n        delete state.entities[key];\r\n        didMutate = true;\r\n      }\r\n    });\r\n    if (didMutate) {\r\n      state.ids = state.ids.filter((id) => id in state.entities);\r\n    }\r\n  }\r\n  function removeAllMutably(state) {\r\n    Object.assign(state, {\r\n      ids: [],\r\n      entities: {}\r\n    });\r\n  }\r\n  function takeNewKey(keys, update, state) {\r\n    const original3 = state.entities[update.id];\r\n    if (original3 === void 0) {\r\n      return false;\r\n    }\r\n    const updated = Object.assign({}, original3, update.changes);\r\n    const newKey = selectIdValue(updated, selectId);\r\n    const hasNewKey = newKey !== update.id;\r\n    if (hasNewKey) {\r\n      keys[update.id] = newKey;\r\n      delete state.entities[update.id];\r\n    }\r\n    ;\r\n    state.entities[newKey] = updated;\r\n    return hasNewKey;\r\n  }\r\n  function updateOneMutably(update, state) {\r\n    return updateManyMutably([update], state);\r\n  }\r\n  function updateManyMutably(updates, state) {\r\n    const newKeys = {};\r\n    const updatesPerEntity = {};\r\n    updates.forEach((update) => {\r\n      if (update.id in state.entities) {\r\n        updatesPerEntity[update.id] = {\r\n          id: update.id,\r\n          // Spreads ignore falsy values, so this works even if there isn't\r\n          // an existing update already at this key\r\n          changes: {\r\n            ...updatesPerEntity[update.id]?.changes,\r\n            ...update.changes\r\n          }\r\n        };\r\n      }\r\n    });\r\n    updates = Object.values(updatesPerEntity);\r\n    const didMutateEntities = updates.length > 0;\r\n    if (didMutateEntities) {\r\n      const didMutateIds = updates.filter((update) => takeNewKey(newKeys, update, state)).length > 0;\r\n      if (didMutateIds) {\r\n        state.ids = Object.values(state.entities).map((e) => selectIdValue(e, selectId));\r\n      }\r\n    }\r\n  }\r\n  function upsertOneMutably(entity, state) {\r\n    return upsertManyMutably([entity], state);\r\n  }\r\n  function upsertManyMutably(newEntities, state) {\r\n    const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\r\n    addManyMutably(added, state);\r\n    updateManyMutably(updated, state);\r\n  }\r\n  return {\r\n    removeAll: createSingleArgumentStateOperator(removeAllMutably),\r\n    addOne: createStateOperator(addOneMutably),\r\n    addMany: createStateOperator(addManyMutably),\r\n    setOne: createStateOperator(setOneMutably),\r\n    setMany: createStateOperator(setManyMutably),\r\n    setAll: createStateOperator(setAllMutably),\r\n    updateOne: createStateOperator(updateOneMutably),\r\n    updateMany: createStateOperator(updateManyMutably),\r\n    upsertOne: createStateOperator(upsertOneMutably),\r\n    upsertMany: createStateOperator(upsertManyMutably),\r\n    removeOne: createStateOperator(removeOneMutably),\r\n    removeMany: createStateOperator(removeManyMutably)\r\n  };\r\n}\r\n\r\n// src/entities/sorted_state_adapter.ts\r\nfunction findInsertIndex(sortedItems, item, comparisonFunction) {\r\n  let lowIndex = 0;\r\n  let highIndex = sortedItems.length;\r\n  while (lowIndex < highIndex) {\r\n    let middleIndex = lowIndex + highIndex >>> 1;\r\n    const currentItem = sortedItems[middleIndex];\r\n    const res = comparisonFunction(item, currentItem);\r\n    if (res >= 0) {\r\n      lowIndex = middleIndex + 1;\r\n    } else {\r\n      highIndex = middleIndex;\r\n    }\r\n  }\r\n  return lowIndex;\r\n}\r\nfunction insert(sortedItems, item, comparisonFunction) {\r\n  const insertAtIndex = findInsertIndex(sortedItems, item, comparisonFunction);\r\n  sortedItems.splice(insertAtIndex, 0, item);\r\n  return sortedItems;\r\n}\r\nfunction createSortedStateAdapter(selectId, comparer) {\r\n  const {\r\n    removeOne,\r\n    removeMany,\r\n    removeAll\r\n  } = createUnsortedStateAdapter(selectId);\r\n  function addOneMutably(entity, state) {\r\n    return addManyMutably([entity], state);\r\n  }\r\n  function addManyMutably(newEntities, state, existingIds) {\r\n    newEntities = ensureEntitiesArray(newEntities);\r\n    const existingKeys = new Set(existingIds ?? getCurrent(state.ids));\r\n    const models = newEntities.filter((model) => !existingKeys.has(selectIdValue(model, selectId)));\r\n    if (models.length !== 0) {\r\n      mergeFunction(state, models);\r\n    }\r\n  }\r\n  function setOneMutably(entity, state) {\r\n    return setManyMutably([entity], state);\r\n  }\r\n  function setManyMutably(newEntities, state) {\r\n    newEntities = ensureEntitiesArray(newEntities);\r\n    if (newEntities.length !== 0) {\r\n      for (const item of newEntities) {\r\n        delete state.entities[selectId(item)];\r\n      }\r\n      mergeFunction(state, newEntities);\r\n    }\r\n  }\r\n  function setAllMutably(newEntities, state) {\r\n    newEntities = ensureEntitiesArray(newEntities);\r\n    state.entities = {};\r\n    state.ids = [];\r\n    addManyMutably(newEntities, state, []);\r\n  }\r\n  function updateOneMutably(update, state) {\r\n    return updateManyMutably([update], state);\r\n  }\r\n  function updateManyMutably(updates, state) {\r\n    let appliedUpdates = false;\r\n    let replacedIds = false;\r\n    for (let update of updates) {\r\n      const entity = state.entities[update.id];\r\n      if (!entity) {\r\n        continue;\r\n      }\r\n      appliedUpdates = true;\r\n      Object.assign(entity, update.changes);\r\n      const newId = selectId(entity);\r\n      if (update.id !== newId) {\r\n        replacedIds = true;\r\n        delete state.entities[update.id];\r\n        const oldIndex = state.ids.indexOf(update.id);\r\n        state.ids[oldIndex] = newId;\r\n        state.entities[newId] = entity;\r\n      }\r\n    }\r\n    if (appliedUpdates) {\r\n      mergeFunction(state, [], appliedUpdates, replacedIds);\r\n    }\r\n  }\r\n  function upsertOneMutably(entity, state) {\r\n    return upsertManyMutably([entity], state);\r\n  }\r\n  function upsertManyMutably(newEntities, state) {\r\n    const [added, updated, existingIdsArray] = splitAddedUpdatedEntities(newEntities, selectId, state);\r\n    if (added.length) {\r\n      addManyMutably(added, state, existingIdsArray);\r\n    }\r\n    if (updated.length) {\r\n      updateManyMutably(updated, state);\r\n    }\r\n  }\r\n  function areArraysEqual(a, b) {\r\n    if (a.length !== b.length) {\r\n      return false;\r\n    }\r\n    for (let i = 0; i < a.length; i++) {\r\n      if (a[i] === b[i]) {\r\n        continue;\r\n      }\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  const mergeFunction = (state, addedItems, appliedUpdates, replacedIds) => {\r\n    const currentEntities = getCurrent(state.entities);\r\n    const currentIds = getCurrent(state.ids);\r\n    const stateEntities = state.entities;\r\n    let ids = currentIds;\r\n    if (replacedIds) {\r\n      ids = new Set(currentIds);\r\n    }\r\n    let sortedEntities = [];\r\n    for (const id of ids) {\r\n      const entity = currentEntities[id];\r\n      if (entity) {\r\n        sortedEntities.push(entity);\r\n      }\r\n    }\r\n    const wasPreviouslyEmpty = sortedEntities.length === 0;\r\n    for (const item of addedItems) {\r\n      stateEntities[selectId(item)] = item;\r\n      if (!wasPreviouslyEmpty) {\r\n        insert(sortedEntities, item, comparer);\r\n      }\r\n    }\r\n    if (wasPreviouslyEmpty) {\r\n      sortedEntities = addedItems.slice().sort(comparer);\r\n    } else if (appliedUpdates) {\r\n      sortedEntities.sort(comparer);\r\n    }\r\n    const newSortedIds = sortedEntities.map(selectId);\r\n    if (!areArraysEqual(currentIds, newSortedIds)) {\r\n      state.ids = newSortedIds;\r\n    }\r\n  };\r\n  return {\r\n    removeOne,\r\n    removeMany,\r\n    removeAll,\r\n    addOne: createStateOperator(addOneMutably),\r\n    updateOne: createStateOperator(updateOneMutably),\r\n    upsertOne: createStateOperator(upsertOneMutably),\r\n    setOne: createStateOperator(setOneMutably),\r\n    setMany: createStateOperator(setManyMutably),\r\n    setAll: createStateOperator(setAllMutably),\r\n    addMany: createStateOperator(addManyMutably),\r\n    updateMany: createStateOperator(updateManyMutably),\r\n    upsertMany: createStateOperator(upsertManyMutably)\r\n  };\r\n}\r\n\r\n// src/entities/create_adapter.ts\r\nfunction createEntityAdapter(options = {}) {\r\n  const {\r\n    selectId,\r\n    sortComparer\r\n  } = {\r\n    sortComparer: false,\r\n    selectId: (instance) => instance.id,\r\n    ...options\r\n  };\r\n  const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\r\n  const stateFactory = createInitialStateFactory(stateAdapter);\r\n  const selectorsFactory = createSelectorsFactory();\r\n  return {\r\n    selectId,\r\n    sortComparer,\r\n    ...stateFactory,\r\n    ...selectorsFactory,\r\n    ...stateAdapter\r\n  };\r\n}\r\n\r\n// src/listenerMiddleware/index.ts\r\n\r\n\r\n// src/listenerMiddleware/exceptions.ts\r\nvar task = \"task\";\r\nvar listener = \"listener\";\r\nvar completed = \"completed\";\r\nvar cancelled = \"cancelled\";\r\nvar taskCancelled = `task-${cancelled}`;\r\nvar taskCompleted = `task-${completed}`;\r\nvar listenerCancelled = `${listener}-${cancelled}`;\r\nvar listenerCompleted = `${listener}-${completed}`;\r\nvar TaskAbortError = class {\r\n  constructor(code) {\r\n    this.code = code;\r\n    this.message = `${task} ${cancelled} (reason: ${code})`;\r\n  }\r\n  name = \"TaskAbortError\";\r\n  message;\r\n};\r\n\r\n// src/listenerMiddleware/utils.ts\r\nvar assertFunction = (func, expected) => {\r\n  if (typeof func !== \"function\") {\r\n    throw new TypeError( false ? 0 : `${expected} is not a function`);\r\n  }\r\n};\r\nvar noop2 = () => {\r\n};\r\nvar catchRejection = (promise, onError = noop2) => {\r\n  promise.catch(onError);\r\n  return promise;\r\n};\r\nvar addAbortSignalListener = (abortSignal, callback) => {\r\n  abortSignal.addEventListener(\"abort\", callback, {\r\n    once: true\r\n  });\r\n  return () => abortSignal.removeEventListener(\"abort\", callback);\r\n};\r\nvar abortControllerWithReason = (abortController, reason) => {\r\n  const signal = abortController.signal;\r\n  if (signal.aborted) {\r\n    return;\r\n  }\r\n  if (!(\"reason\" in signal)) {\r\n    Object.defineProperty(signal, \"reason\", {\r\n      enumerable: true,\r\n      value: reason,\r\n      configurable: true,\r\n      writable: true\r\n    });\r\n  }\r\n  ;\r\n  abortController.abort(reason);\r\n};\r\n\r\n// src/listenerMiddleware/task.ts\r\nvar validateActive = (signal) => {\r\n  if (signal.aborted) {\r\n    const {\r\n      reason\r\n    } = signal;\r\n    throw new TaskAbortError(reason);\r\n  }\r\n};\r\nfunction raceWithSignal(signal, promise) {\r\n  let cleanup = noop2;\r\n  return new Promise((resolve, reject) => {\r\n    const notifyRejection = () => reject(new TaskAbortError(signal.reason));\r\n    if (signal.aborted) {\r\n      notifyRejection();\r\n      return;\r\n    }\r\n    cleanup = addAbortSignalListener(signal, notifyRejection);\r\n    promise.finally(() => cleanup()).then(resolve, reject);\r\n  }).finally(() => {\r\n    cleanup = noop2;\r\n  });\r\n}\r\nvar runTask = async (task2, cleanUp) => {\r\n  try {\r\n    await Promise.resolve();\r\n    const value = await task2();\r\n    return {\r\n      status: \"ok\",\r\n      value\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      status: error instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\r\n      error\r\n    };\r\n  } finally {\r\n    cleanUp?.();\r\n  }\r\n};\r\nvar createPause = (signal) => {\r\n  return (promise) => {\r\n    return catchRejection(raceWithSignal(signal, promise).then((output) => {\r\n      validateActive(signal);\r\n      return output;\r\n    }));\r\n  };\r\n};\r\nvar createDelay = (signal) => {\r\n  const pause = createPause(signal);\r\n  return (timeoutMs) => {\r\n    return pause(new Promise((resolve) => setTimeout(resolve, timeoutMs)));\r\n  };\r\n};\r\n\r\n// src/listenerMiddleware/index.ts\r\nvar {\r\n  assign\r\n} = Object;\r\nvar INTERNAL_NIL_TOKEN = {};\r\nvar alm = \"listenerMiddleware\";\r\nvar createFork = (parentAbortSignal, parentBlockingPromises) => {\r\n  const linkControllers = (controller) => addAbortSignalListener(parentAbortSignal, () => abortControllerWithReason(controller, parentAbortSignal.reason));\r\n  return (taskExecutor, opts) => {\r\n    assertFunction(taskExecutor, \"taskExecutor\");\r\n    const childAbortController = new AbortController();\r\n    linkControllers(childAbortController);\r\n    const result = runTask(async () => {\r\n      validateActive(parentAbortSignal);\r\n      validateActive(childAbortController.signal);\r\n      const result2 = await taskExecutor({\r\n        pause: createPause(childAbortController.signal),\r\n        delay: createDelay(childAbortController.signal),\r\n        signal: childAbortController.signal\r\n      });\r\n      validateActive(childAbortController.signal);\r\n      return result2;\r\n    }, () => abortControllerWithReason(childAbortController, taskCompleted));\r\n    if (opts?.autoJoin) {\r\n      parentBlockingPromises.push(result.catch(noop2));\r\n    }\r\n    return {\r\n      result: createPause(parentAbortSignal)(result),\r\n      cancel() {\r\n        abortControllerWithReason(childAbortController, taskCancelled);\r\n      }\r\n    };\r\n  };\r\n};\r\nvar createTakePattern = (startListening, signal) => {\r\n  const take = async (predicate, timeout) => {\r\n    validateActive(signal);\r\n    let unsubscribe = () => {\r\n    };\r\n    const tuplePromise = new Promise((resolve, reject) => {\r\n      let stopListening = startListening({\r\n        predicate,\r\n        effect: (action, listenerApi) => {\r\n          listenerApi.unsubscribe();\r\n          resolve([action, listenerApi.getState(), listenerApi.getOriginalState()]);\r\n        }\r\n      });\r\n      unsubscribe = () => {\r\n        stopListening();\r\n        reject();\r\n      };\r\n    });\r\n    const promises = [tuplePromise];\r\n    if (timeout != null) {\r\n      promises.push(new Promise((resolve) => setTimeout(resolve, timeout, null)));\r\n    }\r\n    try {\r\n      const output = await raceWithSignal(signal, Promise.race(promises));\r\n      validateActive(signal);\r\n      return output;\r\n    } finally {\r\n      unsubscribe();\r\n    }\r\n  };\r\n  return (predicate, timeout) => catchRejection(take(predicate, timeout));\r\n};\r\nvar getListenerEntryPropsFrom = (options) => {\r\n  let {\r\n    type,\r\n    actionCreator,\r\n    matcher,\r\n    predicate,\r\n    effect\r\n  } = options;\r\n  if (type) {\r\n    predicate = createAction(type).match;\r\n  } else if (actionCreator) {\r\n    type = actionCreator.type;\r\n    predicate = actionCreator.match;\r\n  } else if (matcher) {\r\n    predicate = matcher;\r\n  } else if (predicate) {\r\n  } else {\r\n    throw new Error( false ? 0 : \"Creating or removing a listener requires one of the known fields for matching an action\");\r\n  }\r\n  assertFunction(effect, \"options.listener\");\r\n  return {\r\n    predicate,\r\n    type,\r\n    effect\r\n  };\r\n};\r\nvar createListenerEntry = /* @__PURE__ */ assign((options) => {\r\n  const {\r\n    type,\r\n    predicate,\r\n    effect\r\n  } = getListenerEntryPropsFrom(options);\r\n  const entry = {\r\n    id: nanoid(),\r\n    effect,\r\n    type,\r\n    predicate,\r\n    pending: /* @__PURE__ */ new Set(),\r\n    unsubscribe: () => {\r\n      throw new Error( false ? 0 : \"Unsubscribe not initialized\");\r\n    }\r\n  };\r\n  return entry;\r\n}, {\r\n  withTypes: () => createListenerEntry\r\n});\r\nvar findListenerEntry = (listenerMap, options) => {\r\n  const {\r\n    type,\r\n    effect,\r\n    predicate\r\n  } = getListenerEntryPropsFrom(options);\r\n  return Array.from(listenerMap.values()).find((entry) => {\r\n    const matchPredicateOrType = typeof type === \"string\" ? entry.type === type : entry.predicate === predicate;\r\n    return matchPredicateOrType && entry.effect === effect;\r\n  });\r\n};\r\nvar cancelActiveListeners = (entry) => {\r\n  entry.pending.forEach((controller) => {\r\n    abortControllerWithReason(controller, listenerCancelled);\r\n  });\r\n};\r\nvar createClearListenerMiddleware = (listenerMap) => {\r\n  return () => {\r\n    listenerMap.forEach(cancelActiveListeners);\r\n    listenerMap.clear();\r\n  };\r\n};\r\nvar safelyNotifyError = (errorHandler, errorToNotify, errorInfo) => {\r\n  try {\r\n    errorHandler(errorToNotify, errorInfo);\r\n  } catch (errorHandlerError) {\r\n    setTimeout(() => {\r\n      throw errorHandlerError;\r\n    }, 0);\r\n  }\r\n};\r\nvar addListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/add`), {\r\n  withTypes: () => addListener\r\n});\r\nvar clearAllListeners = /* @__PURE__ */ createAction(`${alm}/removeAll`);\r\nvar removeListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/remove`), {\r\n  withTypes: () => removeListener\r\n});\r\nvar defaultErrorHandler = (...args) => {\r\n  console.error(`${alm}/error`, ...args);\r\n};\r\nvar createListenerMiddleware = (middlewareOptions = {}) => {\r\n  const listenerMap = /* @__PURE__ */ new Map();\r\n  const {\r\n    extra,\r\n    onError = defaultErrorHandler\r\n  } = middlewareOptions;\r\n  assertFunction(onError, \"onError\");\r\n  const insertEntry = (entry) => {\r\n    entry.unsubscribe = () => listenerMap.delete(entry.id);\r\n    listenerMap.set(entry.id, entry);\r\n    return (cancelOptions) => {\r\n      entry.unsubscribe();\r\n      if (cancelOptions?.cancelActive) {\r\n        cancelActiveListeners(entry);\r\n      }\r\n    };\r\n  };\r\n  const startListening = (options) => {\r\n    const entry = findListenerEntry(listenerMap, options) ?? createListenerEntry(options);\r\n    return insertEntry(entry);\r\n  };\r\n  assign(startListening, {\r\n    withTypes: () => startListening\r\n  });\r\n  const stopListening = (options) => {\r\n    const entry = findListenerEntry(listenerMap, options);\r\n    if (entry) {\r\n      entry.unsubscribe();\r\n      if (options.cancelActive) {\r\n        cancelActiveListeners(entry);\r\n      }\r\n    }\r\n    return !!entry;\r\n  };\r\n  assign(stopListening, {\r\n    withTypes: () => stopListening\r\n  });\r\n  const notifyListener = async (entry, action, api, getOriginalState) => {\r\n    const internalTaskController = new AbortController();\r\n    const take = createTakePattern(startListening, internalTaskController.signal);\r\n    const autoJoinPromises = [];\r\n    try {\r\n      entry.pending.add(internalTaskController);\r\n      await Promise.resolve(entry.effect(\r\n        action,\r\n        // Use assign() rather than ... to avoid extra helper functions added to bundle\r\n        assign({}, api, {\r\n          getOriginalState,\r\n          condition: (predicate, timeout) => take(predicate, timeout).then(Boolean),\r\n          take,\r\n          delay: createDelay(internalTaskController.signal),\r\n          pause: createPause(internalTaskController.signal),\r\n          extra,\r\n          signal: internalTaskController.signal,\r\n          fork: createFork(internalTaskController.signal, autoJoinPromises),\r\n          unsubscribe: entry.unsubscribe,\r\n          subscribe: () => {\r\n            listenerMap.set(entry.id, entry);\r\n          },\r\n          cancelActiveListeners: () => {\r\n            entry.pending.forEach((controller, _, set) => {\r\n              if (controller !== internalTaskController) {\r\n                abortControllerWithReason(controller, listenerCancelled);\r\n                set.delete(controller);\r\n              }\r\n            });\r\n          },\r\n          cancel: () => {\r\n            abortControllerWithReason(internalTaskController, listenerCancelled);\r\n            entry.pending.delete(internalTaskController);\r\n          },\r\n          throwIfCancelled: () => {\r\n            validateActive(internalTaskController.signal);\r\n          }\r\n        })\r\n      ));\r\n    } catch (listenerError) {\r\n      if (!(listenerError instanceof TaskAbortError)) {\r\n        safelyNotifyError(onError, listenerError, {\r\n          raisedBy: \"effect\"\r\n        });\r\n      }\r\n    } finally {\r\n      await Promise.all(autoJoinPromises);\r\n      abortControllerWithReason(internalTaskController, listenerCompleted);\r\n      entry.pending.delete(internalTaskController);\r\n    }\r\n  };\r\n  const clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\r\n  const middleware = (api) => (next) => (action) => {\r\n    if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\r\n      return next(action);\r\n    }\r\n    if (addListener.match(action)) {\r\n      return startListening(action.payload);\r\n    }\r\n    if (clearAllListeners.match(action)) {\r\n      clearListenerMiddleware();\r\n      return;\r\n    }\r\n    if (removeListener.match(action)) {\r\n      return stopListening(action.payload);\r\n    }\r\n    let originalState = api.getState();\r\n    const getOriginalState = () => {\r\n      if (originalState === INTERNAL_NIL_TOKEN) {\r\n        throw new Error( false ? 0 : `${alm}: getOriginalState can only be called synchronously`);\r\n      }\r\n      return originalState;\r\n    };\r\n    let result;\r\n    try {\r\n      result = next(action);\r\n      if (listenerMap.size > 0) {\r\n        const currentState = api.getState();\r\n        const listenerEntries = Array.from(listenerMap.values());\r\n        for (const entry of listenerEntries) {\r\n          let runListener = false;\r\n          try {\r\n            runListener = entry.predicate(action, currentState, originalState);\r\n          } catch (predicateError) {\r\n            runListener = false;\r\n            safelyNotifyError(onError, predicateError, {\r\n              raisedBy: \"predicate\"\r\n            });\r\n          }\r\n          if (!runListener) {\r\n            continue;\r\n          }\r\n          notifyListener(entry, action, api, getOriginalState);\r\n        }\r\n      }\r\n    } finally {\r\n      originalState = INTERNAL_NIL_TOKEN;\r\n    }\r\n    return result;\r\n  };\r\n  return {\r\n    middleware,\r\n    startListening,\r\n    stopListening,\r\n    clearListeners: clearListenerMiddleware\r\n  };\r\n};\r\n\r\n// src/dynamicMiddleware/index.ts\r\n\r\nvar createMiddlewareEntry = (middleware) => ({\r\n  middleware,\r\n  applied: /* @__PURE__ */ new Map()\r\n});\r\nvar matchInstance = (instanceId) => (action) => action?.meta?.instanceId === instanceId;\r\nvar createDynamicMiddleware = () => {\r\n  const instanceId = nanoid();\r\n  const middlewareMap = /* @__PURE__ */ new Map();\r\n  const withMiddleware = Object.assign(createAction(\"dynamicMiddleware/add\", (...middlewares) => ({\r\n    payload: middlewares,\r\n    meta: {\r\n      instanceId\r\n    }\r\n  })), {\r\n    withTypes: () => withMiddleware\r\n  });\r\n  const addMiddleware = Object.assign(function addMiddleware2(...middlewares) {\r\n    middlewares.forEach((middleware2) => {\r\n      getOrInsertComputed(middlewareMap, middleware2, createMiddlewareEntry);\r\n    });\r\n  }, {\r\n    withTypes: () => addMiddleware\r\n  });\r\n  const getFinalMiddleware = (api) => {\r\n    const appliedMiddleware = Array.from(middlewareMap.values()).map((entry) => getOrInsertComputed(entry.applied, api, entry.middleware));\r\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.compose)(...appliedMiddleware);\r\n  };\r\n  const isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));\r\n  const middleware = (api) => (next) => (action) => {\r\n    if (isWithMiddleware(action)) {\r\n      addMiddleware(...action.payload);\r\n      return api.dispatch;\r\n    }\r\n    return getFinalMiddleware(api)(next)(action);\r\n  };\r\n  return {\r\n    middleware,\r\n    addMiddleware,\r\n    withMiddleware,\r\n    instanceId\r\n  };\r\n};\r\n\r\n// src/combineSlices.ts\r\n\r\nvar isSliceLike = (maybeSliceLike) => \"reducerPath\" in maybeSliceLike && typeof maybeSliceLike.reducerPath === \"string\";\r\nvar getReducers = (slices) => slices.flatMap((sliceOrMap) => isSliceLike(sliceOrMap) ? [[sliceOrMap.reducerPath, sliceOrMap.reducer]] : Object.entries(sliceOrMap));\r\nvar ORIGINAL_STATE = Symbol.for(\"rtk-state-proxy-original\");\r\nvar isStateProxy = (value) => !!value && !!value[ORIGINAL_STATE];\r\nvar stateProxyMap = /* @__PURE__ */ new WeakMap();\r\nvar createStateProxy = (state, reducerMap, initialStateCache) => getOrInsertComputed(stateProxyMap, state, () => new Proxy(state, {\r\n  get: (target, prop, receiver) => {\r\n    if (prop === ORIGINAL_STATE) return target;\r\n    const result = Reflect.get(target, prop, receiver);\r\n    if (typeof result === \"undefined\") {\r\n      const cached = initialStateCache[prop];\r\n      if (typeof cached !== \"undefined\") return cached;\r\n      const reducer = reducerMap[prop];\r\n      if (reducer) {\r\n        const reducerResult = reducer(void 0, {\r\n          type: nanoid()\r\n        });\r\n        if (typeof reducerResult === \"undefined\") {\r\n          throw new Error( false ? 0 : `The slice reducer for key \"${prop.toString()}\" returned undefined when called for selector(). If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);\r\n        }\r\n        initialStateCache[prop] = reducerResult;\r\n        return reducerResult;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n}));\r\nvar original = (state) => {\r\n  if (!isStateProxy(state)) {\r\n    throw new Error( false ? 0 : \"original must be used on state Proxy\");\r\n  }\r\n  return state[ORIGINAL_STATE];\r\n};\r\nvar emptyObject = {};\r\nvar noopReducer = (state = emptyObject) => state;\r\nfunction combineSlices(...slices) {\r\n  const reducerMap = Object.fromEntries(getReducers(slices));\r\n  const getReducer = () => Object.keys(reducerMap).length ? (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducerMap) : noopReducer;\r\n  let reducer = getReducer();\r\n  function combinedReducer(state, action) {\r\n    return reducer(state, action);\r\n  }\r\n  combinedReducer.withLazyLoadedSlices = () => combinedReducer;\r\n  const initialStateCache = {};\r\n  const inject = (slice, config = {}) => {\r\n    const {\r\n      reducerPath,\r\n      reducer: reducerToInject\r\n    } = slice;\r\n    const currentReducer = reducerMap[reducerPath];\r\n    if (!config.overrideExisting && currentReducer && currentReducer !== reducerToInject) {\r\n      if (typeof process !== \"undefined\" && \"development\" === \"development\") {\r\n        console.error(`called \\`inject\\` to override already-existing reducer ${reducerPath} without specifying \\`overrideExisting: true\\``);\r\n      }\r\n      return combinedReducer;\r\n    }\r\n    if (config.overrideExisting && currentReducer !== reducerToInject) {\r\n      delete initialStateCache[reducerPath];\r\n    }\r\n    reducerMap[reducerPath] = reducerToInject;\r\n    reducer = getReducer();\r\n    return combinedReducer;\r\n  };\r\n  const selector = Object.assign(function makeSelector(selectorFn, selectState) {\r\n    return function selector2(state, ...args) {\r\n      return selectorFn(createStateProxy(selectState ? selectState(state, ...args) : state, reducerMap, initialStateCache), ...args);\r\n    };\r\n  }, {\r\n    original\r\n  });\r\n  return Object.assign(combinedReducer, {\r\n    inject,\r\n    selector\r\n  });\r\n}\r\n\r\n// src/formatProdErrorMessage.ts\r\nfunction formatProdErrorMessage(code) {\r\n  return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\r\n}\r\n\r\n//# sourceMappingURL=redux-toolkit.modern.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3JlZHV4LXRvb2xraXQubW9kZXJuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNzQjtBQUNtRjtBQUNpQztBQUMxSTtBQUNBO0FBQ3lDO0FBQ3dCO0FBQ2pFO0FBQ0EsMEJBQTBCLCtEQUFxQjtBQUMvQztBQUNBO0FBQ0EseURBQXlELDhDQUFPLFVBQVUsOENBQU87QUFDakY7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNkVBQTZFLG9EQUFjO0FBQzNGO0FBQ0E7QUFDNEg7QUFDNUg7QUFDQTtBQUNnQztBQUNoQztBQUNBO0FBQ0EsK0NBQStDLDBDQUFPO0FBQ3RELFNBQVMsMENBQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMwRTtBQUMxRTtBQUNBO0FBQ2lDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixNQUFxQyxHQUFHLENBQXlCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxLQUFLO0FBQ3pDO0FBQ0Esb0NBQW9DLCtDQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywrQ0FBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixLQUFLO0FBQ25DO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRSxrRkFBa0YsV0FBVyw4QkFBOEIsV0FBVztBQUN0STtBQUNBLDREQUE0RDtBQUM1RCxNQUFNLEtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7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QUFDQSxXQUFXLDhDQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNpRTtBQUNqRTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4Q0FBUSxVQUFVLDhDQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEMsNEJBQTRCLFVBQVU7QUFDdEMsMkJBQTJCLFNBQVMsR0FBRyxVQUFVO0FBQ2pELDJCQUEyQixTQUFTLEdBQUcsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTSxFQUFFLFdBQVcsV0FBVyxLQUFLO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBcUMsR0FBRyxDQUEwQixNQUFNLFVBQVU7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQ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Q0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFdBQVcsOENBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMEJBQTBCLE1BQXFDLEdBQUcsQ0FBMEIsaUNBQWlDLGdCQUFnQjtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esb0JBQW9CLE1BQXFDLEdBQUcsQ0FBMEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsc0RBQWdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDRDQUE0QyxhQUFvQjtBQUNoRSxnRkFBZ0YsYUFBYTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPLGlEQUFpRCxNQUFNO0FBQ3hHO0FBb0RFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L2Rpc3QvcmVkdXgtdG9vbGtpdC5tb2Rlcm4ubWpzPzQyOTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXHJcbmV4cG9ydCAqIGZyb20gXCJyZWR1eFwiO1xyXG5pbXBvcnQgeyBwcm9kdWNlLCBjdXJyZW50IGFzIGN1cnJlbnQzLCBmcmVlemUsIG9yaWdpbmFsIGFzIG9yaWdpbmFsMiwgaXNEcmFmdCBhcyBpc0RyYWZ0NSB9IGZyb20gXCJpbW1lclwiO1xyXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvciwgY3JlYXRlU2VsZWN0b3JDcmVhdG9yIGFzIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcjIsIGxydU1lbW9pemUsIHdlYWtNYXBNZW1vaXplIGFzIHdlYWtNYXBNZW1vaXplMiB9IGZyb20gXCJyZXNlbGVjdFwiO1xyXG5cclxuLy8gc3JjL2NyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yLnRzXHJcbmltcG9ydCB7IGN1cnJlbnQsIGlzRHJhZnQgfSBmcm9tIFwiaW1tZXJcIjtcclxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JDcmVhdG9yLCB3ZWFrTWFwTWVtb2l6ZSB9IGZyb20gXCJyZXNlbGVjdFwiO1xyXG52YXIgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JDcmVhdG9yID0gKC4uLmFyZ3MpID0+IHtcclxuICBjb25zdCBjcmVhdGVTZWxlY3RvcjIgPSBjcmVhdGVTZWxlY3RvckNyZWF0b3IoLi4uYXJncyk7XHJcbiAgY29uc3QgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyID0gT2JqZWN0LmFzc2lnbigoLi4uYXJnczIpID0+IHtcclxuICAgIGNvbnN0IHNlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3IyKC4uLmFyZ3MyKTtcclxuICAgIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9ICh2YWx1ZSwgLi4ucmVzdCkgPT4gc2VsZWN0b3IoaXNEcmFmdCh2YWx1ZSkgPyBjdXJyZW50KHZhbHVlKSA6IHZhbHVlLCAuLi5yZXN0KTtcclxuICAgIE9iamVjdC5hc3NpZ24od3JhcHBlZFNlbGVjdG9yLCBzZWxlY3Rvcik7XHJcbiAgICByZXR1cm4gd3JhcHBlZFNlbGVjdG9yO1xyXG4gIH0sIHtcclxuICAgIHdpdGhUeXBlczogKCkgPT4gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyXHJcbiAgfSk7XHJcbiAgcmV0dXJuIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yMjtcclxufTtcclxudmFyIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvcih3ZWFrTWFwTWVtb2l6ZSk7XHJcblxyXG4vLyBzcmMvY29uZmlndXJlU3RvcmUudHNcclxuaW1wb3J0IHsgYXBwbHlNaWRkbGV3YXJlLCBjcmVhdGVTdG9yZSwgY29tcG9zZSBhcyBjb21wb3NlMiwgY29tYmluZVJlZHVjZXJzLCBpc1BsYWluT2JqZWN0IGFzIGlzUGxhaW5PYmplY3QyIH0gZnJvbSBcInJlZHV4XCI7XHJcblxyXG4vLyBzcmMvZGV2dG9vbHNFeHRlbnNpb24udHNcclxuaW1wb3J0IHsgY29tcG9zZSB9IGZyb20gXCJyZWR1eFwiO1xyXG52YXIgY29tcG9zZVdpdGhEZXZUb29scyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyA/IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gOiBmdW5jdGlvbigpIHtcclxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHZvaWQgMDtcclxuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIGNvbXBvc2U7XHJcbiAgcmV0dXJuIGNvbXBvc2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxufTtcclxudmFyIGRldlRvb2xzRW5oYW5jZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fID8gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gOiBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gZnVuY3Rpb24obm9vcDMpIHtcclxuICAgIHJldHVybiBub29wMztcclxuICB9O1xyXG59O1xyXG5cclxuLy8gc3JjL2dldERlZmF1bHRNaWRkbGV3YXJlLnRzXHJcbmltcG9ydCB7IHRodW5rIGFzIHRodW5rTWlkZGxld2FyZSwgd2l0aEV4dHJhQXJndW1lbnQgfSBmcm9tIFwicmVkdXgtdGh1bmtcIjtcclxuXHJcbi8vIHNyYy9jcmVhdGVBY3Rpb24udHNcclxuaW1wb3J0IHsgaXNBY3Rpb24gfSBmcm9tIFwicmVkdXhcIjtcclxuXHJcbi8vIHNyYy90c0hlbHBlcnMudHNcclxudmFyIGhhc01hdGNoRnVuY3Rpb24gPSAodikgPT4ge1xyXG4gIHJldHVybiB2ICYmIHR5cGVvZiB2Lm1hdGNoID09PSBcImZ1bmN0aW9uXCI7XHJcbn07XHJcblxyXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbih0eXBlLCBwcmVwYXJlQWN0aW9uKSB7XHJcbiAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvciguLi5hcmdzKSB7XHJcbiAgICBpZiAocHJlcGFyZUFjdGlvbikge1xyXG4gICAgICBsZXQgcHJlcGFyZWQgPSBwcmVwYXJlQWN0aW9uKC4uLmFyZ3MpO1xyXG4gICAgICBpZiAoIXByZXBhcmVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMCkgOiBcInByZXBhcmVBY3Rpb24gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0XCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICBwYXlsb2FkOiBwcmVwYXJlZC5wYXlsb2FkLFxyXG4gICAgICAgIC4uLlwibWV0YVwiIGluIHByZXBhcmVkICYmIHtcclxuICAgICAgICAgIG1ldGE6IHByZXBhcmVkLm1ldGFcclxuICAgICAgICB9LFxyXG4gICAgICAgIC4uLlwiZXJyb3JcIiBpbiBwcmVwYXJlZCAmJiB7XHJcbiAgICAgICAgICBlcnJvcjogcHJlcGFyZWQuZXJyb3JcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlLFxyXG4gICAgICBwYXlsb2FkOiBhcmdzWzBdXHJcbiAgICB9O1xyXG4gIH1cclxuICBhY3Rpb25DcmVhdG9yLnRvU3RyaW5nID0gKCkgPT4gYCR7dHlwZX1gO1xyXG4gIGFjdGlvbkNyZWF0b3IudHlwZSA9IHR5cGU7XHJcbiAgYWN0aW9uQ3JlYXRvci5tYXRjaCA9IChhY3Rpb24pID0+IGlzQWN0aW9uKGFjdGlvbikgJiYgYWN0aW9uLnR5cGUgPT09IHR5cGU7XHJcbiAgcmV0dXJuIGFjdGlvbkNyZWF0b3I7XHJcbn1cclxuZnVuY3Rpb24gaXNBY3Rpb25DcmVhdG9yKGFjdGlvbikge1xyXG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSBcImZ1bmN0aW9uXCIgJiYgXCJ0eXBlXCIgaW4gYWN0aW9uICYmIC8vIGhhc01hdGNoRnVuY3Rpb24gb25seSB3YW50cyBNYXRjaGVycyBidXQgSSBkb24ndCBzZWUgdGhlIHBvaW50IGluIHJld3JpdGluZyBpdFxyXG4gIGhhc01hdGNoRnVuY3Rpb24oYWN0aW9uKTtcclxufVxyXG5mdW5jdGlvbiBpc0ZTQShhY3Rpb24pIHtcclxuICByZXR1cm4gaXNBY3Rpb24oYWN0aW9uKSAmJiBPYmplY3Qua2V5cyhhY3Rpb24pLmV2ZXJ5KGlzVmFsaWRLZXkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XHJcbiAgcmV0dXJuIFtcInR5cGVcIiwgXCJwYXlsb2FkXCIsIFwiZXJyb3JcIiwgXCJtZXRhXCJdLmluZGV4T2Yoa2V5KSA+IC0xO1xyXG59XHJcblxyXG4vLyBzcmMvYWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUudHNcclxuZnVuY3Rpb24gZ2V0TWVzc2FnZSh0eXBlKSB7XHJcbiAgY29uc3Qgc3BsaXRUeXBlID0gdHlwZSA/IGAke3R5cGV9YC5zcGxpdChcIi9cIikgOiBbXTtcclxuICBjb25zdCBhY3Rpb25OYW1lID0gc3BsaXRUeXBlW3NwbGl0VHlwZS5sZW5ndGggLSAxXSB8fCBcImFjdGlvbkNyZWF0b3JcIjtcclxuICByZXR1cm4gYERldGVjdGVkIGFuIGFjdGlvbiBjcmVhdG9yIHdpdGggdHlwZSBcIiR7dHlwZSB8fCBcInVua25vd25cIn1cIiBiZWluZyBkaXNwYXRjaGVkLiBcclxuTWFrZSBzdXJlIHlvdSdyZSBjYWxsaW5nIHRoZSBhY3Rpb24gY3JlYXRvciBiZWZvcmUgZGlzcGF0Y2hpbmcsIGkuZS4gXFxgZGlzcGF0Y2goJHthY3Rpb25OYW1lfSgpKVxcYCBpbnN0ZWFkIG9mIFxcYGRpc3BhdGNoKCR7YWN0aW9uTmFtZX0pXFxgLiBUaGlzIGlzIG5lY2Vzc2FyeSBldmVuIGlmIHRoZSBhY3Rpb24gaGFzIG5vIHBheWxvYWQuYDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zID0ge30pIHtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICByZXR1cm4gKCkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IG5leHQoYWN0aW9uKTtcclxuICB9XHJcbiAgY29uc3Qge1xyXG4gICAgaXNBY3Rpb25DcmVhdG9yOiBpc0FjdGlvbkNyZWF0b3IyID0gaXNBY3Rpb25DcmVhdG9yXHJcbiAgfSA9IG9wdGlvbnM7XHJcbiAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XHJcbiAgICBpZiAoaXNBY3Rpb25DcmVhdG9yMihhY3Rpb24pKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihnZXRNZXNzYWdlKGFjdGlvbi50eXBlKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIHNyYy91dGlscy50c1xyXG5pbXBvcnQgeyBwcm9kdWNlIGFzIGNyZWF0ZU5leHRTdGF0ZSwgaXNEcmFmdGFibGUgfSBmcm9tIFwiaW1tZXJcIjtcclxuZnVuY3Rpb24gZ2V0VGltZU1lYXN1cmVVdGlscyhtYXhEZWxheSwgZm5OYW1lKSB7XHJcbiAgbGV0IGVsYXBzZWQgPSAwO1xyXG4gIHJldHVybiB7XHJcbiAgICBtZWFzdXJlVGltZShmbikge1xyXG4gICAgICBjb25zdCBzdGFydGVkID0gRGF0ZS5ub3coKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gZm4oKTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICBjb25zdCBmaW5pc2hlZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgZWxhcHNlZCArPSBmaW5pc2hlZCAtIHN0YXJ0ZWQ7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICB3YXJuSWZFeGNlZWRlZCgpIHtcclxuICAgICAgaWYgKGVsYXBzZWQgPiBtYXhEZWxheSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgJHtmbk5hbWV9IHRvb2sgJHtlbGFwc2VkfW1zLCB3aGljaCBpcyBtb3JlIHRoYW4gdGhlIHdhcm5pbmcgdGhyZXNob2xkIG9mICR7bWF4RGVsYXl9bXMuIFxyXG5JZiB5b3VyIHN0YXRlIG9yIGFjdGlvbnMgYXJlIHZlcnkgbGFyZ2UsIHlvdSBtYXkgd2FudCB0byBkaXNhYmxlIHRoZSBtaWRkbGV3YXJlIGFzIGl0IG1pZ2h0IGNhdXNlIHRvbyBtdWNoIG9mIGEgc2xvd2Rvd24gaW4gZGV2ZWxvcG1lbnQgbW9kZS4gU2VlIGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2dldERlZmF1bHRNaWRkbGV3YXJlIGZvciBpbnN0cnVjdGlvbnMuXHJcbkl0IGlzIGRpc2FibGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLCBzbyB5b3UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGF0LmApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG52YXIgVHVwbGUgPSBjbGFzcyBfVHVwbGUgZXh0ZW5kcyBBcnJheSB7XHJcbiAgY29uc3RydWN0b3IoLi4uaXRlbXMpIHtcclxuICAgIHN1cGVyKC4uLml0ZW1zKTtcclxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfVHVwbGUucHJvdG90eXBlKTtcclxuICB9XHJcbiAgc3RhdGljIGdldCBbU3ltYm9sLnNwZWNpZXNdKCkge1xyXG4gICAgcmV0dXJuIF9UdXBsZTtcclxuICB9XHJcbiAgY29uY2F0KC4uLmFycikge1xyXG4gICAgcmV0dXJuIHN1cGVyLmNvbmNhdC5hcHBseSh0aGlzLCBhcnIpO1xyXG4gIH1cclxuICBwcmVwZW5kKC4uLmFycikge1xyXG4gICAgaWYgKGFyci5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcnJbMF0pKSB7XHJcbiAgICAgIHJldHVybiBuZXcgX1R1cGxlKC4uLmFyclswXS5jb25jYXQodGhpcykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBfVHVwbGUoLi4uYXJyLmNvbmNhdCh0aGlzKSk7XHJcbiAgfVxyXG59O1xyXG5mdW5jdGlvbiBmcmVlemVEcmFmdGFibGUodmFsKSB7XHJcbiAgcmV0dXJuIGlzRHJhZnRhYmxlKHZhbCkgPyBjcmVhdGVOZXh0U3RhdGUodmFsLCAoKSA9PiB7XHJcbiAgfSkgOiB2YWw7XHJcbn1cclxuZnVuY3Rpb24gZ2V0T3JJbnNlcnRDb21wdXRlZChtYXAsIGtleSwgY29tcHV0ZSkge1xyXG4gIGlmIChtYXAuaGFzKGtleSkpIHJldHVybiBtYXAuZ2V0KGtleSk7XHJcbiAgcmV0dXJuIG1hcC5zZXQoa2V5LCBjb21wdXRlKGtleSkpLmdldChrZXkpO1xyXG59XHJcblxyXG4vLyBzcmMvaW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXHJcbmZ1bmN0aW9uIGlzSW1tdXRhYmxlRGVmYXVsdCh2YWx1ZSkge1xyXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT0gbnVsbCB8fCBPYmplY3QuaXNGcm96ZW4odmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIHRyYWNrRm9yTXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqKSB7XHJcbiAgY29uc3QgdHJhY2tlZFByb3BlcnRpZXMgPSB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmopO1xyXG4gIHJldHVybiB7XHJcbiAgICBkZXRlY3RNdXRhdGlvbnMoKSB7XHJcbiAgICAgIHJldHVybiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCB0cmFja2VkUHJvcGVydGllcywgb2JqKTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMgPSBbXSwgb2JqLCBwYXRoID0gXCJcIiwgY2hlY2tlZE9iamVjdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSB7XHJcbiAgY29uc3QgdHJhY2tlZCA9IHtcclxuICAgIHZhbHVlOiBvYmpcclxuICB9O1xyXG4gIGlmICghaXNJbW11dGFibGUob2JqKSAmJiAhY2hlY2tlZE9iamVjdHMuaGFzKG9iaikpIHtcclxuICAgIGNoZWNrZWRPYmplY3RzLmFkZChvYmopO1xyXG4gICAgdHJhY2tlZC5jaGlsZHJlbiA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XHJcbiAgICAgIGlmIChpZ25vcmVQYXRocy5sZW5ndGggJiYgaWdub3JlUGF0aHMuaW5kZXhPZihjaGlsZFBhdGgpICE9PSAtMSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHRyYWNrZWQuY2hpbGRyZW5ba2V5XSA9IHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9ialtrZXldLCBjaGlsZFBhdGgpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdHJhY2tlZDtcclxufVxyXG5mdW5jdGlvbiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZWRQYXRocyA9IFtdLCB0cmFja2VkUHJvcGVydHksIG9iaiwgc2FtZVBhcmVudFJlZiA9IGZhbHNlLCBwYXRoID0gXCJcIikge1xyXG4gIGNvbnN0IHByZXZPYmogPSB0cmFja2VkUHJvcGVydHkgPyB0cmFja2VkUHJvcGVydHkudmFsdWUgOiB2b2lkIDA7XHJcbiAgY29uc3Qgc2FtZVJlZiA9IHByZXZPYmogPT09IG9iajtcclxuICBpZiAoc2FtZVBhcmVudFJlZiAmJiAhc2FtZVJlZiAmJiAhTnVtYmVyLmlzTmFOKG9iaikpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHdhc011dGF0ZWQ6IHRydWUsXHJcbiAgICAgIHBhdGhcclxuICAgIH07XHJcbiAgfVxyXG4gIGlmIChpc0ltbXV0YWJsZShwcmV2T2JqKSB8fCBpc0ltbXV0YWJsZShvYmopKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB3YXNNdXRhdGVkOiBmYWxzZVxyXG4gICAgfTtcclxuICB9XHJcbiAgY29uc3Qga2V5c1RvRGV0ZWN0ID0ge307XHJcbiAgZm9yIChsZXQga2V5IGluIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbikge1xyXG4gICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlO1xyXG4gIH1cclxuICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XHJcbiAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWU7XHJcbiAgfVxyXG4gIGNvbnN0IGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xyXG4gIGZvciAobGV0IGtleSBpbiBrZXlzVG9EZXRlY3QpIHtcclxuICAgIGNvbnN0IG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xyXG4gICAgaWYgKGhhc0lnbm9yZWRQYXRocykge1xyXG4gICAgICBjb25zdCBoYXNNYXRjaGVzID0gaWdub3JlZFBhdGhzLnNvbWUoKGlnbm9yZWQpID0+IHtcclxuICAgICAgICBpZiAoaWdub3JlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xyXG4gICAgICAgICAgcmV0dXJuIGlnbm9yZWQudGVzdChuZXN0ZWRQYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5lc3RlZFBhdGggPT09IGlnbm9yZWQ7XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoaGFzTWF0Y2hlcykge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXN1bHQgPSBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZWRQYXRocywgdHJhY2tlZFByb3BlcnR5LmNoaWxkcmVuW2tleV0sIG9ialtrZXldLCBzYW1lUmVmLCBuZXN0ZWRQYXRoKTtcclxuICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4ge1xyXG4gICAgd2FzTXV0YXRlZDogZmFsc2VcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zID0ge30pIHtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICByZXR1cm4gKCkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IG5leHQoYWN0aW9uKTtcclxuICB9IGVsc2Uge1xyXG4gICAgbGV0IHN0cmluZ2lmeTIgPSBmdW5jdGlvbihvYmosIHNlcmlhbGl6ZXIsIGluZGVudCwgZGVjeWNsZXIpIHtcclxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgZ2V0U2VyaWFsaXplMihzZXJpYWxpemVyLCBkZWN5Y2xlciksIGluZGVudCk7XHJcbiAgICB9LCBnZXRTZXJpYWxpemUyID0gZnVuY3Rpb24oc2VyaWFsaXplciwgZGVjeWNsZXIpIHtcclxuICAgICAgbGV0IHN0YWNrID0gW10sIGtleXMgPSBbXTtcclxuICAgICAgaWYgKCFkZWN5Y2xlcikgZGVjeWNsZXIgPSBmdW5jdGlvbihfLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChzdGFja1swXSA9PT0gdmFsdWUpIHJldHVybiBcIltDaXJjdWxhciB+XVwiO1xyXG4gICAgICAgIHJldHVybiBcIltDaXJjdWxhciB+LlwiICsga2V5cy5zbGljZSgwLCBzdGFjay5pbmRleE9mKHZhbHVlKSkuam9pbihcIi5cIikgKyBcIl1cIjtcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgdmFyIHRoaXNQb3MgPSBzdGFjay5pbmRleE9mKHRoaXMpO1xyXG4gICAgICAgICAgfnRoaXNQb3MgPyBzdGFjay5zcGxpY2UodGhpc1BvcyArIDEpIDogc3RhY2sucHVzaCh0aGlzKTtcclxuICAgICAgICAgIH50aGlzUG9zID8ga2V5cy5zcGxpY2UodGhpc1BvcywgSW5maW5pdHksIGtleSkgOiBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgIGlmICh+c3RhY2suaW5kZXhPZih2YWx1ZSkpIHZhbHVlID0gZGVjeWNsZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcclxuICAgICAgICB9IGVsc2Ugc3RhY2sucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXIgPT0gbnVsbCA/IHZhbHVlIDogc2VyaWFsaXplci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICAgIHZhciBzdHJpbmdpZnkgPSBzdHJpbmdpZnkyLCBnZXRTZXJpYWxpemUgPSBnZXRTZXJpYWxpemUyO1xyXG4gICAgbGV0IHtcclxuICAgICAgaXNJbW11dGFibGUgPSBpc0ltbXV0YWJsZURlZmF1bHQsXHJcbiAgICAgIGlnbm9yZWRQYXRocyxcclxuICAgICAgd2FybkFmdGVyID0gMzJcclxuICAgIH0gPSBvcHRpb25zO1xyXG4gICAgY29uc3QgdHJhY2sgPSB0cmFja0Zvck11dGF0aW9ucy5iaW5kKG51bGwsIGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMpO1xyXG4gICAgcmV0dXJuICh7XHJcbiAgICAgIGdldFN0YXRlXHJcbiAgICB9KSA9PiB7XHJcbiAgICAgIGxldCBzdGF0ZSA9IGdldFN0YXRlKCk7XHJcbiAgICAgIGxldCB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xyXG4gICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICByZXR1cm4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcclxuICAgICAgICBjb25zdCBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XHJcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcclxuICAgICAgICAgIHN0YXRlID0gZ2V0U3RhdGUoKTtcclxuICAgICAgICAgIHJlc3VsdCA9IHRyYWNrZXIuZGV0ZWN0TXV0YXRpb25zKCk7XHJcbiAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xyXG4gICAgICAgICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE5KSA6IGBBIHN0YXRlIG11dGF0aW9uIHdhcyBkZXRlY3RlZCBiZXR3ZWVuIGRpc3BhdGNoZXMsIGluIHRoZSBwYXRoICcke3Jlc3VsdC5wYXRoIHx8IFwiXCJ9Jy4gIFRoaXMgbWF5IGNhdXNlIGluY29ycmVjdCBiZWhhdmlvci4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpYCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgZGlzcGF0Y2hlZEFjdGlvbiA9IG5leHQoYWN0aW9uKTtcclxuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xyXG4gICAgICAgICAgc3RhdGUgPSBnZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcclxuICAgICAgICAgIHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XHJcbiAgICAgICAgICBpZiAocmVzdWx0Lndhc011dGF0ZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjApIDogYEEgc3RhdGUgbXV0YXRpb24gd2FzIGRldGVjdGVkIGluc2lkZSBhIGRpc3BhdGNoLCBpbiB0aGUgcGF0aDogJHtyZXN1bHQucGF0aCB8fCBcIlwifS4gVGFrZSBhIGxvb2sgYXQgdGhlIHJlZHVjZXIocykgaGFuZGxpbmcgdGhlIGFjdGlvbiAke3N0cmluZ2lmeTIoYWN0aW9uKX0uIChodHRwczovL3JlZHV4LmpzLm9yZy9zdHlsZS1ndWlkZS9zdHlsZS1ndWlkZSNkby1ub3QtbXV0YXRlLXN0YXRlKWApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG1lYXN1cmVVdGlscy53YXJuSWZFeGNlZWRlZCgpO1xyXG4gICAgICAgIHJldHVybiBkaXNwYXRjaGVkQWN0aW9uO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8vIHNyYy9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcclxuaW1wb3J0IHsgaXNBY3Rpb24gYXMgaXNBY3Rpb24yLCBpc1BsYWluT2JqZWN0IH0gZnJvbSBcInJlZHV4XCI7XHJcbmZ1bmN0aW9uIGlzUGxhaW4odmFsKSB7XHJcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XHJcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIiB8fCBBcnJheS5pc0FycmF5KHZhbCkgfHwgaXNQbGFpbk9iamVjdCh2YWwpO1xyXG59XHJcbmZ1bmN0aW9uIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSh2YWx1ZSwgcGF0aCA9IFwiXCIsIGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbiwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzID0gW10sIGNhY2hlKSB7XHJcbiAgbGV0IGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlO1xyXG4gIGlmICghaXNTZXJpYWxpemFibGUodmFsdWUpKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBrZXlQYXRoOiBwYXRoIHx8IFwiPHJvb3Q+XCIsXHJcbiAgICAgIHZhbHVlXHJcbiAgICB9O1xyXG4gIH1cclxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGlmIChjYWNoZT8uaGFzKHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xyXG4gIGNvbnN0IGVudHJpZXMgPSBnZXRFbnRyaWVzICE9IG51bGwgPyBnZXRFbnRyaWVzKHZhbHVlKSA6IE9iamVjdC5lbnRyaWVzKHZhbHVlKTtcclxuICBjb25zdCBoYXNJZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMubGVuZ3RoID4gMDtcclxuICBmb3IgKGNvbnN0IFtrZXksIG5lc3RlZFZhbHVlXSBvZiBlbnRyaWVzKSB7XHJcbiAgICBjb25zdCBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcclxuICAgIGlmIChoYXNJZ25vcmVkUGF0aHMpIHtcclxuICAgICAgY29uc3QgaGFzTWF0Y2hlcyA9IGlnbm9yZWRQYXRocy5zb21lKChpZ25vcmVkKSA9PiB7XHJcbiAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcclxuICAgICAgICAgIHJldHVybiBpZ25vcmVkLnRlc3QobmVzdGVkUGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXN0ZWRQYXRoID09PSBpZ25vcmVkO1xyXG4gICAgICB9KTtcclxuICAgICAgaWYgKGhhc01hdGNoZXMpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFpc1NlcmlhbGl6YWJsZShuZXN0ZWRWYWx1ZSkpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBrZXlQYXRoOiBuZXN0ZWRQYXRoLFxyXG4gICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShuZXN0ZWRWYWx1ZSwgbmVzdGVkUGF0aCwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRQYXRocywgY2FjaGUpO1xyXG4gICAgICBpZiAoZm91bmROZXN0ZWRTZXJpYWxpemFibGUpIHtcclxuICAgICAgICByZXR1cm4gZm91bmROZXN0ZWRTZXJpYWxpemFibGU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgaWYgKGNhY2hlICYmIGlzTmVzdGVkRnJvemVuKHZhbHVlKSkgY2FjaGUuYWRkKHZhbHVlKTtcclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNOZXN0ZWRGcm96ZW4odmFsdWUpIHtcclxuICBpZiAoIU9iamVjdC5pc0Zyb3plbih2YWx1ZSkpIHJldHVybiBmYWxzZTtcclxuICBmb3IgKGNvbnN0IG5lc3RlZFZhbHVlIG9mIE9iamVjdC52YWx1ZXModmFsdWUpKSB7XHJcbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlICE9PSBcIm9iamVjdFwiIHx8IG5lc3RlZFZhbHVlID09PSBudWxsKSBjb250aW51ZTtcclxuICAgIGlmICghaXNOZXN0ZWRGcm96ZW4obmVzdGVkVmFsdWUpKSByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zID0ge30pIHtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICByZXR1cm4gKCkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IG5leHQoYWN0aW9uKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBpc1NlcmlhbGl6YWJsZSA9IGlzUGxhaW4sXHJcbiAgICAgIGdldEVudHJpZXMsXHJcbiAgICAgIGlnbm9yZWRBY3Rpb25zID0gW10sXHJcbiAgICAgIGlnbm9yZWRBY3Rpb25QYXRocyA9IFtcIm1ldGEuYXJnXCIsIFwibWV0YS5iYXNlUXVlcnlNZXRhXCJdLFxyXG4gICAgICBpZ25vcmVkUGF0aHMgPSBbXSxcclxuICAgICAgd2FybkFmdGVyID0gMzIsXHJcbiAgICAgIGlnbm9yZVN0YXRlID0gZmFsc2UsXHJcbiAgICAgIGlnbm9yZUFjdGlvbnMgPSBmYWxzZSxcclxuICAgICAgZGlzYWJsZUNhY2hlID0gZmFsc2VcclxuICAgIH0gPSBvcHRpb25zO1xyXG4gICAgY29uc3QgY2FjaGUgPSAhZGlzYWJsZUNhY2hlICYmIFdlYWtTZXQgPyAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSA6IHZvaWQgMDtcclxuICAgIHJldHVybiAoc3RvcmVBUEkpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XHJcbiAgICAgIGlmICghaXNBY3Rpb24yKGFjdGlvbikpIHtcclxuICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5leHQoYWN0aW9uKTtcclxuICAgICAgY29uc3QgbWVhc3VyZVV0aWxzID0gZ2V0VGltZU1lYXN1cmVVdGlscyh3YXJuQWZ0ZXIsIFwiU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlXCIpO1xyXG4gICAgICBpZiAoIWlnbm9yZUFjdGlvbnMgJiYgIShpZ25vcmVkQWN0aW9ucy5sZW5ndGggJiYgaWdub3JlZEFjdGlvbnMuaW5kZXhPZihhY3Rpb24udHlwZSkgIT09IC0xKSkge1xyXG4gICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZSgoKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKGFjdGlvbiwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRBY3Rpb25QYXRocywgY2FjaGUpO1xyXG4gICAgICAgICAgaWYgKGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcclxuICAgICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICAgIGtleVBhdGgsXHJcbiAgICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICAgICAgfSA9IGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gYW4gYWN0aW9uLCBpbiB0aGUgcGF0aDogXFxgJHtrZXlQYXRofVxcYC4gVmFsdWU6YCwgdmFsdWUsIFwiXFxuVGFrZSBhIGxvb2sgYXQgdGhlIGxvZ2ljIHRoYXQgZGlzcGF0Y2hlZCB0aGlzIGFjdGlvbjogXCIsIGFjdGlvbiwgXCJcXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9hY3Rpb25zI3doeS1zaG91bGQtdHlwZS1iZS1hLXN0cmluZy1vci1hdC1sZWFzdC1zZXJpYWxpemFibGUtd2h5LXNob3VsZC1teS1hY3Rpb24tdHlwZXMtYmUtY29uc3RhbnRzKVwiLCBcIlxcbihUbyBhbGxvdyBub24tc2VyaWFsaXphYmxlIHZhbHVlcyBzZWU6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvdXNhZ2UvdXNhZ2UtZ3VpZGUjd29ya2luZy13aXRoLW5vbi1zZXJpYWxpemFibGUtZGF0YSlcIik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFpZ25vcmVTdGF0ZSkge1xyXG4gICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZSgoKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlQVBJLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICBjb25zdCBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoc3RhdGUsIFwiXCIsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkUGF0aHMsIGNhY2hlKTtcclxuICAgICAgICAgIGlmIChmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcclxuICAgICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICAgIGtleVBhdGgsXHJcbiAgICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICAgICAgfSA9IGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZTtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQSBub24tc2VyaWFsaXphYmxlIHZhbHVlIHdhcyBkZXRlY3RlZCBpbiB0aGUgc3RhdGUsIGluIHRoZSBwYXRoOiBcXGAke2tleVBhdGh9XFxgLiBWYWx1ZTpgLCB2YWx1ZSwgYFxyXG5UYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGlzIGFjdGlvbiB0eXBlOiAke2FjdGlvbi50eXBlfS5cclxuKFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9mYXEvb3JnYW5pemluZy1zdGF0ZSNjYW4taS1wdXQtZnVuY3Rpb25zLXByb21pc2VzLW9yLW90aGVyLW5vbi1zZXJpYWxpemFibGUtaXRlbXMtaW4tbXktc3RvcmUtc3RhdGUpYCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vLyBzcmMvZ2V0RGVmYXVsdE1pZGRsZXdhcmUudHNcclxuZnVuY3Rpb24gaXNCb29sZWFuKHgpIHtcclxuICByZXR1cm4gdHlwZW9mIHggPT09IFwiYm9vbGVhblwiO1xyXG59XHJcbnZhciBidWlsZEdldERlZmF1bHRNaWRkbGV3YXJlID0gKCkgPT4gZnVuY3Rpb24gZ2V0RGVmYXVsdE1pZGRsZXdhcmUob3B0aW9ucykge1xyXG4gIGNvbnN0IHtcclxuICAgIHRodW5rID0gdHJ1ZSxcclxuICAgIGltbXV0YWJsZUNoZWNrID0gdHJ1ZSxcclxuICAgIHNlcmlhbGl6YWJsZUNoZWNrID0gdHJ1ZSxcclxuICAgIGFjdGlvbkNyZWF0b3JDaGVjayA9IHRydWVcclxuICB9ID0gb3B0aW9ucyA/PyB7fTtcclxuICBsZXQgbWlkZGxld2FyZUFycmF5ID0gbmV3IFR1cGxlKCk7XHJcbiAgaWYgKHRodW5rKSB7XHJcbiAgICBpZiAoaXNCb29sZWFuKHRodW5rKSkge1xyXG4gICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh0aHVua01pZGRsZXdhcmUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2god2l0aEV4dHJhQXJndW1lbnQodGh1bmsuZXh0cmFBcmd1bWVudCkpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICBpZiAoaW1tdXRhYmxlQ2hlY2spIHtcclxuICAgICAgbGV0IGltbXV0YWJsZU9wdGlvbnMgPSB7fTtcclxuICAgICAgaWYgKCFpc0Jvb2xlYW4oaW1tdXRhYmxlQ2hlY2spKSB7XHJcbiAgICAgICAgaW1tdXRhYmxlT3B0aW9ucyA9IGltbXV0YWJsZUNoZWNrO1xyXG4gICAgICB9XHJcbiAgICAgIG1pZGRsZXdhcmVBcnJheS51bnNoaWZ0KGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShpbW11dGFibGVPcHRpb25zKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2VyaWFsaXphYmxlQ2hlY2spIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YWJsZU9wdGlvbnMgPSB7fTtcclxuICAgICAgaWYgKCFpc0Jvb2xlYW4oc2VyaWFsaXphYmxlQ2hlY2spKSB7XHJcbiAgICAgICAgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHNlcmlhbGl6YWJsZUNoZWNrO1xyXG4gICAgICB9XHJcbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShzZXJpYWxpemFibGVPcHRpb25zKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoYWN0aW9uQ3JlYXRvckNoZWNrKSB7XHJcbiAgICAgIGxldCBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IHt9O1xyXG4gICAgICBpZiAoIWlzQm9vbGVhbihhY3Rpb25DcmVhdG9yQ2hlY2spKSB7XHJcbiAgICAgICAgYWN0aW9uQ3JlYXRvck9wdGlvbnMgPSBhY3Rpb25DcmVhdG9yQ2hlY2s7XHJcbiAgICAgIH1cclxuICAgICAgbWlkZGxld2FyZUFycmF5LnVuc2hpZnQoY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUoYWN0aW9uQ3JlYXRvck9wdGlvbnMpKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG1pZGRsZXdhcmVBcnJheTtcclxufTtcclxuXHJcbi8vIHNyYy9hdXRvQmF0Y2hFbmhhbmNlci50c1xyXG52YXIgU0hPVUxEX0FVVE9CQVRDSCA9IFwiUlRLX2F1dG9CYXRjaFwiO1xyXG52YXIgcHJlcGFyZUF1dG9CYXRjaGVkID0gKCkgPT4gKHBheWxvYWQpID0+ICh7XHJcbiAgcGF5bG9hZCxcclxuICBtZXRhOiB7XHJcbiAgICBbU0hPVUxEX0FVVE9CQVRDSF06IHRydWVcclxuICB9XHJcbn0pO1xyXG52YXIgY3JlYXRlUXVldWVXaXRoVGltZXIgPSAodGltZW91dCkgPT4ge1xyXG4gIHJldHVybiAobm90aWZ5KSA9PiB7XHJcbiAgICBzZXRUaW1lb3V0KG5vdGlmeSwgdGltZW91dCk7XHJcbiAgfTtcclxufTtcclxudmFyIGF1dG9CYXRjaEVuaGFuY2VyID0gKG9wdGlvbnMgPSB7XHJcbiAgdHlwZTogXCJyYWZcIlxyXG59KSA9PiAobmV4dCkgPT4gKC4uLmFyZ3MpID0+IHtcclxuICBjb25zdCBzdG9yZSA9IG5leHQoLi4uYXJncyk7XHJcbiAgbGV0IG5vdGlmeWluZyA9IHRydWU7XHJcbiAgbGV0IHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gZmFsc2U7XHJcbiAgbGV0IG5vdGlmaWNhdGlvblF1ZXVlZCA9IGZhbHNlO1xyXG4gIGNvbnN0IGxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XHJcbiAgY29uc3QgcXVldWVDYWxsYmFjayA9IG9wdGlvbnMudHlwZSA9PT0gXCJ0aWNrXCIgPyBxdWV1ZU1pY3JvdGFzayA6IG9wdGlvbnMudHlwZSA9PT0gXCJyYWZcIiA/IChcclxuICAgIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSB3b24ndCBleGlzdCBpbiBTU1IgZW52aXJvbm1lbnRzLiBGYWxsIGJhY2sgdG8gYSB2YWd1ZSBhcHByb3hpbWF0aW9uIGp1c3QgdG8ga2VlcCBmcm9tIGVycm9yaW5nLlxyXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKDEwKVxyXG4gICkgOiBvcHRpb25zLnR5cGUgPT09IFwiY2FsbGJhY2tcIiA/IG9wdGlvbnMucXVldWVOb3RpZmljYXRpb24gOiBjcmVhdGVRdWV1ZVdpdGhUaW1lcihvcHRpb25zLnRpbWVvdXQpO1xyXG4gIGNvbnN0IG5vdGlmeUxpc3RlbmVycyA9ICgpID0+IHtcclxuICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IGZhbHNlO1xyXG4gICAgaWYgKHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrKSB7XHJcbiAgICAgIHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gZmFsc2U7XHJcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsKSA9PiBsKCkpO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0b3JlLCB7XHJcbiAgICAvLyBPdmVycmlkZSB0aGUgYmFzZSBgc3RvcmUuc3Vic2NyaWJlYCBtZXRob2QgdG8ga2VlcCBvcmlnaW5hbCBsaXN0ZW5lcnNcclxuICAgIC8vIGZyb20gcnVubmluZyBpZiB3ZSdyZSBkZWxheWluZyBub3RpZmljYXRpb25zXHJcbiAgICBzdWJzY3JpYmUobGlzdGVuZXIyKSB7XHJcbiAgICAgIGNvbnN0IHdyYXBwZWRMaXN0ZW5lciA9ICgpID0+IG5vdGlmeWluZyAmJiBsaXN0ZW5lcjIoKTtcclxuICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdG9yZS5zdWJzY3JpYmUod3JhcHBlZExpc3RlbmVyKTtcclxuICAgICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcjIpO1xyXG4gICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcjIpO1xyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICAgIC8vIE92ZXJyaWRlIHRoZSBiYXNlIGBzdG9yZS5kaXNwYXRjaGAgbWV0aG9kIHNvIHRoYXQgd2UgY2FuIGNoZWNrIGFjdGlvbnNcclxuICAgIC8vIGZvciB0aGUgYHNob3VsZEF1dG9CYXRjaGAgZmxhZyBhbmQgZGV0ZXJtaW5lIGlmIGJhdGNoaW5nIGlzIGFjdGl2ZVxyXG4gICAgZGlzcGF0Y2goYWN0aW9uKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbm90aWZ5aW5nID0gIWFjdGlvbj8ubWV0YT8uW1NIT1VMRF9BVVRPQkFUQ0hdO1xyXG4gICAgICAgIHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gIW5vdGlmeWluZztcclxuICAgICAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcclxuICAgICAgICAgIGlmICghbm90aWZpY2F0aW9uUXVldWVkKSB7XHJcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHF1ZXVlQ2FsbGJhY2sobm90aWZ5TGlzdGVuZXJzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgbm90aWZ5aW5nID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG59O1xyXG5cclxuLy8gc3JjL2dldERlZmF1bHRFbmhhbmNlcnMudHNcclxudmFyIGJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyA9IChtaWRkbGV3YXJlRW5oYW5jZXIpID0+IGZ1bmN0aW9uIGdldERlZmF1bHRFbmhhbmNlcnMob3B0aW9ucykge1xyXG4gIGNvbnN0IHtcclxuICAgIGF1dG9CYXRjaCA9IHRydWVcclxuICB9ID0gb3B0aW9ucyA/PyB7fTtcclxuICBsZXQgZW5oYW5jZXJBcnJheSA9IG5ldyBUdXBsZShtaWRkbGV3YXJlRW5oYW5jZXIpO1xyXG4gIGlmIChhdXRvQmF0Y2gpIHtcclxuICAgIGVuaGFuY2VyQXJyYXkucHVzaChhdXRvQmF0Y2hFbmhhbmNlcih0eXBlb2YgYXV0b0JhdGNoID09PSBcIm9iamVjdFwiID8gYXV0b0JhdGNoIDogdm9pZCAwKSk7XHJcbiAgfVxyXG4gIHJldHVybiBlbmhhbmNlckFycmF5O1xyXG59O1xyXG5cclxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXHJcbmZ1bmN0aW9uIGNvbmZpZ3VyZVN0b3JlKG9wdGlvbnMpIHtcclxuICBjb25zdCBnZXREZWZhdWx0TWlkZGxld2FyZSA9IGJ1aWxkR2V0RGVmYXVsdE1pZGRsZXdhcmUoKTtcclxuICBjb25zdCB7XHJcbiAgICByZWR1Y2VyID0gdm9pZCAwLFxyXG4gICAgbWlkZGxld2FyZSxcclxuICAgIGRldlRvb2xzID0gdHJ1ZSxcclxuICAgIGR1cGxpY2F0ZU1pZGRsZXdhcmVDaGVjayA9IHRydWUsXHJcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHZvaWQgMCxcclxuICAgIGVuaGFuY2VycyA9IHZvaWQgMFxyXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xyXG4gIGxldCByb290UmVkdWNlcjtcclxuICBpZiAodHlwZW9mIHJlZHVjZXIgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgcm9vdFJlZHVjZXIgPSByZWR1Y2VyO1xyXG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdDIocmVkdWNlcikpIHtcclxuICAgIHJvb3RSZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHJlZHVjZXIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxKSA6IFwiYHJlZHVjZXJgIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQsIGFuZCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IG9mIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gY29tYmluZVJlZHVjZXJzXCIpO1xyXG4gIH1cclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG1pZGRsZXdhcmUgJiYgdHlwZW9mIG1pZGRsZXdhcmUgIT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMikgOiBcImBtaWRkbGV3YXJlYCBmaWVsZCBtdXN0IGJlIGEgY2FsbGJhY2tcIik7XHJcbiAgfVxyXG4gIGxldCBmaW5hbE1pZGRsZXdhcmU7XHJcbiAgaWYgKHR5cGVvZiBtaWRkbGV3YXJlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgIGZpbmFsTWlkZGxld2FyZSA9IG1pZGRsZXdhcmUoZ2V0RGVmYXVsdE1pZGRsZXdhcmUpO1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhQXJyYXkuaXNBcnJheShmaW5hbE1pZGRsZXdhcmUpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMpIDogXCJ3aGVuIHVzaW5nIGEgbWlkZGxld2FyZSBidWlsZGVyIGZ1bmN0aW9uLCBhbiBhcnJheSBvZiBtaWRkbGV3YXJlIG11c3QgYmUgcmV0dXJuZWRcIik7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGZpbmFsTWlkZGxld2FyZSA9IGdldERlZmF1bHRNaWRkbGV3YXJlKCk7XHJcbiAgfVxyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZmluYWxNaWRkbGV3YXJlLnNvbWUoKGl0ZW0pID0+IHR5cGVvZiBpdGVtICE9PSBcImZ1bmN0aW9uXCIpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0KSA6IFwiZWFjaCBtaWRkbGV3YXJlIHByb3ZpZGVkIHRvIGNvbmZpZ3VyZVN0b3JlIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcclxuICB9XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBkdXBsaWNhdGVNaWRkbGV3YXJlQ2hlY2spIHtcclxuICAgIGxldCBtaWRkbGV3YXJlUmVmZXJlbmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XHJcbiAgICBmaW5hbE1pZGRsZXdhcmUuZm9yRWFjaCgobWlkZGxld2FyZTIpID0+IHtcclxuICAgICAgaWYgKG1pZGRsZXdhcmVSZWZlcmVuY2VzLmhhcyhtaWRkbGV3YXJlMikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0MikgOiBcIkR1cGxpY2F0ZSBtaWRkbGV3YXJlIHJlZmVyZW5jZXMgZm91bmQgd2hlbiBjcmVhdGluZyB0aGUgc3RvcmUuIEVuc3VyZSB0aGF0IGVhY2ggbWlkZGxld2FyZSBpcyBvbmx5IGluY2x1ZGVkIG9uY2UuXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIG1pZGRsZXdhcmVSZWZlcmVuY2VzLmFkZChtaWRkbGV3YXJlMik7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgbGV0IGZpbmFsQ29tcG9zZSA9IGNvbXBvc2UyO1xyXG4gIGlmIChkZXZUb29scykge1xyXG4gICAgZmluYWxDb21wb3NlID0gY29tcG9zZVdpdGhEZXZUb29scyh7XHJcbiAgICAgIC8vIEVuYWJsZSBjYXB0dXJlIG9mIHN0YWNrIHRyYWNlcyBmb3IgZGlzcGF0Y2hlZCBSZWR1eCBhY3Rpb25zXHJcbiAgICAgIHRyYWNlOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIsXHJcbiAgICAgIC4uLnR5cGVvZiBkZXZUb29scyA9PT0gXCJvYmplY3RcIiAmJiBkZXZUb29sc1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGNvbnN0IG1pZGRsZXdhcmVFbmhhbmNlciA9IGFwcGx5TWlkZGxld2FyZSguLi5maW5hbE1pZGRsZXdhcmUpO1xyXG4gIGNvbnN0IGdldERlZmF1bHRFbmhhbmNlcnMgPSBidWlsZEdldERlZmF1bHRFbmhhbmNlcnMobWlkZGxld2FyZUVuaGFuY2VyKTtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGVuaGFuY2VycyAmJiB0eXBlb2YgZW5oYW5jZXJzICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDUpIDogXCJgZW5oYW5jZXJzYCBmaWVsZCBtdXN0IGJlIGEgY2FsbGJhY2tcIik7XHJcbiAgfVxyXG4gIGxldCBzdG9yZUVuaGFuY2VycyA9IHR5cGVvZiBlbmhhbmNlcnMgPT09IFwiZnVuY3Rpb25cIiA/IGVuaGFuY2VycyhnZXREZWZhdWx0RW5oYW5jZXJzKSA6IGdldERlZmF1bHRFbmhhbmNlcnMoKTtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFBcnJheS5pc0FycmF5KHN0b3JlRW5oYW5jZXJzKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNikgOiBcImBlbmhhbmNlcnNgIGNhbGxiYWNrIG11c3QgcmV0dXJuIGFuIGFycmF5XCIpO1xyXG4gIH1cclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHN0b3JlRW5oYW5jZXJzLnNvbWUoKGl0ZW0pID0+IHR5cGVvZiBpdGVtICE9PSBcImZ1bmN0aW9uXCIpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg3KSA6IFwiZWFjaCBlbmhhbmNlciBwcm92aWRlZCB0byBjb25maWd1cmVTdG9yZSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XHJcbiAgfVxyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZmluYWxNaWRkbGV3YXJlLmxlbmd0aCAmJiAhc3RvcmVFbmhhbmNlcnMuaW5jbHVkZXMobWlkZGxld2FyZUVuaGFuY2VyKSkge1xyXG4gICAgY29uc29sZS5lcnJvcihcIm1pZGRsZXdhcmVzIHdlcmUgcHJvdmlkZWQsIGJ1dCBtaWRkbGV3YXJlIGVuaGFuY2VyIHdhcyBub3QgaW5jbHVkZWQgaW4gZmluYWwgZW5oYW5jZXJzIC0gbWFrZSBzdXJlIHRvIGNhbGwgYGdldERlZmF1bHRFbmhhbmNlcnNgXCIpO1xyXG4gIH1cclxuICBjb25zdCBjb21wb3NlZEVuaGFuY2VyID0gZmluYWxDb21wb3NlKC4uLnN0b3JlRW5oYW5jZXJzKTtcclxuICByZXR1cm4gY3JlYXRlU3RvcmUocm9vdFJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBjb21wb3NlZEVuaGFuY2VyKTtcclxufVxyXG5cclxuLy8gc3JjL2NyZWF0ZVJlZHVjZXIudHNcclxuaW1wb3J0IHsgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUyLCBpc0RyYWZ0IGFzIGlzRHJhZnQyLCBpc0RyYWZ0YWJsZSBhcyBpc0RyYWZ0YWJsZTIgfSBmcm9tIFwiaW1tZXJcIjtcclxuXHJcbi8vIHNyYy9tYXBCdWlsZGVycy50c1xyXG5mdW5jdGlvbiBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhidWlsZGVyQ2FsbGJhY2spIHtcclxuICBjb25zdCBhY3Rpb25zTWFwID0ge307XHJcbiAgY29uc3QgYWN0aW9uTWF0Y2hlcnMgPSBbXTtcclxuICBsZXQgZGVmYXVsdENhc2VSZWR1Y2VyO1xyXG4gIGNvbnN0IGJ1aWxkZXIgPSB7XHJcbiAgICBhZGRDYXNlKHR5cGVPckFjdGlvbkNyZWF0b3IsIHJlZHVjZXIpIHtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgIGlmIChhY3Rpb25NYXRjaGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNikgOiBcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGRNYXRjaGVyYFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjcpIDogXCJgYnVpbGRlci5hZGRDYXNlYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHR5cGVPckFjdGlvbkNyZWF0b3IgPT09IFwic3RyaW5nXCIgPyB0eXBlT3JBY3Rpb25DcmVhdG9yIDogdHlwZU9yQWN0aW9uQ3JlYXRvci50eXBlO1xyXG4gICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyOCkgOiBcImBidWlsZGVyLmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBhbiBlbXB0eSBhY3Rpb24gdHlwZVwiKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZSBpbiBhY3Rpb25zTWFwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjkpIDogYFxcYGJ1aWxkZXIuYWRkQ2FzZVxcYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggdHdvIHJlZHVjZXJzIGZvciB0aGUgc2FtZSBhY3Rpb24gdHlwZSAnJHt0eXBlfSdgKTtcclxuICAgICAgfVxyXG4gICAgICBhY3Rpb25zTWFwW3R5cGVdID0gcmVkdWNlcjtcclxuICAgICAgcmV0dXJuIGJ1aWxkZXI7XHJcbiAgICB9LFxyXG4gICAgYWRkTWF0Y2hlcihtYXRjaGVyLCByZWR1Y2VyKSB7XHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMCkgOiBcImBidWlsZGVyLmFkZE1hdGNoZXJgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGFjdGlvbk1hdGNoZXJzLnB1c2goe1xyXG4gICAgICAgIG1hdGNoZXIsXHJcbiAgICAgICAgcmVkdWNlclxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGJ1aWxkZXI7XHJcbiAgICB9LFxyXG4gICAgYWRkRGVmYXVsdENhc2UocmVkdWNlcikge1xyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzEpIDogXCJgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWAgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2VcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGRlZmF1bHRDYXNlUmVkdWNlciA9IHJlZHVjZXI7XHJcbiAgICAgIHJldHVybiBidWlsZGVyO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgYnVpbGRlckNhbGxiYWNrKGJ1aWxkZXIpO1xyXG4gIHJldHVybiBbYWN0aW9uc01hcCwgYWN0aW9uTWF0Y2hlcnMsIGRlZmF1bHRDYXNlUmVkdWNlcl07XHJcbn1cclxuXHJcbi8vIHNyYy9jcmVhdGVSZWR1Y2VyLnRzXHJcbmZ1bmN0aW9uIGlzU3RhdGVGdW5jdGlvbih4KSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVkdWNlcihpbml0aWFsU3RhdGUsIG1hcE9yQnVpbGRlckNhbGxiYWNrKSB7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgaWYgKHR5cGVvZiBtYXBPckJ1aWxkZXJDYWxsYmFjayA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg4KSA6IFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVJlZHVjZXJgIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgdGhlICdidWlsZGVyIGNhbGxiYWNrJyBub3RhdGlvbiBpbnN0ZWFkOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9jcmVhdGVSZWR1Y2VyXCIpO1xyXG4gICAgfVxyXG4gIH1cclxuICBsZXQgW2FjdGlvbnNNYXAsIGZpbmFsQWN0aW9uTWF0Y2hlcnMsIGZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXSA9IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG1hcE9yQnVpbGRlckNhbGxiYWNrKTtcclxuICBsZXQgZ2V0SW5pdGlhbFN0YXRlO1xyXG4gIGlmIChpc1N0YXRlRnVuY3Rpb24oaW5pdGlhbFN0YXRlKSkge1xyXG4gICAgZ2V0SW5pdGlhbFN0YXRlID0gKCkgPT4gZnJlZXplRHJhZnRhYmxlKGluaXRpYWxTdGF0ZSgpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgZnJvemVuSW5pdGlhbFN0YXRlID0gZnJlZXplRHJhZnRhYmxlKGluaXRpYWxTdGF0ZSk7XHJcbiAgICBnZXRJbml0aWFsU3RhdGUgPSAoKSA9PiBmcm96ZW5Jbml0aWFsU3RhdGU7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlZHVjZXIoc3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKSwgYWN0aW9uKSB7XHJcbiAgICBsZXQgY2FzZVJlZHVjZXJzID0gW2FjdGlvbnNNYXBbYWN0aW9uLnR5cGVdLCAuLi5maW5hbEFjdGlvbk1hdGNoZXJzLmZpbHRlcigoe1xyXG4gICAgICBtYXRjaGVyXHJcbiAgICB9KSA9PiBtYXRjaGVyKGFjdGlvbikpLm1hcCgoe1xyXG4gICAgICByZWR1Y2VyOiByZWR1Y2VyMlxyXG4gICAgfSkgPT4gcmVkdWNlcjIpXTtcclxuICAgIGlmIChjYXNlUmVkdWNlcnMuZmlsdGVyKChjcikgPT4gISFjcikubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGNhc2VSZWR1Y2VycyA9IFtmaW5hbERlZmF1bHRDYXNlUmVkdWNlcl07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2FzZVJlZHVjZXJzLnJlZHVjZSgocHJldmlvdXNTdGF0ZSwgY2FzZVJlZHVjZXIpID0+IHtcclxuICAgICAgaWYgKGNhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgaWYgKGlzRHJhZnQyKHByZXZpb3VzU3RhdGUpKSB7XHJcbiAgICAgICAgICBjb25zdCBkcmFmdCA9IHByZXZpb3VzU3RhdGU7XHJcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcclxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSBlbHNlIGlmICghaXNEcmFmdGFibGUyKHByZXZpb3VzU3RhdGUpKSB7XHJcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihwcmV2aW91c1N0YXRlLCBhY3Rpb24pO1xyXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGlmIChwcmV2aW91c1N0YXRlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJBIGNhc2UgcmVkdWNlciBvbiBhIG5vbi1kcmFmdGFibGUgdmFsdWUgbXVzdCBub3QgcmV0dXJuIHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBjcmVhdGVOZXh0U3RhdGUyKHByZXZpb3VzU3RhdGUsIChkcmFmdCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoZHJhZnQsIGFjdGlvbik7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XHJcbiAgICB9LCBzdGF0ZSk7XHJcbiAgfVxyXG4gIHJlZHVjZXIuZ2V0SW5pdGlhbFN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlO1xyXG4gIHJldHVybiByZWR1Y2VyO1xyXG59XHJcblxyXG4vLyBzcmMvbWF0Y2hlcnMudHNcclxudmFyIG1hdGNoZXMgPSAobWF0Y2hlciwgYWN0aW9uKSA9PiB7XHJcbiAgaWYgKGhhc01hdGNoRnVuY3Rpb24obWF0Y2hlcikpIHtcclxuICAgIHJldHVybiBtYXRjaGVyLm1hdGNoKGFjdGlvbik7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBtYXRjaGVyKGFjdGlvbik7XHJcbiAgfVxyXG59O1xyXG5mdW5jdGlvbiBpc0FueU9mKC4uLm1hdGNoZXJzKSB7XHJcbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcclxuICAgIHJldHVybiBtYXRjaGVycy5zb21lKChtYXRjaGVyKSA9PiBtYXRjaGVzKG1hdGNoZXIsIGFjdGlvbikpO1xyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gaXNBbGxPZiguLi5tYXRjaGVycykge1xyXG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XHJcbiAgICByZXR1cm4gbWF0Y2hlcnMuZXZlcnkoKG1hdGNoZXIpID0+IG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKSk7XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIHZhbGlkU3RhdHVzKSB7XHJcbiAgaWYgKCFhY3Rpb24gfHwgIWFjdGlvbi5tZXRhKSByZXR1cm4gZmFsc2U7XHJcbiAgY29uc3QgaGFzVmFsaWRSZXF1ZXN0SWQgPSB0eXBlb2YgYWN0aW9uLm1ldGEucmVxdWVzdElkID09PSBcInN0cmluZ1wiO1xyXG4gIGNvbnN0IGhhc1ZhbGlkUmVxdWVzdFN0YXR1cyA9IHZhbGlkU3RhdHVzLmluZGV4T2YoYWN0aW9uLm1ldGEucmVxdWVzdFN0YXR1cykgPiAtMTtcclxuICByZXR1cm4gaGFzVmFsaWRSZXF1ZXN0SWQgJiYgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzO1xyXG59XHJcbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FycmF5KGEpIHtcclxuICByZXR1cm4gdHlwZW9mIGFbMF0gPT09IFwiZnVuY3Rpb25cIiAmJiBcInBlbmRpbmdcIiBpbiBhWzBdICYmIFwiZnVsZmlsbGVkXCIgaW4gYVswXSAmJiBcInJlamVjdGVkXCIgaW4gYVswXTtcclxufVxyXG5mdW5jdGlvbiBpc1BlbmRpbmcoLi4uYXN5bmNUaHVua3MpIHtcclxuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gKGFjdGlvbikgPT4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJwZW5kaW5nXCJdKTtcclxuICB9XHJcbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgIHJldHVybiBpc1BlbmRpbmcoKShhc3luY1RodW5rc1swXSk7XHJcbiAgfVxyXG4gIHJldHVybiBpc0FueU9mKC4uLmFzeW5jVGh1bmtzLm1hcCgoYXN5bmNUaHVuaykgPT4gYXN5bmNUaHVuay5wZW5kaW5nKSk7XHJcbn1cclxuZnVuY3Rpb24gaXNSZWplY3RlZCguLi5hc3luY1RodW5rcykge1xyXG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInJlamVjdGVkXCJdKTtcclxuICB9XHJcbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgIHJldHVybiBpc1JlamVjdGVkKCkoYXN5bmNUaHVua3NbMF0pO1xyXG4gIH1cclxuICByZXR1cm4gaXNBbnlPZiguLi5hc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsucmVqZWN0ZWQpKTtcclxufVxyXG5mdW5jdGlvbiBpc1JlamVjdGVkV2l0aFZhbHVlKC4uLmFzeW5jVGh1bmtzKSB7XHJcbiAgY29uc3QgaGFzRmxhZyA9IChhY3Rpb24pID0+IHtcclxuICAgIHJldHVybiBhY3Rpb24gJiYgYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWU7XHJcbiAgfTtcclxuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gaXNBbGxPZihpc1JlamVjdGVkKC4uLmFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XHJcbiAgfVxyXG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XHJcbiAgICByZXR1cm4gaXNSZWplY3RlZFdpdGhWYWx1ZSgpKGFzeW5jVGh1bmtzWzBdKTtcclxuICB9XHJcbiAgcmV0dXJuIGlzQWxsT2YoaXNSZWplY3RlZCguLi5hc3luY1RodW5rcyksIGhhc0ZsYWcpO1xyXG59XHJcbmZ1bmN0aW9uIGlzRnVsZmlsbGVkKC4uLmFzeW5jVGh1bmtzKSB7XHJcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wiZnVsZmlsbGVkXCJdKTtcclxuICB9XHJcbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgIHJldHVybiBpc0Z1bGZpbGxlZCgpKGFzeW5jVGh1bmtzWzBdKTtcclxuICB9XHJcbiAgcmV0dXJuIGlzQW55T2YoLi4uYXN5bmNUaHVua3MubWFwKChhc3luY1RodW5rKSA9PiBhc3luY1RodW5rLmZ1bGZpbGxlZCkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FjdGlvbiguLi5hc3luY1RodW5rcykge1xyXG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInBlbmRpbmdcIiwgXCJmdWxmaWxsZWRcIiwgXCJyZWplY3RlZFwiXSk7XHJcbiAgfVxyXG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XHJcbiAgICByZXR1cm4gaXNBc3luY1RodW5rQWN0aW9uKCkoYXN5bmNUaHVua3NbMF0pO1xyXG4gIH1cclxuICByZXR1cm4gaXNBbnlPZiguLi5hc3luY1RodW5rcy5mbGF0TWFwKChhc3luY1RodW5rKSA9PiBbYXN5bmNUaHVuay5wZW5kaW5nLCBhc3luY1RodW5rLnJlamVjdGVkLCBhc3luY1RodW5rLmZ1bGZpbGxlZF0pKTtcclxufVxyXG5cclxuLy8gc3JjL25hbm9pZC50c1xyXG52YXIgdXJsQWxwaGFiZXQgPSBcIk1vZHVsZVN5bWJoYXNPd25Qci0wMTIzNDU2Nzg5QUJDREVGR0hOUlZmZ2N0aVV2el9LcVlUSmtMeHBaWElqUVdcIjtcclxudmFyIG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcclxuICBsZXQgaWQgPSBcIlwiO1xyXG4gIGxldCBpID0gc2l6ZTtcclxuICB3aGlsZSAoaS0tKSB7XHJcbiAgICBpZCArPSB1cmxBbHBoYWJldFtNYXRoLnJhbmRvbSgpICogNjQgfCAwXTtcclxuICB9XHJcbiAgcmV0dXJuIGlkO1xyXG59O1xyXG5cclxuLy8gc3JjL2NyZWF0ZUFzeW5jVGh1bmsudHNcclxudmFyIGNvbW1vblByb3BlcnRpZXMgPSBbXCJuYW1lXCIsIFwibWVzc2FnZVwiLCBcInN0YWNrXCIsIFwiY29kZVwiXTtcclxudmFyIFJlamVjdFdpdGhWYWx1ZSA9IGNsYXNzIHtcclxuICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBtZXRhKSB7XHJcbiAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xyXG4gICAgdGhpcy5tZXRhID0gbWV0YTtcclxuICB9XHJcbiAgLypcclxuICB0eXBlLW9ubHkgcHJvcGVydHkgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBSZWplY3RXaXRoVmFsdWUgYW5kIEZ1bGZpbGxXaXRoTWV0YVxyXG4gIGRvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWVcclxuICAqL1xyXG4gIF90eXBlO1xyXG59O1xyXG52YXIgRnVsZmlsbFdpdGhNZXRhID0gY2xhc3Mge1xyXG4gIGNvbnN0cnVjdG9yKHBheWxvYWQsIG1ldGEpIHtcclxuICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XHJcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xyXG4gIH1cclxuICAvKlxyXG4gIHR5cGUtb25seSBwcm9wZXJ0eSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIFJlamVjdFdpdGhWYWx1ZSBhbmQgRnVsZmlsbFdpdGhNZXRhXHJcbiAgZG9lcyBub3QgZXhpc3QgYXQgcnVudGltZVxyXG4gICovXHJcbiAgX3R5cGU7XHJcbn07XHJcbnZhciBtaW5pU2VyaWFsaXplRXJyb3IgPSAodmFsdWUpID0+IHtcclxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XHJcbiAgICBjb25zdCBzaW1wbGVFcnJvciA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBjb21tb25Qcm9wZXJ0aWVzKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVbcHJvcGVydHldID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgc2ltcGxlRXJyb3JbcHJvcGVydHldID0gdmFsdWVbcHJvcGVydHldO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2ltcGxlRXJyb3I7XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICBtZXNzYWdlOiBTdHJpbmcodmFsdWUpXHJcbiAgfTtcclxufTtcclxudmFyIGV4dGVybmFsQWJvcnRNZXNzYWdlID0gXCJFeHRlcm5hbCBzaWduYWwgd2FzIGFib3J0ZWRcIjtcclxudmFyIGNyZWF0ZUFzeW5jVGh1bmsgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcclxuICBmdW5jdGlvbiBjcmVhdGVBc3luY1RodW5rMih0eXBlUHJlZml4LCBwYXlsb2FkQ3JlYXRvciwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgZnVsZmlsbGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9mdWxmaWxsZWRcIiwgKHBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCBtZXRhKSA9PiAoe1xyXG4gICAgICBwYXlsb2FkLFxyXG4gICAgICBtZXRhOiB7XHJcbiAgICAgICAgLi4ubWV0YSB8fCB7fSxcclxuICAgICAgICBhcmcsXHJcbiAgICAgICAgcmVxdWVzdElkLFxyXG4gICAgICAgIHJlcXVlc3RTdGF0dXM6IFwiZnVsZmlsbGVkXCJcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG4gICAgY29uc3QgcGVuZGluZyA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcGVuZGluZ1wiLCAocmVxdWVzdElkLCBhcmcsIG1ldGEpID0+ICh7XHJcbiAgICAgIHBheWxvYWQ6IHZvaWQgMCxcclxuICAgICAgbWV0YToge1xyXG4gICAgICAgIC4uLm1ldGEgfHwge30sXHJcbiAgICAgICAgYXJnLFxyXG4gICAgICAgIHJlcXVlc3RJZCxcclxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcInBlbmRpbmdcIlxyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcbiAgICBjb25zdCByZWplY3RlZCA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcmVqZWN0ZWRcIiwgKGVycm9yLCByZXF1ZXN0SWQsIGFyZywgcGF5bG9hZCwgbWV0YSkgPT4gKHtcclxuICAgICAgcGF5bG9hZCxcclxuICAgICAgZXJyb3I6IChvcHRpb25zICYmIG9wdGlvbnMuc2VyaWFsaXplRXJyb3IgfHwgbWluaVNlcmlhbGl6ZUVycm9yKShlcnJvciB8fCBcIlJlamVjdGVkXCIpLFxyXG4gICAgICBtZXRhOiB7XHJcbiAgICAgICAgLi4ubWV0YSB8fCB7fSxcclxuICAgICAgICBhcmcsXHJcbiAgICAgICAgcmVxdWVzdElkLFxyXG4gICAgICAgIHJlamVjdGVkV2l0aFZhbHVlOiAhIXBheWxvYWQsXHJcbiAgICAgICAgcmVxdWVzdFN0YXR1czogXCJyZWplY3RlZFwiLFxyXG4gICAgICAgIGFib3J0ZWQ6IGVycm9yPy5uYW1lID09PSBcIkFib3J0RXJyb3JcIixcclxuICAgICAgICBjb25kaXRpb246IGVycm9yPy5uYW1lID09PSBcIkNvbmRpdGlvbkVycm9yXCJcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG4gICAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvcihhcmcsIHtcclxuICAgICAgc2lnbmFsXHJcbiAgICB9ID0ge30pIHtcclxuICAgICAgcmV0dXJuIChkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gb3B0aW9ucz8uaWRHZW5lcmF0b3IgPyBvcHRpb25zLmlkR2VuZXJhdG9yKGFyZykgOiBuYW5vaWQoKTtcclxuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XHJcbiAgICAgICAgbGV0IGFib3J0SGFuZGxlcjtcclxuICAgICAgICBsZXQgYWJvcnRSZWFzb247XHJcbiAgICAgICAgZnVuY3Rpb24gYWJvcnQocmVhc29uKSB7XHJcbiAgICAgICAgICBhYm9ydFJlYXNvbiA9IHJlYXNvbjtcclxuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2lnbmFsKSB7XHJcbiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgICAgICAgYWJvcnQoZXh0ZXJuYWxBYm9ydE1lc3NhZ2UpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiBhYm9ydChleHRlcm5hbEFib3J0TWVzc2FnZSksIHtcclxuICAgICAgICAgICAgICBvbmNlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcm9taXNlID0gYXN5bmMgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBsZXQgZmluYWxBY3Rpb247XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBsZXQgY29uZGl0aW9uUmVzdWx0ID0gb3B0aW9ucz8uY29uZGl0aW9uPy4oYXJnLCB7XHJcbiAgICAgICAgICAgICAgZ2V0U3RhdGUsXHJcbiAgICAgICAgICAgICAgZXh0cmFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChpc1RoZW5hYmxlKGNvbmRpdGlvblJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICBjb25kaXRpb25SZXN1bHQgPSBhd2FpdCBjb25kaXRpb25SZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbmRpdGlvblJlc3VsdCA9PT0gZmFsc2UgfHwgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogXCJDb25kaXRpb25FcnJvclwiLFxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBYm9ydGVkIGR1ZSB0byBjb25kaXRpb24gY2FsbGJhY2sgcmV0dXJuaW5nIGZhbHNlLlwiXHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBhYm9ydGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICBhYm9ydEhhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIkFib3J0RXJyb3JcIixcclxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYWJvcnRSZWFzb24gfHwgXCJBYm9ydGVkXCJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRIYW5kbGVyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoKHBlbmRpbmcocmVxdWVzdElkLCBhcmcsIG9wdGlvbnM/LmdldFBlbmRpbmdNZXRhPy4oe1xyXG4gICAgICAgICAgICAgIHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgICBhcmdcclxuICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgIGdldFN0YXRlLFxyXG4gICAgICAgICAgICAgIGV4dHJhXHJcbiAgICAgICAgICAgIH0pKSk7XHJcbiAgICAgICAgICAgIGZpbmFsQWN0aW9uID0gYXdhaXQgUHJvbWlzZS5yYWNlKFthYm9ydGVkUHJvbWlzZSwgUHJvbWlzZS5yZXNvbHZlKHBheWxvYWRDcmVhdG9yKGFyZywge1xyXG4gICAgICAgICAgICAgIGRpc3BhdGNoLFxyXG4gICAgICAgICAgICAgIGdldFN0YXRlLFxyXG4gICAgICAgICAgICAgIGV4dHJhLFxyXG4gICAgICAgICAgICAgIHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXHJcbiAgICAgICAgICAgICAgYWJvcnQsXHJcbiAgICAgICAgICAgICAgcmVqZWN0V2l0aFZhbHVlOiAodmFsdWUsIG1ldGEpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVqZWN0V2l0aFZhbHVlKHZhbHVlLCBtZXRhKTtcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIGZ1bGZpbGxXaXRoVmFsdWU6ICh2YWx1ZSwgbWV0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdWxmaWxsV2l0aE1ldGEodmFsdWUsIG1ldGEpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IHJlc3VsdDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZ1bGZpbGxXaXRoTWV0YSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZChyZXN1bHQucGF5bG9hZCwgcmVxdWVzdElkLCBhcmcsIHJlc3VsdC5tZXRhKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZChyZXN1bHQsIHJlcXVlc3RJZCwgYXJnKTtcclxuICAgICAgICAgICAgfSldKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGVyciBpbnN0YW5jZW9mIFJlamVjdFdpdGhWYWx1ZSA/IHJlamVjdGVkKG51bGwsIHJlcXVlc3RJZCwgYXJnLCBlcnIucGF5bG9hZCwgZXJyLm1ldGEpIDogcmVqZWN0ZWQoZXJyLCByZXF1ZXN0SWQsIGFyZyk7XHJcbiAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICBpZiAoYWJvcnRIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRIYW5kbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29uc3Qgc2tpcERpc3BhdGNoID0gb3B0aW9ucyAmJiAhb3B0aW9ucy5kaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbiAmJiByZWplY3RlZC5tYXRjaChmaW5hbEFjdGlvbikgJiYgZmluYWxBY3Rpb24ubWV0YS5jb25kaXRpb247XHJcbiAgICAgICAgICBpZiAoIXNraXBEaXNwYXRjaCkge1xyXG4gICAgICAgICAgICBkaXNwYXRjaChmaW5hbEFjdGlvbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gZmluYWxBY3Rpb247XHJcbiAgICAgICAgfSgpO1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHByb21pc2UsIHtcclxuICAgICAgICAgIGFib3J0LFxyXG4gICAgICAgICAgcmVxdWVzdElkLFxyXG4gICAgICAgICAgYXJnLFxyXG4gICAgICAgICAgdW53cmFwKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKHVud3JhcFJlc3VsdCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY3Rpb25DcmVhdG9yLCB7XHJcbiAgICAgIHBlbmRpbmcsXHJcbiAgICAgIHJlamVjdGVkLFxyXG4gICAgICBmdWxmaWxsZWQsXHJcbiAgICAgIHNldHRsZWQ6IGlzQW55T2YocmVqZWN0ZWQsIGZ1bGZpbGxlZCksXHJcbiAgICAgIHR5cGVQcmVmaXhcclxuICAgIH0pO1xyXG4gIH1cclxuICBjcmVhdGVBc3luY1RodW5rMi53aXRoVHlwZXMgPSAoKSA9PiBjcmVhdGVBc3luY1RodW5rMjtcclxuICByZXR1cm4gY3JlYXRlQXN5bmNUaHVuazI7XHJcbn0pKCk7XHJcbmZ1bmN0aW9uIHVud3JhcFJlc3VsdChhY3Rpb24pIHtcclxuICBpZiAoYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWUpIHtcclxuICAgIHRocm93IGFjdGlvbi5wYXlsb2FkO1xyXG4gIH1cclxuICBpZiAoYWN0aW9uLmVycm9yKSB7XHJcbiAgICB0aHJvdyBhY3Rpb24uZXJyb3I7XHJcbiAgfVxyXG4gIHJldHVybiBhY3Rpb24ucGF5bG9hZDtcclxufVxyXG5mdW5jdGlvbiBpc1RoZW5hYmxlKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xyXG59XHJcblxyXG4vLyBzcmMvY3JlYXRlU2xpY2UudHNcclxudmFyIGFzeW5jVGh1bmtTeW1ib2wgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJ0ay1zbGljZS1jcmVhdGVhc3luY3RodW5rXCIpO1xyXG52YXIgYXN5bmNUaHVua0NyZWF0b3IgPSB7XHJcbiAgW2FzeW5jVGh1bmtTeW1ib2xdOiBjcmVhdGVBc3luY1RodW5rXHJcbn07XHJcbnZhciBSZWR1Y2VyVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFJlZHVjZXJUeXBlMikgPT4ge1xyXG4gIFJlZHVjZXJUeXBlMltcInJlZHVjZXJcIl0gPSBcInJlZHVjZXJcIjtcclxuICBSZWR1Y2VyVHlwZTJbXCJyZWR1Y2VyV2l0aFByZXBhcmVcIl0gPSBcInJlZHVjZXJXaXRoUHJlcGFyZVwiO1xyXG4gIFJlZHVjZXJUeXBlMltcImFzeW5jVGh1bmtcIl0gPSBcImFzeW5jVGh1bmtcIjtcclxuICByZXR1cm4gUmVkdWNlclR5cGUyO1xyXG59KShSZWR1Y2VyVHlwZSB8fCB7fSk7XHJcbmZ1bmN0aW9uIGdldFR5cGUoc2xpY2UsIGFjdGlvbktleSkge1xyXG4gIHJldHVybiBgJHtzbGljZX0vJHthY3Rpb25LZXl9YDtcclxufVxyXG5mdW5jdGlvbiBidWlsZENyZWF0ZVNsaWNlKHtcclxuICBjcmVhdG9yc1xyXG59ID0ge30pIHtcclxuICBjb25zdCBjQVQgPSBjcmVhdG9ycz8uYXN5bmNUaHVuaz8uW2FzeW5jVGh1bmtTeW1ib2xdO1xyXG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVTbGljZTIob3B0aW9ucykge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBuYW1lLFxyXG4gICAgICByZWR1Y2VyUGF0aCA9IG5hbWVcclxuICAgIH0gPSBvcHRpb25zO1xyXG4gICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDExKSA6IFwiYG5hbWVgIGlzIGEgcmVxdWlyZWQgb3B0aW9uIGZvciBjcmVhdGVTbGljZVwiKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XHJcbiAgICAgIGlmIChvcHRpb25zLmluaXRpYWxTdGF0ZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIllvdSBtdXN0IHByb3ZpZGUgYW4gYGluaXRpYWxTdGF0ZWAgdmFsdWUgdGhhdCBpcyBub3QgYHVuZGVmaW5lZGAuIFlvdSBtYXkgaGF2ZSBtaXNzcGVsbGVkIGBpbml0aWFsU3RhdGVgXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCByZWR1Y2VycyA9ICh0eXBlb2Ygb3B0aW9ucy5yZWR1Y2VycyA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5yZWR1Y2VycyhidWlsZFJlZHVjZXJDcmVhdG9ycygpKSA6IG9wdGlvbnMucmVkdWNlcnMpIHx8IHt9O1xyXG4gICAgY29uc3QgcmVkdWNlck5hbWVzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xyXG4gICAgY29uc3QgY29udGV4dCA9IHtcclxuICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWU6IHt9LFxyXG4gICAgICBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZToge30sXHJcbiAgICAgIGFjdGlvbkNyZWF0b3JzOiB7fSxcclxuICAgICAgc2xpY2VNYXRjaGVyczogW11cclxuICAgIH07XHJcbiAgICBjb25zdCBjb250ZXh0TWV0aG9kcyA9IHtcclxuICAgICAgYWRkQ2FzZSh0eXBlT3JBY3Rpb25DcmVhdG9yLCByZWR1Y2VyMikge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XHJcbiAgICAgICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMikgOiBcImBjb250ZXh0LmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBhbiBlbXB0eSBhY3Rpb24gdHlwZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgaW4gY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTMpIDogXCJgY29udGV4dC5hZGRDYXNlYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggdHdvIHJlZHVjZXJzIGZvciB0aGUgc2FtZSBhY3Rpb24gdHlwZTogXCIgKyB0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZVt0eXBlXSA9IHJlZHVjZXIyO1xyXG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcclxuICAgICAgfSxcclxuICAgICAgYWRkTWF0Y2hlcihtYXRjaGVyLCByZWR1Y2VyMikge1xyXG4gICAgICAgIGNvbnRleHQuc2xpY2VNYXRjaGVycy5wdXNoKHtcclxuICAgICAgICAgIG1hdGNoZXIsXHJcbiAgICAgICAgICByZWR1Y2VyOiByZWR1Y2VyMlxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcclxuICAgICAgfSxcclxuICAgICAgZXhwb3NlQWN0aW9uKG5hbWUyLCBhY3Rpb25DcmVhdG9yKSB7XHJcbiAgICAgICAgY29udGV4dC5hY3Rpb25DcmVhdG9yc1tuYW1lMl0gPSBhY3Rpb25DcmVhdG9yO1xyXG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcclxuICAgICAgfSxcclxuICAgICAgZXhwb3NlQ2FzZVJlZHVjZXIobmFtZTIsIHJlZHVjZXIyKSB7XHJcbiAgICAgICAgY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZVtuYW1lMl0gPSByZWR1Y2VyMjtcclxuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICByZWR1Y2VyTmFtZXMuZm9yRWFjaCgocmVkdWNlck5hbWUpID0+IHtcclxuICAgICAgY29uc3QgcmVkdWNlckRlZmluaXRpb24gPSByZWR1Y2Vyc1tyZWR1Y2VyTmFtZV07XHJcbiAgICAgIGNvbnN0IHJlZHVjZXJEZXRhaWxzID0ge1xyXG4gICAgICAgIHJlZHVjZXJOYW1lLFxyXG4gICAgICAgIHR5cGU6IGdldFR5cGUobmFtZSwgcmVkdWNlck5hbWUpLFxyXG4gICAgICAgIGNyZWF0ZU5vdGF0aW9uOiB0eXBlb2Ygb3B0aW9ucy5yZWR1Y2VycyA9PT0gXCJmdW5jdGlvblwiXHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChpc0FzeW5jVGh1bmtTbGljZVJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSkge1xyXG4gICAgICAgIGhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZXRhaWxzLCByZWR1Y2VyRGVmaW5pdGlvbiwgY29udGV4dE1ldGhvZHMsIGNBVCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaGFuZGxlTm9ybWFsUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRldGFpbHMsIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0TWV0aG9kcyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgZnVuY3Rpb24gYnVpbGRSZWR1Y2VyKCkge1xyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE0KSA6IFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVNsaWNlLmV4dHJhUmVkdWNlcnNgIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgdGhlICdidWlsZGVyIGNhbGxiYWNrJyBub3RhdGlvbiBpbnN0ZWFkOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9jcmVhdGVTbGljZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgW2V4dHJhUmVkdWNlcnMgPSB7fSwgYWN0aW9uTWF0Y2hlcnMgPSBbXSwgZGVmYXVsdENhc2VSZWR1Y2VyID0gdm9pZCAwXSA9IHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwiZnVuY3Rpb25cIiA/IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG9wdGlvbnMuZXh0cmFSZWR1Y2VycykgOiBbb3B0aW9ucy5leHRyYVJlZHVjZXJzXTtcclxuICAgICAgY29uc3QgZmluYWxDYXNlUmVkdWNlcnMgPSB7XHJcbiAgICAgICAgLi4uZXh0cmFSZWR1Y2VycyxcclxuICAgICAgICAuLi5jb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBjcmVhdGVSZWR1Y2VyKG9wdGlvbnMuaW5pdGlhbFN0YXRlLCAoYnVpbGRlcikgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBmaW5hbENhc2VSZWR1Y2Vycykge1xyXG4gICAgICAgICAgYnVpbGRlci5hZGRDYXNlKGtleSwgZmluYWxDYXNlUmVkdWNlcnNba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IHNNIG9mIGNvbnRleHQuc2xpY2VNYXRjaGVycykge1xyXG4gICAgICAgICAgYnVpbGRlci5hZGRNYXRjaGVyKHNNLm1hdGNoZXIsIHNNLnJlZHVjZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBtIG9mIGFjdGlvbk1hdGNoZXJzKSB7XHJcbiAgICAgICAgICBidWlsZGVyLmFkZE1hdGNoZXIobS5tYXRjaGVyLCBtLnJlZHVjZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICBidWlsZGVyLmFkZERlZmF1bHRDYXNlKGRlZmF1bHRDYXNlUmVkdWNlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGNvbnN0IHNlbGVjdFNlbGYgPSAoc3RhdGUpID0+IHN0YXRlO1xyXG4gICAgY29uc3QgaW5qZWN0ZWRTZWxlY3RvckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcclxuICAgIGNvbnN0IGluamVjdGVkU3RhdGVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xyXG4gICAgbGV0IF9yZWR1Y2VyO1xyXG4gICAgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XHJcbiAgICAgIGlmICghX3JlZHVjZXIpIF9yZWR1Y2VyID0gYnVpbGRSZWR1Y2VyKCk7XHJcbiAgICAgIHJldHVybiBfcmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcclxuICAgICAgaWYgKCFfcmVkdWNlcikgX3JlZHVjZXIgPSBidWlsZFJlZHVjZXIoKTtcclxuICAgICAgcmV0dXJuIF9yZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbWFrZVNlbGVjdG9yUHJvcHMocmVkdWNlclBhdGgyLCBpbmplY3RlZCA9IGZhbHNlKSB7XHJcbiAgICAgIGZ1bmN0aW9uIHNlbGVjdFNsaWNlKHN0YXRlKSB7XHJcbiAgICAgICAgbGV0IHNsaWNlU3RhdGUgPSBzdGF0ZVtyZWR1Y2VyUGF0aDJdO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2xpY2VTdGF0ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgaWYgKGluamVjdGVkKSB7XHJcbiAgICAgICAgICAgIHNsaWNlU3RhdGUgPSBnZXRPckluc2VydENvbXB1dGVkKGluamVjdGVkU3RhdGVDYWNoZSwgc2VsZWN0U2xpY2UsIGdldEluaXRpYWxTdGF0ZSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNSkgOiBcInNlbGVjdFNsaWNlIHJldHVybmVkIHVuZGVmaW5lZCBmb3IgYW4gdW5pbmplY3RlZCBzbGljZSByZWR1Y2VyXCIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2xpY2VTdGF0ZTtcclxuICAgICAgfVxyXG4gICAgICBmdW5jdGlvbiBnZXRTZWxlY3RvcnMoc2VsZWN0U3RhdGUgPSBzZWxlY3RTZWxmKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0b3JDYWNoZSA9IGdldE9ySW5zZXJ0Q29tcHV0ZWQoaW5qZWN0ZWRTZWxlY3RvckNhY2hlLCBpbmplY3RlZCwgKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xyXG4gICAgICAgIHJldHVybiBnZXRPckluc2VydENvbXB1dGVkKHNlbGVjdG9yQ2FjaGUsIHNlbGVjdFN0YXRlLCAoKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBtYXAgPSB7fTtcclxuICAgICAgICAgIGZvciAoY29uc3QgW25hbWUyLCBzZWxlY3Rvcl0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5zZWxlY3RvcnMgPz8ge30pKSB7XHJcbiAgICAgICAgICAgIG1hcFtuYW1lMl0gPSB3cmFwU2VsZWN0b3Ioc2VsZWN0b3IsIHNlbGVjdFN0YXRlLCAoKSA9PiBnZXRPckluc2VydENvbXB1dGVkKGluamVjdGVkU3RhdGVDYWNoZSwgc2VsZWN0U3RhdGUsIGdldEluaXRpYWxTdGF0ZSksIGluamVjdGVkKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBtYXA7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICByZWR1Y2VyUGF0aDogcmVkdWNlclBhdGgyLFxyXG4gICAgICAgIGdldFNlbGVjdG9ycyxcclxuICAgICAgICBnZXQgc2VsZWN0b3JzKCkge1xyXG4gICAgICAgICAgcmV0dXJuIGdldFNlbGVjdG9ycyhzZWxlY3RTbGljZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZWxlY3RTbGljZVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2xpY2UgPSB7XHJcbiAgICAgIG5hbWUsXHJcbiAgICAgIHJlZHVjZXIsXHJcbiAgICAgIGFjdGlvbnM6IGNvbnRleHQuYWN0aW9uQ3JlYXRvcnMsXHJcbiAgICAgIGNhc2VSZWR1Y2VyczogY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZSxcclxuICAgICAgZ2V0SW5pdGlhbFN0YXRlLFxyXG4gICAgICAuLi5tYWtlU2VsZWN0b3JQcm9wcyhyZWR1Y2VyUGF0aCksXHJcbiAgICAgIGluamVjdEludG8oaW5qZWN0YWJsZSwge1xyXG4gICAgICAgIHJlZHVjZXJQYXRoOiBwYXRoT3B0LFxyXG4gICAgICAgIC4uLmNvbmZpZ1xyXG4gICAgICB9ID0ge30pIHtcclxuICAgICAgICBjb25zdCBuZXdSZWR1Y2VyUGF0aCA9IHBhdGhPcHQgPz8gcmVkdWNlclBhdGg7XHJcbiAgICAgICAgaW5qZWN0YWJsZS5pbmplY3Qoe1xyXG4gICAgICAgICAgcmVkdWNlclBhdGg6IG5ld1JlZHVjZXJQYXRoLFxyXG4gICAgICAgICAgcmVkdWNlclxyXG4gICAgICAgIH0sIGNvbmZpZyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIC4uLnNsaWNlLFxyXG4gICAgICAgICAgLi4ubWFrZVNlbGVjdG9yUHJvcHMobmV3UmVkdWNlclBhdGgsIHRydWUpXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBzbGljZTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHdyYXBTZWxlY3RvcihzZWxlY3Rvciwgc2VsZWN0U3RhdGUsIGdldEluaXRpYWxTdGF0ZSwgaW5qZWN0ZWQpIHtcclxuICBmdW5jdGlvbiB3cmFwcGVyKHJvb3RTdGF0ZSwgLi4uYXJncykge1xyXG4gICAgbGV0IHNsaWNlU3RhdGUgPSBzZWxlY3RTdGF0ZShyb290U3RhdGUpO1xyXG4gICAgaWYgKHR5cGVvZiBzbGljZVN0YXRlID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgIGlmIChpbmplY3RlZCkge1xyXG4gICAgICAgIHNsaWNlU3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKTtcclxuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNikgOiBcInNlbGVjdFN0YXRlIHJldHVybmVkIHVuZGVmaW5lZCBmb3IgYW4gdW5pbmplY3RlZCBzbGljZSByZWR1Y2VyXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2VsZWN0b3Ioc2xpY2VTdGF0ZSwgLi4uYXJncyk7XHJcbiAgfVxyXG4gIHdyYXBwZXIudW53cmFwcGVkID0gc2VsZWN0b3I7XHJcbiAgcmV0dXJuIHdyYXBwZXI7XHJcbn1cclxudmFyIGNyZWF0ZVNsaWNlID0gLyogQF9fUFVSRV9fICovIGJ1aWxkQ3JlYXRlU2xpY2UoKTtcclxuZnVuY3Rpb24gYnVpbGRSZWR1Y2VyQ3JlYXRvcnMoKSB7XHJcbiAgZnVuY3Rpb24gYXN5bmNUaHVuayhwYXlsb2FkQ3JlYXRvciwgY29uZmlnKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcImFzeW5jVGh1bmtcIiAvKiBhc3luY1RodW5rICovLFxyXG4gICAgICBwYXlsb2FkQ3JlYXRvcixcclxuICAgICAgLi4uY29uZmlnXHJcbiAgICB9O1xyXG4gIH1cclxuICBhc3luY1RodW5rLndpdGhUeXBlcyA9ICgpID0+IGFzeW5jVGh1bms7XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlZHVjZXIoY2FzZVJlZHVjZXIpIHtcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICAgIC8vIGhhY2sgc28gdGhlIHdyYXBwaW5nIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBuYW1lIGFzIHRoZSBvcmlnaW5hbFxyXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY3JlYXRlIGEgd3JhcHBlciBzbyB0aGUgYHJlZHVjZXJEZWZpbml0aW9uVHlwZWAgaXMgbm90IGFzc2lnbmVkIHRvIHRoZSBvcmlnaW5hbFxyXG4gICAgICAgIFtjYXNlUmVkdWNlci5uYW1lXSguLi5hcmdzKSB7XHJcbiAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoLi4uYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9W2Nhc2VSZWR1Y2VyLm5hbWVdLCB7XHJcbiAgICAgICAgX3JlZHVjZXJEZWZpbml0aW9uVHlwZTogXCJyZWR1Y2VyXCIgLyogcmVkdWNlciAqL1xyXG4gICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBwcmVwYXJlZFJlZHVjZXIocHJlcGFyZSwgcmVkdWNlcikge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIF9yZWR1Y2VyRGVmaW5pdGlvblR5cGU6IFwicmVkdWNlcldpdGhQcmVwYXJlXCIgLyogcmVkdWNlcldpdGhQcmVwYXJlICovLFxyXG4gICAgICAgIHByZXBhcmUsXHJcbiAgICAgICAgcmVkdWNlclxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICAgIGFzeW5jVGh1bmtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZU5vcm1hbFJlZHVjZXJEZWZpbml0aW9uKHtcclxuICB0eXBlLFxyXG4gIHJlZHVjZXJOYW1lLFxyXG4gIGNyZWF0ZU5vdGF0aW9uXHJcbn0sIG1heWJlUmVkdWNlcldpdGhQcmVwYXJlLCBjb250ZXh0KSB7XHJcbiAgbGV0IGNhc2VSZWR1Y2VyO1xyXG4gIGxldCBwcmVwYXJlQ2FsbGJhY2s7XHJcbiAgaWYgKFwicmVkdWNlclwiIGluIG1heWJlUmVkdWNlcldpdGhQcmVwYXJlKSB7XHJcbiAgICBpZiAoY3JlYXRlTm90YXRpb24gJiYgIWlzQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZURlZmluaXRpb24obWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE3KSA6IFwiUGxlYXNlIHVzZSB0aGUgYGNyZWF0ZS5wcmVwYXJlZFJlZHVjZXJgIG5vdGF0aW9uIGZvciBwcmVwYXJlZCBhY3Rpb24gY3JlYXRvcnMgd2l0aCB0aGUgYGNyZWF0ZWAgbm90YXRpb24uXCIpO1xyXG4gICAgfVxyXG4gICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZS5yZWR1Y2VyO1xyXG4gICAgcHJlcGFyZUNhbGxiYWNrID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucHJlcGFyZTtcclxuICB9IGVsc2Uge1xyXG4gICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZTtcclxuICB9XHJcbiAgY29udGV4dC5hZGRDYXNlKHR5cGUsIGNhc2VSZWR1Y2VyKS5leHBvc2VDYXNlUmVkdWNlcihyZWR1Y2VyTmFtZSwgY2FzZVJlZHVjZXIpLmV4cG9zZUFjdGlvbihyZWR1Y2VyTmFtZSwgcHJlcGFyZUNhbGxiYWNrID8gY3JlYXRlQWN0aW9uKHR5cGUsIHByZXBhcmVDYWxsYmFjaykgOiBjcmVhdGVBY3Rpb24odHlwZSkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRlZmluaXRpb24pIHtcclxuICByZXR1cm4gcmVkdWNlckRlZmluaXRpb24uX3JlZHVjZXJEZWZpbml0aW9uVHlwZSA9PT0gXCJhc3luY1RodW5rXCIgLyogYXN5bmNUaHVuayAqLztcclxufVxyXG5mdW5jdGlvbiBpc0Nhc2VSZWR1Y2VyV2l0aFByZXBhcmVEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSB7XHJcbiAgcmV0dXJuIHJlZHVjZXJEZWZpbml0aW9uLl9yZWR1Y2VyRGVmaW5pdGlvblR5cGUgPT09IFwicmVkdWNlcldpdGhQcmVwYXJlXCIgLyogcmVkdWNlcldpdGhQcmVwYXJlICovO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uKHtcclxuICB0eXBlLFxyXG4gIHJlZHVjZXJOYW1lXHJcbn0sIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0LCBjQVQpIHtcclxuICBpZiAoIWNBVCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTgpIDogXCJDYW5ub3QgdXNlIGBjcmVhdGUuYXN5bmNUaHVua2AgaW4gdGhlIGJ1aWx0LWluIGBjcmVhdGVTbGljZWAuIFVzZSBgYnVpbGRDcmVhdGVTbGljZSh7IGNyZWF0b3JzOiB7IGFzeW5jVGh1bms6IGFzeW5jVGh1bmtDcmVhdG9yIH0gfSlgIHRvIGNyZWF0ZSBhIGN1c3RvbWlzZWQgdmVyc2lvbiBvZiBgY3JlYXRlU2xpY2VgLlwiKTtcclxuICB9XHJcbiAgY29uc3Qge1xyXG4gICAgcGF5bG9hZENyZWF0b3IsXHJcbiAgICBmdWxmaWxsZWQsXHJcbiAgICBwZW5kaW5nLFxyXG4gICAgcmVqZWN0ZWQsXHJcbiAgICBzZXR0bGVkLFxyXG4gICAgb3B0aW9uc1xyXG4gIH0gPSByZWR1Y2VyRGVmaW5pdGlvbjtcclxuICBjb25zdCB0aHVuayA9IGNBVCh0eXBlLCBwYXlsb2FkQ3JlYXRvciwgb3B0aW9ucyk7XHJcbiAgY29udGV4dC5leHBvc2VBY3Rpb24ocmVkdWNlck5hbWUsIHRodW5rKTtcclxuICBpZiAoZnVsZmlsbGVkKSB7XHJcbiAgICBjb250ZXh0LmFkZENhc2UodGh1bmsuZnVsZmlsbGVkLCBmdWxmaWxsZWQpO1xyXG4gIH1cclxuICBpZiAocGVuZGluZykge1xyXG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLnBlbmRpbmcsIHBlbmRpbmcpO1xyXG4gIH1cclxuICBpZiAocmVqZWN0ZWQpIHtcclxuICAgIGNvbnRleHQuYWRkQ2FzZSh0aHVuay5yZWplY3RlZCwgcmVqZWN0ZWQpO1xyXG4gIH1cclxuICBpZiAoc2V0dGxlZCkge1xyXG4gICAgY29udGV4dC5hZGRNYXRjaGVyKHRodW5rLnNldHRsZWQsIHNldHRsZWQpO1xyXG4gIH1cclxuICBjb250ZXh0LmV4cG9zZUNhc2VSZWR1Y2VyKHJlZHVjZXJOYW1lLCB7XHJcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCB8fCBub29wLFxyXG4gICAgcGVuZGluZzogcGVuZGluZyB8fCBub29wLFxyXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkIHx8IG5vb3AsXHJcbiAgICBzZXR0bGVkOiBzZXR0bGVkIHx8IG5vb3BcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBub29wKCkge1xyXG59XHJcblxyXG4vLyBzcmMvZW50aXRpZXMvZW50aXR5X3N0YXRlLnRzXHJcbmZ1bmN0aW9uIGdldEluaXRpYWxFbnRpdHlTdGF0ZSgpIHtcclxuICByZXR1cm4ge1xyXG4gICAgaWRzOiBbXSxcclxuICAgIGVudGl0aWVzOiB7fVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeShzdGF0ZUFkYXB0ZXIpIHtcclxuICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoYWRkaXRpb25hbFN0YXRlID0ge30sIGVudGl0aWVzKSB7XHJcbiAgICBjb25zdCBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCksIGFkZGl0aW9uYWxTdGF0ZSk7XHJcbiAgICByZXR1cm4gZW50aXRpZXMgPyBzdGF0ZUFkYXB0ZXIuc2V0QWxsKHN0YXRlLCBlbnRpdGllcykgOiBzdGF0ZTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIGdldEluaXRpYWxTdGF0ZVxyXG4gIH07XHJcbn1cclxuXHJcbi8vIHNyYy9lbnRpdGllcy9zdGF0ZV9zZWxlY3RvcnMudHNcclxuZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSgpIHtcclxuICBmdW5jdGlvbiBnZXRTZWxlY3RvcnMoc2VsZWN0U3RhdGUsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBjcmVhdGVTZWxlY3RvcjogY3JlYXRlU2VsZWN0b3IyID0gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JcclxuICAgIH0gPSBvcHRpb25zO1xyXG4gICAgY29uc3Qgc2VsZWN0SWRzID0gKHN0YXRlKSA9PiBzdGF0ZS5pZHM7XHJcbiAgICBjb25zdCBzZWxlY3RFbnRpdGllcyA9IChzdGF0ZSkgPT4gc3RhdGUuZW50aXRpZXM7XHJcbiAgICBjb25zdCBzZWxlY3RBbGwgPSBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0SWRzLCBzZWxlY3RFbnRpdGllcywgKGlkcywgZW50aXRpZXMpID0+IGlkcy5tYXAoKGlkKSA9PiBlbnRpdGllc1tpZF0pKTtcclxuICAgIGNvbnN0IHNlbGVjdElkID0gKF8sIGlkKSA9PiBpZDtcclxuICAgIGNvbnN0IHNlbGVjdEJ5SWQgPSAoZW50aXRpZXMsIGlkKSA9PiBlbnRpdGllc1tpZF07XHJcbiAgICBjb25zdCBzZWxlY3RUb3RhbCA9IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RJZHMsIChpZHMpID0+IGlkcy5sZW5ndGgpO1xyXG4gICAgaWYgKCFzZWxlY3RTdGF0ZSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHNlbGVjdElkcyxcclxuICAgICAgICBzZWxlY3RFbnRpdGllcyxcclxuICAgICAgICBzZWxlY3RBbGwsXHJcbiAgICAgICAgc2VsZWN0VG90YWwsXHJcbiAgICAgICAgc2VsZWN0QnlJZDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdEVudGl0aWVzLCBzZWxlY3RJZCwgc2VsZWN0QnlJZClcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyA9IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0RW50aXRpZXMpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc2VsZWN0SWRzOiBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0U3RhdGUsIHNlbGVjdElkcyksXHJcbiAgICAgIHNlbGVjdEVudGl0aWVzOiBzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsXHJcbiAgICAgIHNlbGVjdEFsbDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RBbGwpLFxyXG4gICAgICBzZWxlY3RUb3RhbDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RUb3RhbCksXHJcbiAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIGdldFNlbGVjdG9yc1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIHNyYy9lbnRpdGllcy9zdGF0ZV9hZGFwdGVyLnRzXHJcbmltcG9ydCB7IHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlMywgaXNEcmFmdCBhcyBpc0RyYWZ0MyB9IGZyb20gXCJpbW1lclwiO1xyXG52YXIgaXNEcmFmdFR5cGVkID0gaXNEcmFmdDM7XHJcbmZ1bmN0aW9uIGNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvcihtdXRhdG9yKSB7XHJcbiAgY29uc3Qgb3BlcmF0b3IgPSBjcmVhdGVTdGF0ZU9wZXJhdG9yKChfLCBzdGF0ZSkgPT4gbXV0YXRvcihzdGF0ZSkpO1xyXG4gIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUpIHtcclxuICAgIHJldHVybiBvcGVyYXRvcihzdGF0ZSwgdm9pZCAwKTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xyXG4gIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUsIGFyZykge1xyXG4gICAgZnVuY3Rpb24gaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnMikge1xyXG4gICAgICByZXR1cm4gaXNGU0EoYXJnMik7XHJcbiAgICB9XHJcbiAgICBjb25zdCBydW5NdXRhdG9yID0gKGRyYWZ0KSA9PiB7XHJcbiAgICAgIGlmIChpc1BheWxvYWRBY3Rpb25Bcmd1bWVudChhcmcpKSB7XHJcbiAgICAgICAgbXV0YXRvcihhcmcucGF5bG9hZCwgZHJhZnQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG11dGF0b3IoYXJnLCBkcmFmdCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBpZiAoaXNEcmFmdFR5cGVkKHN0YXRlKSkge1xyXG4gICAgICBydW5NdXRhdG9yKHN0YXRlKTtcclxuICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZTMoc3RhdGUsIHJ1bk11dGF0b3IpO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIHNyYy9lbnRpdGllcy91dGlscy50c1xyXG5pbXBvcnQgeyBjdXJyZW50IGFzIGN1cnJlbnQyLCBpc0RyYWZ0IGFzIGlzRHJhZnQ0IH0gZnJvbSBcImltbWVyXCI7XHJcbmZ1bmN0aW9uIHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCkge1xyXG4gIGNvbnN0IGtleSA9IHNlbGVjdElkKGVudGl0eSk7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBrZXkgPT09IHZvaWQgMCkge1xyXG4gICAgY29uc29sZS53YXJuKFwiVGhlIGVudGl0eSBwYXNzZWQgdG8gdGhlIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgdW5kZWZpbmVkLlwiLCBcIllvdSBzaG91bGQgcHJvYmFibHkgcHJvdmlkZSB5b3VyIG93biBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uLlwiLCBcIlRoZSBlbnRpdHkgdGhhdCB3YXMgcGFzc2VkOlwiLCBlbnRpdHksIFwiVGhlIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb246XCIsIHNlbGVjdElkLnRvU3RyaW5nKCkpO1xyXG4gIH1cclxuICByZXR1cm4ga2V5O1xyXG59XHJcbmZ1bmN0aW9uIGVuc3VyZUVudGl0aWVzQXJyYXkoZW50aXRpZXMpIHtcclxuICBpZiAoIUFycmF5LmlzQXJyYXkoZW50aXRpZXMpKSB7XHJcbiAgICBlbnRpdGllcyA9IE9iamVjdC52YWx1ZXMoZW50aXRpZXMpO1xyXG4gIH1cclxuICByZXR1cm4gZW50aXRpZXM7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q3VycmVudCh2YWx1ZSkge1xyXG4gIHJldHVybiBpc0RyYWZ0NCh2YWx1ZSkgPyBjdXJyZW50Mih2YWx1ZSkgOiB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpIHtcclxuICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xyXG4gIGNvbnN0IGV4aXN0aW5nSWRzQXJyYXkgPSBnZXRDdXJyZW50KHN0YXRlLmlkcyk7XHJcbiAgY29uc3QgZXhpc3RpbmdJZHMgPSBuZXcgU2V0KGV4aXN0aW5nSWRzQXJyYXkpO1xyXG4gIGNvbnN0IGFkZGVkID0gW107XHJcbiAgY29uc3QgYWRkZWRJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXSk7XHJcbiAgY29uc3QgdXBkYXRlZCA9IFtdO1xyXG4gIGZvciAoY29uc3QgZW50aXR5IG9mIG5ld0VudGl0aWVzKSB7XHJcbiAgICBjb25zdCBpZCA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XHJcbiAgICBpZiAoZXhpc3RpbmdJZHMuaGFzKGlkKSB8fCBhZGRlZElkcy5oYXMoaWQpKSB7XHJcbiAgICAgIHVwZGF0ZWQucHVzaCh7XHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgY2hhbmdlczogZW50aXR5XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYWRkZWRJZHMuYWRkKGlkKTtcclxuICAgICAgYWRkZWQucHVzaChlbnRpdHkpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gW2FkZGVkLCB1cGRhdGVkLCBleGlzdGluZ0lkc0FycmF5XTtcclxufVxyXG5cclxuLy8gc3JjL2VudGl0aWVzL3Vuc29ydGVkX3N0YXRlX2FkYXB0ZXIudHNcclxuZnVuY3Rpb24gY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpIHtcclxuICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgIGNvbnN0IGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XHJcbiAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHN0YXRlLmlkcy5wdXNoKGtleSk7XHJcbiAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xyXG4gIH1cclxuICBmdW5jdGlvbiBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcclxuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XHJcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xyXG4gICAgICBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgIGNvbnN0IGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XHJcbiAgICBpZiAoIShrZXkgaW4gc3RhdGUuZW50aXRpZXMpKSB7XHJcbiAgICAgIHN0YXRlLmlkcy5wdXNoKGtleSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xyXG4gIH1cclxuICBmdW5jdGlvbiBzZXRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcclxuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XHJcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xyXG4gICAgICBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBzZXRBbGxNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgIHN0YXRlLmlkcyA9IFtdO1xyXG4gICAgc3RhdGUuZW50aXRpZXMgPSB7fTtcclxuICAgIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlbW92ZU9uZU11dGFibHkoa2V5LCBzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHJlbW92ZU1hbnlNdXRhYmx5KFtrZXldLCBzdGF0ZSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlbW92ZU1hbnlNdXRhYmx5KGtleXMsIHN0YXRlKSB7XHJcbiAgICBsZXQgZGlkTXV0YXRlID0gZmFsc2U7XHJcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW2tleV07XHJcbiAgICAgICAgZGlkTXV0YXRlID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAoZGlkTXV0YXRlKSB7XHJcbiAgICAgIHN0YXRlLmlkcyA9IHN0YXRlLmlkcy5maWx0ZXIoKGlkKSA9PiBpZCBpbiBzdGF0ZS5lbnRpdGllcyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlbW92ZUFsbE11dGFibHkoc3RhdGUpIHtcclxuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUsIHtcclxuICAgICAgaWRzOiBbXSxcclxuICAgICAgZW50aXRpZXM6IHt9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gdGFrZU5ld0tleShrZXlzLCB1cGRhdGUsIHN0YXRlKSB7XHJcbiAgICBjb25zdCBvcmlnaW5hbDMgPSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xyXG4gICAgaWYgKG9yaWdpbmFsMyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbDMsIHVwZGF0ZS5jaGFuZ2VzKTtcclxuICAgIGNvbnN0IG5ld0tleSA9IHNlbGVjdElkVmFsdWUodXBkYXRlZCwgc2VsZWN0SWQpO1xyXG4gICAgY29uc3QgaGFzTmV3S2V5ID0gbmV3S2V5ICE9PSB1cGRhdGUuaWQ7XHJcbiAgICBpZiAoaGFzTmV3S2V5KSB7XHJcbiAgICAgIGtleXNbdXBkYXRlLmlkXSA9IG5ld0tleTtcclxuICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzdGF0ZS5lbnRpdGllc1tuZXdLZXldID0gdXBkYXRlZDtcclxuICAgIHJldHVybiBoYXNOZXdLZXk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHVwZGF0ZU9uZU11dGFibHkodXBkYXRlLCBzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHVwZGF0ZU1hbnlNdXRhYmx5KFt1cGRhdGVdLCBzdGF0ZSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZXMsIHN0YXRlKSB7XHJcbiAgICBjb25zdCBuZXdLZXlzID0ge307XHJcbiAgICBjb25zdCB1cGRhdGVzUGVyRW50aXR5ID0ge307XHJcbiAgICB1cGRhdGVzLmZvckVhY2goKHVwZGF0ZSkgPT4ge1xyXG4gICAgICBpZiAodXBkYXRlLmlkIGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgICAgdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID0ge1xyXG4gICAgICAgICAgaWQ6IHVwZGF0ZS5pZCxcclxuICAgICAgICAgIC8vIFNwcmVhZHMgaWdub3JlIGZhbHN5IHZhbHVlcywgc28gdGhpcyB3b3JrcyBldmVuIGlmIHRoZXJlIGlzbid0XHJcbiAgICAgICAgICAvLyBhbiBleGlzdGluZyB1cGRhdGUgYWxyZWFkeSBhdCB0aGlzIGtleVxyXG4gICAgICAgICAgY2hhbmdlczoge1xyXG4gICAgICAgICAgICAuLi51cGRhdGVzUGVyRW50aXR5W3VwZGF0ZS5pZF0/LmNoYW5nZXMsXHJcbiAgICAgICAgICAgIC4uLnVwZGF0ZS5jaGFuZ2VzXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB1cGRhdGVzID0gT2JqZWN0LnZhbHVlcyh1cGRhdGVzUGVyRW50aXR5KTtcclxuICAgIGNvbnN0IGRpZE11dGF0ZUVudGl0aWVzID0gdXBkYXRlcy5sZW5ndGggPiAwO1xyXG4gICAgaWYgKGRpZE11dGF0ZUVudGl0aWVzKSB7XHJcbiAgICAgIGNvbnN0IGRpZE11dGF0ZUlkcyA9IHVwZGF0ZXMuZmlsdGVyKCh1cGRhdGUpID0+IHRha2VOZXdLZXkobmV3S2V5cywgdXBkYXRlLCBzdGF0ZSkpLmxlbmd0aCA+IDA7XHJcbiAgICAgIGlmIChkaWRNdXRhdGVJZHMpIHtcclxuICAgICAgICBzdGF0ZS5pZHMgPSBPYmplY3QudmFsdWVzKHN0YXRlLmVudGl0aWVzKS5tYXAoKGUpID0+IHNlbGVjdElkVmFsdWUoZSwgc2VsZWN0SWQpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xyXG4gIH1cclxuICBmdW5jdGlvbiB1cHNlcnRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcclxuICAgIGNvbnN0IFthZGRlZCwgdXBkYXRlZF0gPSBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpO1xyXG4gICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlKTtcclxuICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlbW92ZUFsbDogY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yKHJlbW92ZUFsbE11dGFibHkpLFxyXG4gICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxyXG4gICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXHJcbiAgICBzZXRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0T25lTXV0YWJseSksXHJcbiAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcclxuICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcclxuICAgIHVwZGF0ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVPbmVNdXRhYmx5KSxcclxuICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxyXG4gICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxyXG4gICAgdXBzZXJ0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRNYW55TXV0YWJseSksXHJcbiAgICByZW1vdmVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IocmVtb3ZlT25lTXV0YWJseSksXHJcbiAgICByZW1vdmVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHJlbW92ZU1hbnlNdXRhYmx5KVxyXG4gIH07XHJcbn1cclxuXHJcbi8vIHNyYy9lbnRpdGllcy9zb3J0ZWRfc3RhdGVfYWRhcHRlci50c1xyXG5mdW5jdGlvbiBmaW5kSW5zZXJ0SW5kZXgoc29ydGVkSXRlbXMsIGl0ZW0sIGNvbXBhcmlzb25GdW5jdGlvbikge1xyXG4gIGxldCBsb3dJbmRleCA9IDA7XHJcbiAgbGV0IGhpZ2hJbmRleCA9IHNvcnRlZEl0ZW1zLmxlbmd0aDtcclxuICB3aGlsZSAobG93SW5kZXggPCBoaWdoSW5kZXgpIHtcclxuICAgIGxldCBtaWRkbGVJbmRleCA9IGxvd0luZGV4ICsgaGlnaEluZGV4ID4+PiAxO1xyXG4gICAgY29uc3QgY3VycmVudEl0ZW0gPSBzb3J0ZWRJdGVtc1ttaWRkbGVJbmRleF07XHJcbiAgICBjb25zdCByZXMgPSBjb21wYXJpc29uRnVuY3Rpb24oaXRlbSwgY3VycmVudEl0ZW0pO1xyXG4gICAgaWYgKHJlcyA+PSAwKSB7XHJcbiAgICAgIGxvd0luZGV4ID0gbWlkZGxlSW5kZXggKyAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaGlnaEluZGV4ID0gbWlkZGxlSW5kZXg7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBsb3dJbmRleDtcclxufVxyXG5mdW5jdGlvbiBpbnNlcnQoc29ydGVkSXRlbXMsIGl0ZW0sIGNvbXBhcmlzb25GdW5jdGlvbikge1xyXG4gIGNvbnN0IGluc2VydEF0SW5kZXggPSBmaW5kSW5zZXJ0SW5kZXgoc29ydGVkSXRlbXMsIGl0ZW0sIGNvbXBhcmlzb25GdW5jdGlvbik7XHJcbiAgc29ydGVkSXRlbXMuc3BsaWNlKGluc2VydEF0SW5kZXgsIDAsIGl0ZW0pO1xyXG4gIHJldHVybiBzb3J0ZWRJdGVtcztcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQsIGNvbXBhcmVyKSB7XHJcbiAgY29uc3Qge1xyXG4gICAgcmVtb3ZlT25lLFxyXG4gICAgcmVtb3ZlTWFueSxcclxuICAgIHJlbW92ZUFsbFxyXG4gIH0gPSBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCk7XHJcbiAgZnVuY3Rpb24gYWRkT25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XHJcbiAgICByZXR1cm4gYWRkTWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlLCBleGlzdGluZ0lkcykge1xyXG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IG5ldyBTZXQoZXhpc3RpbmdJZHMgPz8gZ2V0Q3VycmVudChzdGF0ZS5pZHMpKTtcclxuICAgIGNvbnN0IG1vZGVscyA9IG5ld0VudGl0aWVzLmZpbHRlcigobW9kZWwpID0+ICFleGlzdGluZ0tleXMuaGFzKHNlbGVjdElkVmFsdWUobW9kZWwsIHNlbGVjdElkKSkpO1xyXG4gICAgaWYgKG1vZGVscy5sZW5ndGggIT09IDApIHtcclxuICAgICAgbWVyZ2VGdW5jdGlvbihzdGF0ZSwgbW9kZWxzKTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XHJcbiAgICByZXR1cm4gc2V0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gc2V0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xyXG4gICAgaWYgKG5ld0VudGl0aWVzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgbmV3RW50aXRpZXMpIHtcclxuICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbc2VsZWN0SWQoaXRlbSldO1xyXG4gICAgICB9XHJcbiAgICAgIG1lcmdlRnVuY3Rpb24oc3RhdGUsIG5ld0VudGl0aWVzKTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gc2V0QWxsTXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcclxuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XHJcbiAgICBzdGF0ZS5lbnRpdGllcyA9IHt9O1xyXG4gICAgc3RhdGUuaWRzID0gW107XHJcbiAgICBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUsIFtdKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gdXBkYXRlT25lTXV0YWJseSh1cGRhdGUsIHN0YXRlKSB7XHJcbiAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gdXBkYXRlTWFueU11dGFibHkodXBkYXRlcywgc3RhdGUpIHtcclxuICAgIGxldCBhcHBsaWVkVXBkYXRlcyA9IGZhbHNlO1xyXG4gICAgbGV0IHJlcGxhY2VkSWRzID0gZmFsc2U7XHJcbiAgICBmb3IgKGxldCB1cGRhdGUgb2YgdXBkYXRlcykge1xyXG4gICAgICBjb25zdCBlbnRpdHkgPSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xyXG4gICAgICBpZiAoIWVudGl0eSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGFwcGxpZWRVcGRhdGVzID0gdHJ1ZTtcclxuICAgICAgT2JqZWN0LmFzc2lnbihlbnRpdHksIHVwZGF0ZS5jaGFuZ2VzKTtcclxuICAgICAgY29uc3QgbmV3SWQgPSBzZWxlY3RJZChlbnRpdHkpO1xyXG4gICAgICBpZiAodXBkYXRlLmlkICE9PSBuZXdJZCkge1xyXG4gICAgICAgIHJlcGxhY2VkSWRzID0gdHJ1ZTtcclxuICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcclxuICAgICAgICBjb25zdCBvbGRJbmRleCA9IHN0YXRlLmlkcy5pbmRleE9mKHVwZGF0ZS5pZCk7XHJcbiAgICAgICAgc3RhdGUuaWRzW29sZEluZGV4XSA9IG5ld0lkO1xyXG4gICAgICAgIHN0YXRlLmVudGl0aWVzW25ld0lkXSA9IGVudGl0eTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGFwcGxpZWRVcGRhdGVzKSB7XHJcbiAgICAgIG1lcmdlRnVuY3Rpb24oc3RhdGUsIFtdLCBhcHBsaWVkVXBkYXRlcywgcmVwbGFjZWRJZHMpO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xyXG4gIH1cclxuICBmdW5jdGlvbiB1cHNlcnRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcclxuICAgIGNvbnN0IFthZGRlZCwgdXBkYXRlZCwgZXhpc3RpbmdJZHNBcnJheV0gPSBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpO1xyXG4gICAgaWYgKGFkZGVkLmxlbmd0aCkge1xyXG4gICAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUsIGV4aXN0aW5nSWRzQXJyYXkpO1xyXG4gICAgfVxyXG4gICAgaWYgKHVwZGF0ZWQubGVuZ3RoKSB7XHJcbiAgICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYSwgYikge1xyXG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKGFbaV0gPT09IGJbaV0pIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgY29uc3QgbWVyZ2VGdW5jdGlvbiA9IChzdGF0ZSwgYWRkZWRJdGVtcywgYXBwbGllZFVwZGF0ZXMsIHJlcGxhY2VkSWRzKSA9PiB7XHJcbiAgICBjb25zdCBjdXJyZW50RW50aXRpZXMgPSBnZXRDdXJyZW50KHN0YXRlLmVudGl0aWVzKTtcclxuICAgIGNvbnN0IGN1cnJlbnRJZHMgPSBnZXRDdXJyZW50KHN0YXRlLmlkcyk7XHJcbiAgICBjb25zdCBzdGF0ZUVudGl0aWVzID0gc3RhdGUuZW50aXRpZXM7XHJcbiAgICBsZXQgaWRzID0gY3VycmVudElkcztcclxuICAgIGlmIChyZXBsYWNlZElkcykge1xyXG4gICAgICBpZHMgPSBuZXcgU2V0KGN1cnJlbnRJZHMpO1xyXG4gICAgfVxyXG4gICAgbGV0IHNvcnRlZEVudGl0aWVzID0gW107XHJcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xyXG4gICAgICBjb25zdCBlbnRpdHkgPSBjdXJyZW50RW50aXRpZXNbaWRdO1xyXG4gICAgICBpZiAoZW50aXR5KSB7XHJcbiAgICAgICAgc29ydGVkRW50aXRpZXMucHVzaChlbnRpdHkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB3YXNQcmV2aW91c2x5RW1wdHkgPSBzb3J0ZWRFbnRpdGllcy5sZW5ndGggPT09IDA7XHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYWRkZWRJdGVtcykge1xyXG4gICAgICBzdGF0ZUVudGl0aWVzW3NlbGVjdElkKGl0ZW0pXSA9IGl0ZW07XHJcbiAgICAgIGlmICghd2FzUHJldmlvdXNseUVtcHR5KSB7XHJcbiAgICAgICAgaW5zZXJ0KHNvcnRlZEVudGl0aWVzLCBpdGVtLCBjb21wYXJlcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh3YXNQcmV2aW91c2x5RW1wdHkpIHtcclxuICAgICAgc29ydGVkRW50aXRpZXMgPSBhZGRlZEl0ZW1zLnNsaWNlKCkuc29ydChjb21wYXJlcik7XHJcbiAgICB9IGVsc2UgaWYgKGFwcGxpZWRVcGRhdGVzKSB7XHJcbiAgICAgIHNvcnRlZEVudGl0aWVzLnNvcnQoY29tcGFyZXIpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmV3U29ydGVkSWRzID0gc29ydGVkRW50aXRpZXMubWFwKHNlbGVjdElkKTtcclxuICAgIGlmICghYXJlQXJyYXlzRXF1YWwoY3VycmVudElkcywgbmV3U29ydGVkSWRzKSkge1xyXG4gICAgICBzdGF0ZS5pZHMgPSBuZXdTb3J0ZWRJZHM7XHJcbiAgICB9XHJcbiAgfTtcclxuICByZXR1cm4ge1xyXG4gICAgcmVtb3ZlT25lLFxyXG4gICAgcmVtb3ZlTWFueSxcclxuICAgIHJlbW92ZUFsbCxcclxuICAgIGFkZE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRPbmVNdXRhYmx5KSxcclxuICAgIHVwZGF0ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVPbmVNdXRhYmx5KSxcclxuICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcclxuICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcclxuICAgIHNldE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0TWFueU11dGFibHkpLFxyXG4gICAgc2V0QWxsOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldEFsbE11dGFibHkpLFxyXG4gICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXHJcbiAgICB1cGRhdGVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU1hbnlNdXRhYmx5KSxcclxuICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpXHJcbiAgfTtcclxufVxyXG5cclxuLy8gc3JjL2VudGl0aWVzL2NyZWF0ZV9hZGFwdGVyLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZUVudGl0eUFkYXB0ZXIob3B0aW9ucyA9IHt9KSB7XHJcbiAgY29uc3Qge1xyXG4gICAgc2VsZWN0SWQsXHJcbiAgICBzb3J0Q29tcGFyZXJcclxuICB9ID0ge1xyXG4gICAgc29ydENvbXBhcmVyOiBmYWxzZSxcclxuICAgIHNlbGVjdElkOiAoaW5zdGFuY2UpID0+IGluc3RhbmNlLmlkLFxyXG4gICAgLi4ub3B0aW9uc1xyXG4gIH07XHJcbiAgY29uc3Qgc3RhdGVBZGFwdGVyID0gc29ydENvbXBhcmVyID8gY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkLCBzb3J0Q29tcGFyZXIpIDogY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xyXG4gIGNvbnN0IHN0YXRlRmFjdG9yeSA9IGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3Rvcnkoc3RhdGVBZGFwdGVyKTtcclxuICBjb25zdCBzZWxlY3RvcnNGYWN0b3J5ID0gY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSgpO1xyXG4gIHJldHVybiB7XHJcbiAgICBzZWxlY3RJZCxcclxuICAgIHNvcnRDb21wYXJlcixcclxuICAgIC4uLnN0YXRlRmFjdG9yeSxcclxuICAgIC4uLnNlbGVjdG9yc0ZhY3RvcnksXHJcbiAgICAuLi5zdGF0ZUFkYXB0ZXJcclxuICB9O1xyXG59XHJcblxyXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL2luZGV4LnRzXHJcbmltcG9ydCB7IGlzQWN0aW9uIGFzIGlzQWN0aW9uMyB9IGZyb20gXCJyZWR1eFwiO1xyXG5cclxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS9leGNlcHRpb25zLnRzXHJcbnZhciB0YXNrID0gXCJ0YXNrXCI7XHJcbnZhciBsaXN0ZW5lciA9IFwibGlzdGVuZXJcIjtcclxudmFyIGNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XHJcbnZhciBjYW5jZWxsZWQgPSBcImNhbmNlbGxlZFwiO1xyXG52YXIgdGFza0NhbmNlbGxlZCA9IGB0YXNrLSR7Y2FuY2VsbGVkfWA7XHJcbnZhciB0YXNrQ29tcGxldGVkID0gYHRhc2stJHtjb21wbGV0ZWR9YDtcclxudmFyIGxpc3RlbmVyQ2FuY2VsbGVkID0gYCR7bGlzdGVuZXJ9LSR7Y2FuY2VsbGVkfWA7XHJcbnZhciBsaXN0ZW5lckNvbXBsZXRlZCA9IGAke2xpc3RlbmVyfS0ke2NvbXBsZXRlZH1gO1xyXG52YXIgVGFza0Fib3J0RXJyb3IgPSBjbGFzcyB7XHJcbiAgY29uc3RydWN0b3IoY29kZSkge1xyXG4gICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgIHRoaXMubWVzc2FnZSA9IGAke3Rhc2t9ICR7Y2FuY2VsbGVkfSAocmVhc29uOiAke2NvZGV9KWA7XHJcbiAgfVxyXG4gIG5hbWUgPSBcIlRhc2tBYm9ydEVycm9yXCI7XHJcbiAgbWVzc2FnZTtcclxufTtcclxuXHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvdXRpbHMudHNcclxudmFyIGFzc2VydEZ1bmN0aW9uID0gKGZ1bmMsIGV4cGVjdGVkKSA9PiB7XHJcbiAgaWYgKHR5cGVvZiBmdW5jICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMikgOiBgJHtleHBlY3RlZH0gaXMgbm90IGEgZnVuY3Rpb25gKTtcclxuICB9XHJcbn07XHJcbnZhciBub29wMiA9ICgpID0+IHtcclxufTtcclxudmFyIGNhdGNoUmVqZWN0aW9uID0gKHByb21pc2UsIG9uRXJyb3IgPSBub29wMikgPT4ge1xyXG4gIHByb21pc2UuY2F0Y2gob25FcnJvcik7XHJcbiAgcmV0dXJuIHByb21pc2U7XHJcbn07XHJcbnZhciBhZGRBYm9ydFNpZ25hbExpc3RlbmVyID0gKGFib3J0U2lnbmFsLCBjYWxsYmFjaykgPT4ge1xyXG4gIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjaywge1xyXG4gICAgb25jZTogdHJ1ZVxyXG4gIH0pO1xyXG4gIHJldHVybiAoKSA9PiBhYm9ydFNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgY2FsbGJhY2spO1xyXG59O1xyXG52YXIgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbiA9IChhYm9ydENvbnRyb2xsZXIsIHJlYXNvbikgPT4ge1xyXG4gIGNvbnN0IHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XHJcbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmICghKFwicmVhc29uXCIgaW4gc2lnbmFsKSkge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNpZ25hbCwgXCJyZWFzb25cIiwge1xyXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICB2YWx1ZTogcmVhc29uLFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICB9XHJcbiAgO1xyXG4gIGFib3J0Q29udHJvbGxlci5hYm9ydChyZWFzb24pO1xyXG59O1xyXG5cclxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS90YXNrLnRzXHJcbnZhciB2YWxpZGF0ZUFjdGl2ZSA9IChzaWduYWwpID0+IHtcclxuICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgcmVhc29uXHJcbiAgICB9ID0gc2lnbmFsO1xyXG4gICAgdGhyb3cgbmV3IFRhc2tBYm9ydEVycm9yKHJlYXNvbik7XHJcbiAgfVxyXG59O1xyXG5mdW5jdGlvbiByYWNlV2l0aFNpZ25hbChzaWduYWwsIHByb21pc2UpIHtcclxuICBsZXQgY2xlYW51cCA9IG5vb3AyO1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBjb25zdCBub3RpZnlSZWplY3Rpb24gPSAoKSA9PiByZWplY3QobmV3IFRhc2tBYm9ydEVycm9yKHNpZ25hbC5yZWFzb24pKTtcclxuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICBub3RpZnlSZWplY3Rpb24oKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY2xlYW51cCA9IGFkZEFib3J0U2lnbmFsTGlzdGVuZXIoc2lnbmFsLCBub3RpZnlSZWplY3Rpb24pO1xyXG4gICAgcHJvbWlzZS5maW5hbGx5KCgpID0+IGNsZWFudXAoKSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xyXG4gIH0pLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgY2xlYW51cCA9IG5vb3AyO1xyXG4gIH0pO1xyXG59XHJcbnZhciBydW5UYXNrID0gYXN5bmMgKHRhc2syLCBjbGVhblVwKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0YXNrMigpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3RhdHVzOiBcIm9rXCIsXHJcbiAgICAgIHZhbHVlXHJcbiAgICB9O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdGF0dXM6IGVycm9yIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IgPyBcImNhbmNlbGxlZFwiIDogXCJyZWplY3RlZFwiLFxyXG4gICAgICBlcnJvclxyXG4gICAgfTtcclxuICB9IGZpbmFsbHkge1xyXG4gICAgY2xlYW5VcD8uKCk7XHJcbiAgfVxyXG59O1xyXG52YXIgY3JlYXRlUGF1c2UgPSAoc2lnbmFsKSA9PiB7XHJcbiAgcmV0dXJuIChwcm9taXNlKSA9PiB7XHJcbiAgICByZXR1cm4gY2F0Y2hSZWplY3Rpb24ocmFjZVdpdGhTaWduYWwoc2lnbmFsLCBwcm9taXNlKS50aGVuKChvdXRwdXQpID0+IHtcclxuICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcclxuICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH0pKTtcclxuICB9O1xyXG59O1xyXG52YXIgY3JlYXRlRGVsYXkgPSAoc2lnbmFsKSA9PiB7XHJcbiAgY29uc3QgcGF1c2UgPSBjcmVhdGVQYXVzZShzaWduYWwpO1xyXG4gIHJldHVybiAodGltZW91dE1zKSA9PiB7XHJcbiAgICByZXR1cm4gcGF1c2UobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dE1zKSkpO1xyXG4gIH07XHJcbn07XHJcblxyXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL2luZGV4LnRzXHJcbnZhciB7XHJcbiAgYXNzaWduXHJcbn0gPSBPYmplY3Q7XHJcbnZhciBJTlRFUk5BTF9OSUxfVE9LRU4gPSB7fTtcclxudmFyIGFsbSA9IFwibGlzdGVuZXJNaWRkbGV3YXJlXCI7XHJcbnZhciBjcmVhdGVGb3JrID0gKHBhcmVudEFib3J0U2lnbmFsLCBwYXJlbnRCbG9ja2luZ1Byb21pc2VzKSA9PiB7XHJcbiAgY29uc3QgbGlua0NvbnRyb2xsZXJzID0gKGNvbnRyb2xsZXIpID0+IGFkZEFib3J0U2lnbmFsTGlzdGVuZXIocGFyZW50QWJvcnRTaWduYWwsICgpID0+IGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgcGFyZW50QWJvcnRTaWduYWwucmVhc29uKSk7XHJcbiAgcmV0dXJuICh0YXNrRXhlY3V0b3IsIG9wdHMpID0+IHtcclxuICAgIGFzc2VydEZ1bmN0aW9uKHRhc2tFeGVjdXRvciwgXCJ0YXNrRXhlY3V0b3JcIik7XHJcbiAgICBjb25zdCBjaGlsZEFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcclxuICAgIGxpbmtDb250cm9sbGVycyhjaGlsZEFib3J0Q29udHJvbGxlcik7XHJcbiAgICBjb25zdCByZXN1bHQgPSBydW5UYXNrKGFzeW5jICgpID0+IHtcclxuICAgICAgdmFsaWRhdGVBY3RpdmUocGFyZW50QWJvcnRTaWduYWwpO1xyXG4gICAgICB2YWxpZGF0ZUFjdGl2ZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpO1xyXG4gICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgdGFza0V4ZWN1dG9yKHtcclxuICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2UoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICBzaWduYWw6IGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbFxyXG4gICAgICB9KTtcclxuICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDI7XHJcbiAgICB9LCAoKSA9PiBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNoaWxkQWJvcnRDb250cm9sbGVyLCB0YXNrQ29tcGxldGVkKSk7XHJcbiAgICBpZiAob3B0cz8uYXV0b0pvaW4pIHtcclxuICAgICAgcGFyZW50QmxvY2tpbmdQcm9taXNlcy5wdXNoKHJlc3VsdC5jYXRjaChub29wMikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmVzdWx0OiBjcmVhdGVQYXVzZShwYXJlbnRBYm9ydFNpZ25hbCkocmVzdWx0KSxcclxuICAgICAgY2FuY2VsKCkge1xyXG4gICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY2hpbGRBYm9ydENvbnRyb2xsZXIsIHRhc2tDYW5jZWxsZWQpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH07XHJcbn07XHJcbnZhciBjcmVhdGVUYWtlUGF0dGVybiA9IChzdGFydExpc3RlbmluZywgc2lnbmFsKSA9PiB7XHJcbiAgY29uc3QgdGFrZSA9IGFzeW5jIChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IHtcclxuICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XHJcbiAgICBsZXQgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdHVwbGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBsZXQgc3RvcExpc3RlbmluZyA9IHN0YXJ0TGlzdGVuaW5nKHtcclxuICAgICAgICBwcmVkaWNhdGUsXHJcbiAgICAgICAgZWZmZWN0OiAoYWN0aW9uLCBsaXN0ZW5lckFwaSkgPT4ge1xyXG4gICAgICAgICAgbGlzdGVuZXJBcGkudW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgIHJlc29sdmUoW2FjdGlvbiwgbGlzdGVuZXJBcGkuZ2V0U3RhdGUoKSwgbGlzdGVuZXJBcGkuZ2V0T3JpZ2luYWxTdGF0ZSgpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XHJcbiAgICAgICAgc3RvcExpc3RlbmluZygpO1xyXG4gICAgICAgIHJlamVjdCgpO1xyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBwcm9taXNlcyA9IFt0dXBsZVByb21pc2VdO1xyXG4gICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xyXG4gICAgICBwcm9taXNlcy5wdXNoKG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXQsIG51bGwpKSk7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCByYWNlV2l0aFNpZ25hbChzaWduYWwsIFByb21pc2UucmFjZShwcm9taXNlcykpO1xyXG4gICAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xyXG4gICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgdW5zdWJzY3JpYmUoKTtcclxuICAgIH1cclxuICB9O1xyXG4gIHJldHVybiAocHJlZGljYXRlLCB0aW1lb3V0KSA9PiBjYXRjaFJlamVjdGlvbih0YWtlKHByZWRpY2F0ZSwgdGltZW91dCkpO1xyXG59O1xyXG52YXIgZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbSA9IChvcHRpb25zKSA9PiB7XHJcbiAgbGV0IHtcclxuICAgIHR5cGUsXHJcbiAgICBhY3Rpb25DcmVhdG9yLFxyXG4gICAgbWF0Y2hlcixcclxuICAgIHByZWRpY2F0ZSxcclxuICAgIGVmZmVjdFxyXG4gIH0gPSBvcHRpb25zO1xyXG4gIGlmICh0eXBlKSB7XHJcbiAgICBwcmVkaWNhdGUgPSBjcmVhdGVBY3Rpb24odHlwZSkubWF0Y2g7XHJcbiAgfSBlbHNlIGlmIChhY3Rpb25DcmVhdG9yKSB7XHJcbiAgICB0eXBlID0gYWN0aW9uQ3JlYXRvci50eXBlO1xyXG4gICAgcHJlZGljYXRlID0gYWN0aW9uQ3JlYXRvci5tYXRjaDtcclxuICB9IGVsc2UgaWYgKG1hdGNoZXIpIHtcclxuICAgIHByZWRpY2F0ZSA9IG1hdGNoZXI7XHJcbiAgfSBlbHNlIGlmIChwcmVkaWNhdGUpIHtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjEpIDogXCJDcmVhdGluZyBvciByZW1vdmluZyBhIGxpc3RlbmVyIHJlcXVpcmVzIG9uZSBvZiB0aGUga25vd24gZmllbGRzIGZvciBtYXRjaGluZyBhbiBhY3Rpb25cIik7XHJcbiAgfVxyXG4gIGFzc2VydEZ1bmN0aW9uKGVmZmVjdCwgXCJvcHRpb25zLmxpc3RlbmVyXCIpO1xyXG4gIHJldHVybiB7XHJcbiAgICBwcmVkaWNhdGUsXHJcbiAgICB0eXBlLFxyXG4gICAgZWZmZWN0XHJcbiAgfTtcclxufTtcclxudmFyIGNyZWF0ZUxpc3RlbmVyRW50cnkgPSAvKiBAX19QVVJFX18gKi8gYXNzaWduKChvcHRpb25zKSA9PiB7XHJcbiAgY29uc3Qge1xyXG4gICAgdHlwZSxcclxuICAgIHByZWRpY2F0ZSxcclxuICAgIGVmZmVjdFxyXG4gIH0gPSBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tKG9wdGlvbnMpO1xyXG4gIGNvbnN0IGVudHJ5ID0ge1xyXG4gICAgaWQ6IG5hbm9pZCgpLFxyXG4gICAgZWZmZWN0LFxyXG4gICAgdHlwZSxcclxuICAgIHByZWRpY2F0ZSxcclxuICAgIHBlbmRpbmc6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXHJcbiAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMikgOiBcIlVuc3Vic2NyaWJlIG5vdCBpbml0aWFsaXplZFwiKTtcclxuICAgIH1cclxuICB9O1xyXG4gIHJldHVybiBlbnRyeTtcclxufSwge1xyXG4gIHdpdGhUeXBlczogKCkgPT4gY3JlYXRlTGlzdGVuZXJFbnRyeVxyXG59KTtcclxudmFyIGZpbmRMaXN0ZW5lckVudHJ5ID0gKGxpc3RlbmVyTWFwLCBvcHRpb25zKSA9PiB7XHJcbiAgY29uc3Qge1xyXG4gICAgdHlwZSxcclxuICAgIGVmZmVjdCxcclxuICAgIHByZWRpY2F0ZVxyXG4gIH0gPSBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tKG9wdGlvbnMpO1xyXG4gIHJldHVybiBBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKS5maW5kKChlbnRyeSkgPT4ge1xyXG4gICAgY29uc3QgbWF0Y2hQcmVkaWNhdGVPclR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVudHJ5LnR5cGUgPT09IHR5cGUgOiBlbnRyeS5wcmVkaWNhdGUgPT09IHByZWRpY2F0ZTtcclxuICAgIHJldHVybiBtYXRjaFByZWRpY2F0ZU9yVHlwZSAmJiBlbnRyeS5lZmZlY3QgPT09IGVmZmVjdDtcclxuICB9KTtcclxufTtcclxudmFyIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyA9IChlbnRyeSkgPT4ge1xyXG4gIGVudHJ5LnBlbmRpbmcuZm9yRWFjaCgoY29udHJvbGxlcikgPT4ge1xyXG4gICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XHJcbiAgfSk7XHJcbn07XHJcbnZhciBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSA9IChsaXN0ZW5lck1hcCkgPT4ge1xyXG4gIHJldHVybiAoKSA9PiB7XHJcbiAgICBsaXN0ZW5lck1hcC5mb3JFYWNoKGNhbmNlbEFjdGl2ZUxpc3RlbmVycyk7XHJcbiAgICBsaXN0ZW5lck1hcC5jbGVhcigpO1xyXG4gIH07XHJcbn07XHJcbnZhciBzYWZlbHlOb3RpZnlFcnJvciA9IChlcnJvckhhbmRsZXIsIGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbykgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBlcnJvckhhbmRsZXIoZXJyb3JUb05vdGlmeSwgZXJyb3JJbmZvKTtcclxuICB9IGNhdGNoIChlcnJvckhhbmRsZXJFcnJvcikge1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHRocm93IGVycm9ySGFuZGxlckVycm9yO1xyXG4gICAgfSwgMCk7XHJcbiAgfVxyXG59O1xyXG52YXIgYWRkTGlzdGVuZXIgPSAvKiBAX19QVVJFX18gKi8gYXNzaWduKC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBY3Rpb24oYCR7YWxtfS9hZGRgKSwge1xyXG4gIHdpdGhUeXBlczogKCkgPT4gYWRkTGlzdGVuZXJcclxufSk7XHJcbnZhciBjbGVhckFsbExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBY3Rpb24oYCR7YWxtfS9yZW1vdmVBbGxgKTtcclxudmFyIHJlbW92ZUxpc3RlbmVyID0gLyogQF9fUFVSRV9fICovIGFzc2lnbigvKiBAX19QVVJFX18gKi8gY3JlYXRlQWN0aW9uKGAke2FsbX0vcmVtb3ZlYCksIHtcclxuICB3aXRoVHlwZXM6ICgpID0+IHJlbW92ZUxpc3RlbmVyXHJcbn0pO1xyXG52YXIgZGVmYXVsdEVycm9ySGFuZGxlciA9ICguLi5hcmdzKSA9PiB7XHJcbiAgY29uc29sZS5lcnJvcihgJHthbG19L2Vycm9yYCwgLi4uYXJncyk7XHJcbn07XHJcbnZhciBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUgPSAobWlkZGxld2FyZU9wdGlvbnMgPSB7fSkgPT4ge1xyXG4gIGNvbnN0IGxpc3RlbmVyTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcclxuICBjb25zdCB7XHJcbiAgICBleHRyYSxcclxuICAgIG9uRXJyb3IgPSBkZWZhdWx0RXJyb3JIYW5kbGVyXHJcbiAgfSA9IG1pZGRsZXdhcmVPcHRpb25zO1xyXG4gIGFzc2VydEZ1bmN0aW9uKG9uRXJyb3IsIFwib25FcnJvclwiKTtcclxuICBjb25zdCBpbnNlcnRFbnRyeSA9IChlbnRyeSkgPT4ge1xyXG4gICAgZW50cnkudW5zdWJzY3JpYmUgPSAoKSA9PiBsaXN0ZW5lck1hcC5kZWxldGUoZW50cnkuaWQpO1xyXG4gICAgbGlzdGVuZXJNYXAuc2V0KGVudHJ5LmlkLCBlbnRyeSk7XHJcbiAgICByZXR1cm4gKGNhbmNlbE9wdGlvbnMpID0+IHtcclxuICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcclxuICAgICAgaWYgKGNhbmNlbE9wdGlvbnM/LmNhbmNlbEFjdGl2ZSkge1xyXG4gICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyhlbnRyeSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfTtcclxuICBjb25zdCBzdGFydExpc3RlbmluZyA9IChvcHRpb25zKSA9PiB7XHJcbiAgICBjb25zdCBlbnRyeSA9IGZpbmRMaXN0ZW5lckVudHJ5KGxpc3RlbmVyTWFwLCBvcHRpb25zKSA/PyBjcmVhdGVMaXN0ZW5lckVudHJ5KG9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIGluc2VydEVudHJ5KGVudHJ5KTtcclxuICB9O1xyXG4gIGFzc2lnbihzdGFydExpc3RlbmluZywge1xyXG4gICAgd2l0aFR5cGVzOiAoKSA9PiBzdGFydExpc3RlbmluZ1xyXG4gIH0pO1xyXG4gIGNvbnN0IHN0b3BMaXN0ZW5pbmcgPSAob3B0aW9ucykgPT4ge1xyXG4gICAgY29uc3QgZW50cnkgPSBmaW5kTGlzdGVuZXJFbnRyeShsaXN0ZW5lck1hcCwgb3B0aW9ucyk7XHJcbiAgICBpZiAoZW50cnkpIHtcclxuICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcclxuICAgICAgaWYgKG9wdGlvbnMuY2FuY2VsQWN0aXZlKSB7XHJcbiAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuICEhZW50cnk7XHJcbiAgfTtcclxuICBhc3NpZ24oc3RvcExpc3RlbmluZywge1xyXG4gICAgd2l0aFR5cGVzOiAoKSA9PiBzdG9wTGlzdGVuaW5nXHJcbiAgfSk7XHJcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXIgPSBhc3luYyAoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKSA9PiB7XHJcbiAgICBjb25zdCBpbnRlcm5hbFRhc2tDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgY29uc3QgdGFrZSA9IGNyZWF0ZVRha2VQYXR0ZXJuKHN0YXJ0TGlzdGVuaW5nLCBpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCk7XHJcbiAgICBjb25zdCBhdXRvSm9pblByb21pc2VzID0gW107XHJcbiAgICB0cnkge1xyXG4gICAgICBlbnRyeS5wZW5kaW5nLmFkZChpbnRlcm5hbFRhc2tDb250cm9sbGVyKTtcclxuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGVudHJ5LmVmZmVjdChcclxuICAgICAgICBhY3Rpb24sXHJcbiAgICAgICAgLy8gVXNlIGFzc2lnbigpIHJhdGhlciB0aGFuIC4uLiB0byBhdm9pZCBleHRyYSBoZWxwZXIgZnVuY3Rpb25zIGFkZGVkIHRvIGJ1bmRsZVxyXG4gICAgICAgIGFzc2lnbih7fSwgYXBpLCB7XHJcbiAgICAgICAgICBnZXRPcmlnaW5hbFN0YXRlLFxyXG4gICAgICAgICAgY29uZGl0aW9uOiAocHJlZGljYXRlLCB0aW1lb3V0KSA9PiB0YWtlKHByZWRpY2F0ZSwgdGltZW91dCkudGhlbihCb29sZWFuKSxcclxuICAgICAgICAgIHRha2UsXHJcbiAgICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpLFxyXG4gICAgICAgICAgcGF1c2U6IGNyZWF0ZVBhdXNlKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICAgIGV4dHJhLFxyXG4gICAgICAgICAgc2lnbmFsOiBpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCxcclxuICAgICAgICAgIGZvcms6IGNyZWF0ZUZvcmsoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwsIGF1dG9Kb2luUHJvbWlzZXMpLFxyXG4gICAgICAgICAgdW5zdWJzY3JpYmU6IGVudHJ5LnVuc3Vic2NyaWJlLFxyXG4gICAgICAgICAgc3Vic2NyaWJlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVyczogKCkgPT4ge1xyXG4gICAgICAgICAgICBlbnRyeS5wZW5kaW5nLmZvckVhY2goKGNvbnRyb2xsZXIsIF8sIHNldCkgPT4ge1xyXG4gICAgICAgICAgICAgIGlmIChjb250cm9sbGVyICE9PSBpbnRlcm5hbFRhc2tDb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIGxpc3RlbmVyQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgICAgIHNldC5kZWxldGUoY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBjYW5jZWw6ICgpID0+IHtcclxuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihpbnRlcm5hbFRhc2tDb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZGVsZXRlKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQ6ICgpID0+IHtcclxuICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICkpO1xyXG4gICAgfSBjYXRjaCAobGlzdGVuZXJFcnJvcikge1xyXG4gICAgICBpZiAoIShsaXN0ZW5lckVycm9yIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IpKSB7XHJcbiAgICAgICAgc2FmZWx5Tm90aWZ5RXJyb3Iob25FcnJvciwgbGlzdGVuZXJFcnJvciwge1xyXG4gICAgICAgICAgcmFpc2VkQnk6IFwiZWZmZWN0XCJcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYXV0b0pvaW5Qcm9taXNlcyk7XHJcbiAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgbGlzdGVuZXJDb21wbGV0ZWQpO1xyXG4gICAgICBlbnRyeS5wZW5kaW5nLmRlbGV0ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyKTtcclxuICAgIH1cclxuICB9O1xyXG4gIGNvbnN0IGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlID0gY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUobGlzdGVuZXJNYXApO1xyXG4gIGNvbnN0IG1pZGRsZXdhcmUgPSAoYXBpKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xyXG4gICAgaWYgKCFpc0FjdGlvbjMoYWN0aW9uKSkge1xyXG4gICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgaWYgKGFkZExpc3RlbmVyLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgcmV0dXJuIHN0YXJ0TGlzdGVuaW5nKGFjdGlvbi5wYXlsb2FkKTtcclxuICAgIH1cclxuICAgIGlmIChjbGVhckFsbExpc3RlbmVycy5tYXRjaChhY3Rpb24pKSB7XHJcbiAgICAgIGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChyZW1vdmVMaXN0ZW5lci5tYXRjaChhY3Rpb24pKSB7XHJcbiAgICAgIHJldHVybiBzdG9wTGlzdGVuaW5nKGFjdGlvbi5wYXlsb2FkKTtcclxuICAgIH1cclxuICAgIGxldCBvcmlnaW5hbFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XHJcbiAgICBjb25zdCBnZXRPcmlnaW5hbFN0YXRlID0gKCkgPT4ge1xyXG4gICAgICBpZiAob3JpZ2luYWxTdGF0ZSA9PT0gSU5URVJOQUxfTklMX1RPS0VOKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjMpIDogYCR7YWxtfTogZ2V0T3JpZ2luYWxTdGF0ZSBjYW4gb25seSBiZSBjYWxsZWQgc3luY2hyb25vdXNseWApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvcmlnaW5hbFN0YXRlO1xyXG4gICAgfTtcclxuICAgIGxldCByZXN1bHQ7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXN1bHQgPSBuZXh0KGFjdGlvbik7XHJcbiAgICAgIGlmIChsaXN0ZW5lck1hcC5zaXplID4gMCkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGFwaS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IGxpc3RlbmVyRW50cmllcyA9IEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpO1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgbGlzdGVuZXJFbnRyaWVzKSB7XHJcbiAgICAgICAgICBsZXQgcnVuTGlzdGVuZXIgPSBmYWxzZTtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJ1bkxpc3RlbmVyID0gZW50cnkucHJlZGljYXRlKGFjdGlvbiwgY3VycmVudFN0YXRlLCBvcmlnaW5hbFN0YXRlKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKHByZWRpY2F0ZUVycm9yKSB7XHJcbiAgICAgICAgICAgIHJ1bkxpc3RlbmVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNhZmVseU5vdGlmeUVycm9yKG9uRXJyb3IsIHByZWRpY2F0ZUVycm9yLCB7XHJcbiAgICAgICAgICAgICAgcmFpc2VkQnk6IFwicHJlZGljYXRlXCJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIXJ1bkxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbm90aWZ5TGlzdGVuZXIoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIG9yaWdpbmFsU3RhdGUgPSBJTlRFUk5BTF9OSUxfVE9LRU47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcbiAgcmV0dXJuIHtcclxuICAgIG1pZGRsZXdhcmUsXHJcbiAgICBzdGFydExpc3RlbmluZyxcclxuICAgIHN0b3BMaXN0ZW5pbmcsXHJcbiAgICBjbGVhckxpc3RlbmVyczogY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmVcclxuICB9O1xyXG59O1xyXG5cclxuLy8gc3JjL2R5bmFtaWNNaWRkbGV3YXJlL2luZGV4LnRzXHJcbmltcG9ydCB7IGNvbXBvc2UgYXMgY29tcG9zZTMgfSBmcm9tIFwicmVkdXhcIjtcclxudmFyIGNyZWF0ZU1pZGRsZXdhcmVFbnRyeSA9IChtaWRkbGV3YXJlKSA9PiAoe1xyXG4gIG1pZGRsZXdhcmUsXHJcbiAgYXBwbGllZDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxyXG59KTtcclxudmFyIG1hdGNoSW5zdGFuY2UgPSAoaW5zdGFuY2VJZCkgPT4gKGFjdGlvbikgPT4gYWN0aW9uPy5tZXRhPy5pbnN0YW5jZUlkID09PSBpbnN0YW5jZUlkO1xyXG52YXIgY3JlYXRlRHluYW1pY01pZGRsZXdhcmUgPSAoKSA9PiB7XHJcbiAgY29uc3QgaW5zdGFuY2VJZCA9IG5hbm9pZCgpO1xyXG4gIGNvbnN0IG1pZGRsZXdhcmVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xyXG4gIGNvbnN0IHdpdGhNaWRkbGV3YXJlID0gT2JqZWN0LmFzc2lnbihjcmVhdGVBY3Rpb24oXCJkeW5hbWljTWlkZGxld2FyZS9hZGRcIiwgKC4uLm1pZGRsZXdhcmVzKSA9PiAoe1xyXG4gICAgcGF5bG9hZDogbWlkZGxld2FyZXMsXHJcbiAgICBtZXRhOiB7XHJcbiAgICAgIGluc3RhbmNlSWRcclxuICAgIH1cclxuICB9KSksIHtcclxuICAgIHdpdGhUeXBlczogKCkgPT4gd2l0aE1pZGRsZXdhcmVcclxuICB9KTtcclxuICBjb25zdCBhZGRNaWRkbGV3YXJlID0gT2JqZWN0LmFzc2lnbihmdW5jdGlvbiBhZGRNaWRkbGV3YXJlMiguLi5taWRkbGV3YXJlcykge1xyXG4gICAgbWlkZGxld2FyZXMuZm9yRWFjaCgobWlkZGxld2FyZTIpID0+IHtcclxuICAgICAgZ2V0T3JJbnNlcnRDb21wdXRlZChtaWRkbGV3YXJlTWFwLCBtaWRkbGV3YXJlMiwgY3JlYXRlTWlkZGxld2FyZUVudHJ5KTtcclxuICAgIH0pO1xyXG4gIH0sIHtcclxuICAgIHdpdGhUeXBlczogKCkgPT4gYWRkTWlkZGxld2FyZVxyXG4gIH0pO1xyXG4gIGNvbnN0IGdldEZpbmFsTWlkZGxld2FyZSA9IChhcGkpID0+IHtcclxuICAgIGNvbnN0IGFwcGxpZWRNaWRkbGV3YXJlID0gQXJyYXkuZnJvbShtaWRkbGV3YXJlTWFwLnZhbHVlcygpKS5tYXAoKGVudHJ5KSA9PiBnZXRPckluc2VydENvbXB1dGVkKGVudHJ5LmFwcGxpZWQsIGFwaSwgZW50cnkubWlkZGxld2FyZSkpO1xyXG4gICAgcmV0dXJuIGNvbXBvc2UzKC4uLmFwcGxpZWRNaWRkbGV3YXJlKTtcclxuICB9O1xyXG4gIGNvbnN0IGlzV2l0aE1pZGRsZXdhcmUgPSBpc0FsbE9mKHdpdGhNaWRkbGV3YXJlLCBtYXRjaEluc3RhbmNlKGluc3RhbmNlSWQpKTtcclxuICBjb25zdCBtaWRkbGV3YXJlID0gKGFwaSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcclxuICAgIGlmIChpc1dpdGhNaWRkbGV3YXJlKGFjdGlvbikpIHtcclxuICAgICAgYWRkTWlkZGxld2FyZSguLi5hY3Rpb24ucGF5bG9hZCk7XHJcbiAgICAgIHJldHVybiBhcGkuZGlzcGF0Y2g7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0RmluYWxNaWRkbGV3YXJlKGFwaSkobmV4dCkoYWN0aW9uKTtcclxuICB9O1xyXG4gIHJldHVybiB7XHJcbiAgICBtaWRkbGV3YXJlLFxyXG4gICAgYWRkTWlkZGxld2FyZSxcclxuICAgIHdpdGhNaWRkbGV3YXJlLFxyXG4gICAgaW5zdGFuY2VJZFxyXG4gIH07XHJcbn07XHJcblxyXG4vLyBzcmMvY29tYmluZVNsaWNlcy50c1xyXG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgYXMgY29tYmluZVJlZHVjZXJzMiB9IGZyb20gXCJyZWR1eFwiO1xyXG52YXIgaXNTbGljZUxpa2UgPSAobWF5YmVTbGljZUxpa2UpID0+IFwicmVkdWNlclBhdGhcIiBpbiBtYXliZVNsaWNlTGlrZSAmJiB0eXBlb2YgbWF5YmVTbGljZUxpa2UucmVkdWNlclBhdGggPT09IFwic3RyaW5nXCI7XHJcbnZhciBnZXRSZWR1Y2VycyA9IChzbGljZXMpID0+IHNsaWNlcy5mbGF0TWFwKChzbGljZU9yTWFwKSA9PiBpc1NsaWNlTGlrZShzbGljZU9yTWFwKSA/IFtbc2xpY2VPck1hcC5yZWR1Y2VyUGF0aCwgc2xpY2VPck1hcC5yZWR1Y2VyXV0gOiBPYmplY3QuZW50cmllcyhzbGljZU9yTWFwKSk7XHJcbnZhciBPUklHSU5BTF9TVEFURSA9IFN5bWJvbC5mb3IoXCJydGstc3RhdGUtcHJveHktb3JpZ2luYWxcIik7XHJcbnZhciBpc1N0YXRlUHJveHkgPSAodmFsdWUpID0+ICEhdmFsdWUgJiYgISF2YWx1ZVtPUklHSU5BTF9TVEFURV07XHJcbnZhciBzdGF0ZVByb3h5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XHJcbnZhciBjcmVhdGVTdGF0ZVByb3h5ID0gKHN0YXRlLCByZWR1Y2VyTWFwLCBpbml0aWFsU3RhdGVDYWNoZSkgPT4gZ2V0T3JJbnNlcnRDb21wdXRlZChzdGF0ZVByb3h5TWFwLCBzdGF0ZSwgKCkgPT4gbmV3IFByb3h5KHN0YXRlLCB7XHJcbiAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xyXG4gICAgaWYgKHByb3AgPT09IE9SSUdJTkFMX1NUQVRFKSByZXR1cm4gdGFyZ2V0O1xyXG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XHJcbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICBjb25zdCBjYWNoZWQgPSBpbml0aWFsU3RhdGVDYWNoZVtwcm9wXTtcclxuICAgICAgaWYgKHR5cGVvZiBjYWNoZWQgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBjYWNoZWQ7XHJcbiAgICAgIGNvbnN0IHJlZHVjZXIgPSByZWR1Y2VyTWFwW3Byb3BdO1xyXG4gICAgICBpZiAocmVkdWNlcikge1xyXG4gICAgICAgIGNvbnN0IHJlZHVjZXJSZXN1bHQgPSByZWR1Y2VyKHZvaWQgMCwge1xyXG4gICAgICAgICAgdHlwZTogbmFub2lkKClcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodHlwZW9mIHJlZHVjZXJSZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI0KSA6IGBUaGUgc2xpY2UgcmVkdWNlciBmb3Iga2V5IFwiJHtwcm9wLnRvU3RyaW5nKCl9XCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gY2FsbGVkIGZvciBzZWxlY3RvcigpLiBJZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VyIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLiBJZiB5b3UgZG9uJ3Qgd2FudCB0byBzZXQgYSB2YWx1ZSBmb3IgdGhpcyByZWR1Y2VyLCB5b3UgY2FuIHVzZSBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbml0aWFsU3RhdGVDYWNoZVtwcm9wXSA9IHJlZHVjZXJSZXN1bHQ7XHJcbiAgICAgICAgcmV0dXJuIHJlZHVjZXJSZXN1bHQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG59KSk7XHJcbnZhciBvcmlnaW5hbCA9IChzdGF0ZSkgPT4ge1xyXG4gIGlmICghaXNTdGF0ZVByb3h5KHN0YXRlKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjUpIDogXCJvcmlnaW5hbCBtdXN0IGJlIHVzZWQgb24gc3RhdGUgUHJveHlcIik7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZVtPUklHSU5BTF9TVEFURV07XHJcbn07XHJcbnZhciBlbXB0eU9iamVjdCA9IHt9O1xyXG52YXIgbm9vcFJlZHVjZXIgPSAoc3RhdGUgPSBlbXB0eU9iamVjdCkgPT4gc3RhdGU7XHJcbmZ1bmN0aW9uIGNvbWJpbmVTbGljZXMoLi4uc2xpY2VzKSB7XHJcbiAgY29uc3QgcmVkdWNlck1hcCA9IE9iamVjdC5mcm9tRW50cmllcyhnZXRSZWR1Y2VycyhzbGljZXMpKTtcclxuICBjb25zdCBnZXRSZWR1Y2VyID0gKCkgPT4gT2JqZWN0LmtleXMocmVkdWNlck1hcCkubGVuZ3RoID8gY29tYmluZVJlZHVjZXJzMihyZWR1Y2VyTWFwKSA6IG5vb3BSZWR1Y2VyO1xyXG4gIGxldCByZWR1Y2VyID0gZ2V0UmVkdWNlcigpO1xyXG4gIGZ1bmN0aW9uIGNvbWJpbmVkUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XHJcbiAgICByZXR1cm4gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcclxuICB9XHJcbiAgY29tYmluZWRSZWR1Y2VyLndpdGhMYXp5TG9hZGVkU2xpY2VzID0gKCkgPT4gY29tYmluZWRSZWR1Y2VyO1xyXG4gIGNvbnN0IGluaXRpYWxTdGF0ZUNhY2hlID0ge307XHJcbiAgY29uc3QgaW5qZWN0ID0gKHNsaWNlLCBjb25maWcgPSB7fSkgPT4ge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICByZWR1Y2VyUGF0aCxcclxuICAgICAgcmVkdWNlcjogcmVkdWNlclRvSW5qZWN0XHJcbiAgICB9ID0gc2xpY2U7XHJcbiAgICBjb25zdCBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXJNYXBbcmVkdWNlclBhdGhdO1xyXG4gICAgaWYgKCFjb25maWcub3ZlcnJpZGVFeGlzdGluZyAmJiBjdXJyZW50UmVkdWNlciAmJiBjdXJyZW50UmVkdWNlciAhPT0gcmVkdWNlclRvSW5qZWN0KSB7XHJcbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgY2FsbGVkIFxcYGluamVjdFxcYCB0byBvdmVycmlkZSBhbHJlYWR5LWV4aXN0aW5nIHJlZHVjZXIgJHtyZWR1Y2VyUGF0aH0gd2l0aG91dCBzcGVjaWZ5aW5nIFxcYG92ZXJyaWRlRXhpc3Rpbmc6IHRydWVcXGBgKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY29tYmluZWRSZWR1Y2VyO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbmZpZy5vdmVycmlkZUV4aXN0aW5nICYmIGN1cnJlbnRSZWR1Y2VyICE9PSByZWR1Y2VyVG9JbmplY3QpIHtcclxuICAgICAgZGVsZXRlIGluaXRpYWxTdGF0ZUNhY2hlW3JlZHVjZXJQYXRoXTtcclxuICAgIH1cclxuICAgIHJlZHVjZXJNYXBbcmVkdWNlclBhdGhdID0gcmVkdWNlclRvSW5qZWN0O1xyXG4gICAgcmVkdWNlciA9IGdldFJlZHVjZXIoKTtcclxuICAgIHJldHVybiBjb21iaW5lZFJlZHVjZXI7XHJcbiAgfTtcclxuICBjb25zdCBzZWxlY3RvciA9IE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gbWFrZVNlbGVjdG9yKHNlbGVjdG9yRm4sIHNlbGVjdFN0YXRlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gc2VsZWN0b3IyKHN0YXRlLCAuLi5hcmdzKSB7XHJcbiAgICAgIHJldHVybiBzZWxlY3RvckZuKGNyZWF0ZVN0YXRlUHJveHkoc2VsZWN0U3RhdGUgPyBzZWxlY3RTdGF0ZShzdGF0ZSwgLi4uYXJncykgOiBzdGF0ZSwgcmVkdWNlck1hcCwgaW5pdGlhbFN0YXRlQ2FjaGUpLCAuLi5hcmdzKTtcclxuICAgIH07XHJcbiAgfSwge1xyXG4gICAgb3JpZ2luYWxcclxuICB9KTtcclxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihjb21iaW5lZFJlZHVjZXIsIHtcclxuICAgIGluamVjdCxcclxuICAgIHNlbGVjdG9yXHJcbiAgfSk7XHJcbn1cclxuXHJcbi8vIHNyYy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLnRzXHJcbmZ1bmN0aW9uIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoY29kZSkge1xyXG4gIHJldHVybiBgTWluaWZpZWQgUmVkdXggVG9vbGtpdCBlcnJvciAjJHtjb2RlfTsgdmlzaXQgaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9FcnJvcnM/Y29kZT0ke2NvZGV9IGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMuIGA7XHJcbn1cclxuZXhwb3J0IHtcclxuICBSZWR1Y2VyVHlwZSxcclxuICBTSE9VTERfQVVUT0JBVENILFxyXG4gIFRhc2tBYm9ydEVycm9yLFxyXG4gIFR1cGxlLFxyXG4gIGFkZExpc3RlbmVyLFxyXG4gIGFzeW5jVGh1bmtDcmVhdG9yLFxyXG4gIGF1dG9CYXRjaEVuaGFuY2VyLFxyXG4gIGJ1aWxkQ3JlYXRlU2xpY2UsXHJcbiAgY2xlYXJBbGxMaXN0ZW5lcnMsXHJcbiAgY29tYmluZVNsaWNlcyxcclxuICBjb25maWd1cmVTdG9yZSxcclxuICBjcmVhdGVBY3Rpb24sXHJcbiAgY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUsXHJcbiAgY3JlYXRlQXN5bmNUaHVuayxcclxuICBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcixcclxuICBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3IsXHJcbiAgY3JlYXRlRHluYW1pY01pZGRsZXdhcmUsXHJcbiAgY3JlYXRlRW50aXR5QWRhcHRlcixcclxuICBjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsXHJcbiAgY3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlLFxyXG4gIHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlLFxyXG4gIGNyZWF0ZVJlZHVjZXIsXHJcbiAgY3JlYXRlU2VsZWN0b3IsXHJcbiAgY3JlYXRlU2VsZWN0b3JDcmVhdG9yMiBhcyBjcmVhdGVTZWxlY3RvckNyZWF0b3IsXHJcbiAgY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLFxyXG4gIGNyZWF0ZVNsaWNlLFxyXG4gIGN1cnJlbnQzIGFzIGN1cnJlbnQsXHJcbiAgZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlLFxyXG4gIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UsXHJcbiAgZnJlZXplLFxyXG4gIGlzQWN0aW9uQ3JlYXRvcixcclxuICBpc0FsbE9mLFxyXG4gIGlzQW55T2YsXHJcbiAgaXNBc3luY1RodW5rQWN0aW9uLFxyXG4gIGlzRHJhZnQ1IGFzIGlzRHJhZnQsXHJcbiAgaXNGU0EgYXMgaXNGbHV4U3RhbmRhcmRBY3Rpb24sXHJcbiAgaXNGdWxmaWxsZWQsXHJcbiAgaXNJbW11dGFibGVEZWZhdWx0LFxyXG4gIGlzUGVuZGluZyxcclxuICBpc1BsYWluLFxyXG4gIGlzUmVqZWN0ZWQsXHJcbiAgaXNSZWplY3RlZFdpdGhWYWx1ZSxcclxuICBscnVNZW1vaXplLFxyXG4gIG1pbmlTZXJpYWxpemVFcnJvcixcclxuICBuYW5vaWQsXHJcbiAgb3JpZ2luYWwyIGFzIG9yaWdpbmFsLFxyXG4gIHByZXBhcmVBdXRvQmF0Y2hlZCxcclxuICByZW1vdmVMaXN0ZW5lcixcclxuICB1bndyYXBSZXN1bHQsXHJcbiAgd2Vha01hcE1lbW9pemUyIGFzIHdlYWtNYXBNZW1vaXplXHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHV4LXRvb2xraXQubW9kZXJuLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\n");

/***/ })

};
;