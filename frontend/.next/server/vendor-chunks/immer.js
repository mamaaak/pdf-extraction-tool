"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/immer";
exports.ids = ["vendor-chunks/immer"];
exports.modules = {

/***/ "(ssr)/./node_modules/immer/dist/immer.mjs":
/*!*******************************************!*\
  !*** ./node_modules/immer/dist/immer.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Immer: () => (/* binding */ Immer2),\n/* harmony export */   applyPatches: () => (/* binding */ applyPatches),\n/* harmony export */   castDraft: () => (/* binding */ castDraft),\n/* harmony export */   castImmutable: () => (/* binding */ castImmutable),\n/* harmony export */   createDraft: () => (/* binding */ createDraft),\n/* harmony export */   current: () => (/* binding */ current),\n/* harmony export */   enableMapSet: () => (/* binding */ enableMapSet),\n/* harmony export */   enablePatches: () => (/* binding */ enablePatches),\n/* harmony export */   finishDraft: () => (/* binding */ finishDraft),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   immerable: () => (/* binding */ DRAFTABLE),\n/* harmony export */   isDraft: () => (/* binding */ isDraft),\n/* harmony export */   isDraftable: () => (/* binding */ isDraftable),\n/* harmony export */   nothing: () => (/* binding */ NOTHING),\n/* harmony export */   original: () => (/* binding */ original),\n/* harmony export */   produce: () => (/* binding */ produce),\n/* harmony export */   produceWithPatches: () => (/* binding */ produceWithPatches),\n/* harmony export */   setAutoFreeze: () => (/* binding */ setAutoFreeze),\n/* harmony export */   setUseStrictShallowCopy: () => (/* binding */ setUseStrictShallowCopy)\n/* harmony export */ });\n// src/utils/env.ts\r\nvar NOTHING = Symbol.for(\"immer-nothing\");\r\nvar DRAFTABLE = Symbol.for(\"immer-draftable\");\r\nvar DRAFT_STATE = Symbol.for(\"immer-state\");\r\n\r\n// src/utils/errors.ts\r\nvar errors =  true ? [\r\n  // All error codes, starting by 0:\r\n  function(plugin) {\r\n    return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`;\r\n  },\r\n  function(thing) {\r\n    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;\r\n  },\r\n  \"This object has been frozen and should not be mutated\",\r\n  function(data) {\r\n    return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\r\n  },\r\n  \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\r\n  \"Immer forbids circular references\",\r\n  \"The first or second argument to `produce` must be a function\",\r\n  \"The third argument to `produce` must be a function or undefined\",\r\n  \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\r\n  \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\r\n  function(thing) {\r\n    return `'current' expects a draft, got: ${thing}`;\r\n  },\r\n  \"Object.defineProperty() cannot be used on an Immer draft\",\r\n  \"Object.setPrototypeOf() cannot be used on an Immer draft\",\r\n  \"Immer only supports deleting array indices\",\r\n  \"Immer only supports setting array indices and the 'length' property\",\r\n  function(thing) {\r\n    return `'original' expects a draft, got: ${thing}`;\r\n  }\r\n  // Note: if more errors are added, the errorOffset in Patches.ts should be increased\r\n  // See Patches.ts for additional errors\r\n] : 0;\r\nfunction die(error, ...args) {\r\n  if (true) {\r\n    const e = errors[error];\r\n    const msg = typeof e === \"function\" ? e.apply(null, args) : e;\r\n    throw new Error(`[Immer] ${msg}`);\r\n  }\r\n  throw new Error(\r\n    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\r\n  );\r\n}\r\n\r\n// src/utils/common.ts\r\nvar getPrototypeOf = Object.getPrototypeOf;\r\nfunction isDraft(value) {\r\n  return !!value && !!value[DRAFT_STATE];\r\n}\r\nfunction isDraftable(value) {\r\n  if (!value)\r\n    return false;\r\n  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);\r\n}\r\nvar objectCtorString = Object.prototype.constructor.toString();\r\nfunction isPlainObject(value) {\r\n  if (!value || typeof value !== \"object\")\r\n    return false;\r\n  const proto = getPrototypeOf(value);\r\n  if (proto === null) {\r\n    return true;\r\n  }\r\n  const Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\r\n  if (Ctor === Object)\r\n    return true;\r\n  return typeof Ctor == \"function\" && Function.toString.call(Ctor) === objectCtorString;\r\n}\r\nfunction original(value) {\r\n  if (!isDraft(value))\r\n    die(15, value);\r\n  return value[DRAFT_STATE].base_;\r\n}\r\nfunction each(obj, iter) {\r\n  if (getArchtype(obj) === 0 /* Object */) {\r\n    Reflect.ownKeys(obj).forEach((key) => {\r\n      iter(key, obj[key], obj);\r\n    });\r\n  } else {\r\n    obj.forEach((entry, index) => iter(index, entry, obj));\r\n  }\r\n}\r\nfunction getArchtype(thing) {\r\n  const state = thing[DRAFT_STATE];\r\n  return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */ : isMap(thing) ? 2 /* Map */ : isSet(thing) ? 3 /* Set */ : 0 /* Object */;\r\n}\r\nfunction has(thing, prop) {\r\n  return getArchtype(thing) === 2 /* Map */ ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\r\n}\r\nfunction get(thing, prop) {\r\n  return getArchtype(thing) === 2 /* Map */ ? thing.get(prop) : thing[prop];\r\n}\r\nfunction set(thing, propOrOldValue, value) {\r\n  const t = getArchtype(thing);\r\n  if (t === 2 /* Map */)\r\n    thing.set(propOrOldValue, value);\r\n  else if (t === 3 /* Set */) {\r\n    thing.add(value);\r\n  } else\r\n    thing[propOrOldValue] = value;\r\n}\r\nfunction is(x, y) {\r\n  if (x === y) {\r\n    return x !== 0 || 1 / x === 1 / y;\r\n  } else {\r\n    return x !== x && y !== y;\r\n  }\r\n}\r\nfunction isMap(target) {\r\n  return target instanceof Map;\r\n}\r\nfunction isSet(target) {\r\n  return target instanceof Set;\r\n}\r\nfunction latest(state) {\r\n  return state.copy_ || state.base_;\r\n}\r\nfunction shallowCopy(base, strict) {\r\n  if (isMap(base)) {\r\n    return new Map(base);\r\n  }\r\n  if (isSet(base)) {\r\n    return new Set(base);\r\n  }\r\n  if (Array.isArray(base))\r\n    return Array.prototype.slice.call(base);\r\n  const isPlain = isPlainObject(base);\r\n  if (strict === true || strict === \"class_only\" && !isPlain) {\r\n    const descriptors = Object.getOwnPropertyDescriptors(base);\r\n    delete descriptors[DRAFT_STATE];\r\n    let keys = Reflect.ownKeys(descriptors);\r\n    for (let i = 0; i < keys.length; i++) {\r\n      const key = keys[i];\r\n      const desc = descriptors[key];\r\n      if (desc.writable === false) {\r\n        desc.writable = true;\r\n        desc.configurable = true;\r\n      }\r\n      if (desc.get || desc.set)\r\n        descriptors[key] = {\r\n          configurable: true,\r\n          writable: true,\r\n          // could live with !!desc.set as well here...\r\n          enumerable: desc.enumerable,\r\n          value: base[key]\r\n        };\r\n    }\r\n    return Object.create(getPrototypeOf(base), descriptors);\r\n  } else {\r\n    const proto = getPrototypeOf(base);\r\n    if (proto !== null && isPlain) {\r\n      return { ...base };\r\n    }\r\n    const obj = Object.create(proto);\r\n    return Object.assign(obj, base);\r\n  }\r\n}\r\nfunction freeze(obj, deep = false) {\r\n  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))\r\n    return obj;\r\n  if (getArchtype(obj) > 1) {\r\n    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\r\n  }\r\n  Object.freeze(obj);\r\n  if (deep)\r\n    Object.entries(obj).forEach(([key, value]) => freeze(value, true));\r\n  return obj;\r\n}\r\nfunction dontMutateFrozenCollections() {\r\n  die(2);\r\n}\r\nfunction isFrozen(obj) {\r\n  return Object.isFrozen(obj);\r\n}\r\n\r\n// src/utils/plugins.ts\r\nvar plugins = {};\r\nfunction getPlugin(pluginKey) {\r\n  const plugin = plugins[pluginKey];\r\n  if (!plugin) {\r\n    die(0, pluginKey);\r\n  }\r\n  return plugin;\r\n}\r\nfunction loadPlugin(pluginKey, implementation) {\r\n  if (!plugins[pluginKey])\r\n    plugins[pluginKey] = implementation;\r\n}\r\n\r\n// src/core/scope.ts\r\nvar currentScope;\r\nfunction getCurrentScope() {\r\n  return currentScope;\r\n}\r\nfunction createScope(parent_, immer_) {\r\n  return {\r\n    drafts_: [],\r\n    parent_,\r\n    immer_,\r\n    // Whenever the modified draft contains a draft from another scope, we\r\n    // need to prevent auto-freezing so the unowned draft can be finalized.\r\n    canAutoFreeze_: true,\r\n    unfinalizedDrafts_: 0\r\n  };\r\n}\r\nfunction usePatchesInScope(scope, patchListener) {\r\n  if (patchListener) {\r\n    getPlugin(\"Patches\");\r\n    scope.patches_ = [];\r\n    scope.inversePatches_ = [];\r\n    scope.patchListener_ = patchListener;\r\n  }\r\n}\r\nfunction revokeScope(scope) {\r\n  leaveScope(scope);\r\n  scope.drafts_.forEach(revokeDraft);\r\n  scope.drafts_ = null;\r\n}\r\nfunction leaveScope(scope) {\r\n  if (scope === currentScope) {\r\n    currentScope = scope.parent_;\r\n  }\r\n}\r\nfunction enterScope(immer2) {\r\n  return currentScope = createScope(currentScope, immer2);\r\n}\r\nfunction revokeDraft(draft) {\r\n  const state = draft[DRAFT_STATE];\r\n  if (state.type_ === 0 /* Object */ || state.type_ === 1 /* Array */)\r\n    state.revoke_();\r\n  else\r\n    state.revoked_ = true;\r\n}\r\n\r\n// src/core/finalize.ts\r\nfunction processResult(result, scope) {\r\n  scope.unfinalizedDrafts_ = scope.drafts_.length;\r\n  const baseDraft = scope.drafts_[0];\r\n  const isReplaced = result !== void 0 && result !== baseDraft;\r\n  if (isReplaced) {\r\n    if (baseDraft[DRAFT_STATE].modified_) {\r\n      revokeScope(scope);\r\n      die(4);\r\n    }\r\n    if (isDraftable(result)) {\r\n      result = finalize(scope, result);\r\n      if (!scope.parent_)\r\n        maybeFreeze(scope, result);\r\n    }\r\n    if (scope.patches_) {\r\n      getPlugin(\"Patches\").generateReplacementPatches_(\r\n        baseDraft[DRAFT_STATE].base_,\r\n        result,\r\n        scope.patches_,\r\n        scope.inversePatches_\r\n      );\r\n    }\r\n  } else {\r\n    result = finalize(scope, baseDraft, []);\r\n  }\r\n  revokeScope(scope);\r\n  if (scope.patches_) {\r\n    scope.patchListener_(scope.patches_, scope.inversePatches_);\r\n  }\r\n  return result !== NOTHING ? result : void 0;\r\n}\r\nfunction finalize(rootScope, value, path) {\r\n  if (isFrozen(value))\r\n    return value;\r\n  const state = value[DRAFT_STATE];\r\n  if (!state) {\r\n    each(\r\n      value,\r\n      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)\r\n    );\r\n    return value;\r\n  }\r\n  if (state.scope_ !== rootScope)\r\n    return value;\r\n  if (!state.modified_) {\r\n    maybeFreeze(rootScope, state.base_, true);\r\n    return state.base_;\r\n  }\r\n  if (!state.finalized_) {\r\n    state.finalized_ = true;\r\n    state.scope_.unfinalizedDrafts_--;\r\n    const result = state.copy_;\r\n    let resultEach = result;\r\n    let isSet2 = false;\r\n    if (state.type_ === 3 /* Set */) {\r\n      resultEach = new Set(result);\r\n      result.clear();\r\n      isSet2 = true;\r\n    }\r\n    each(\r\n      resultEach,\r\n      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)\r\n    );\r\n    maybeFreeze(rootScope, result, false);\r\n    if (path && rootScope.patches_) {\r\n      getPlugin(\"Patches\").generatePatches_(\r\n        state,\r\n        path,\r\n        rootScope.patches_,\r\n        rootScope.inversePatches_\r\n      );\r\n    }\r\n  }\r\n  return state.copy_;\r\n}\r\nfunction finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {\r\n  if ( true && childValue === targetObject)\r\n    die(5);\r\n  if (isDraft(childValue)) {\r\n    const path = rootPath && parentState && parentState.type_ !== 3 /* Set */ && // Set objects are atomic since they have no keys.\r\n    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;\r\n    const res = finalize(rootScope, childValue, path);\r\n    set(targetObject, prop, res);\r\n    if (isDraft(res)) {\r\n      rootScope.canAutoFreeze_ = false;\r\n    } else\r\n      return;\r\n  } else if (targetIsSet) {\r\n    targetObject.add(childValue);\r\n  }\r\n  if (isDraftable(childValue) && !isFrozen(childValue)) {\r\n    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\r\n      return;\r\n    }\r\n    finalize(rootScope, childValue);\r\n    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== \"symbol\" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))\r\n      maybeFreeze(rootScope, childValue);\r\n  }\r\n}\r\nfunction maybeFreeze(scope, value, deep = false) {\r\n  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\r\n    freeze(value, deep);\r\n  }\r\n}\r\n\r\n// src/core/proxy.ts\r\nfunction createProxyProxy(base, parent) {\r\n  const isArray = Array.isArray(base);\r\n  const state = {\r\n    type_: isArray ? 1 /* Array */ : 0 /* Object */,\r\n    // Track which produce call this is associated with.\r\n    scope_: parent ? parent.scope_ : getCurrentScope(),\r\n    // True for both shallow and deep changes.\r\n    modified_: false,\r\n    // Used during finalization.\r\n    finalized_: false,\r\n    // Track which properties have been assigned (true) or deleted (false).\r\n    assigned_: {},\r\n    // The parent draft state.\r\n    parent_: parent,\r\n    // The base state.\r\n    base_: base,\r\n    // The base proxy.\r\n    draft_: null,\r\n    // set below\r\n    // The base copy with any updated values.\r\n    copy_: null,\r\n    // Called by the `produce` function.\r\n    revoke_: null,\r\n    isManual_: false\r\n  };\r\n  let target = state;\r\n  let traps = objectTraps;\r\n  if (isArray) {\r\n    target = [state];\r\n    traps = arrayTraps;\r\n  }\r\n  const { revoke, proxy } = Proxy.revocable(target, traps);\r\n  state.draft_ = proxy;\r\n  state.revoke_ = revoke;\r\n  return proxy;\r\n}\r\nvar objectTraps = {\r\n  get(state, prop) {\r\n    if (prop === DRAFT_STATE)\r\n      return state;\r\n    const source = latest(state);\r\n    if (!has(source, prop)) {\r\n      return readPropFromProto(state, source, prop);\r\n    }\r\n    const value = source[prop];\r\n    if (state.finalized_ || !isDraftable(value)) {\r\n      return value;\r\n    }\r\n    if (value === peek(state.base_, prop)) {\r\n      prepareCopy(state);\r\n      return state.copy_[prop] = createProxy(value, state);\r\n    }\r\n    return value;\r\n  },\r\n  has(state, prop) {\r\n    return prop in latest(state);\r\n  },\r\n  ownKeys(state) {\r\n    return Reflect.ownKeys(latest(state));\r\n  },\r\n  set(state, prop, value) {\r\n    const desc = getDescriptorFromProto(latest(state), prop);\r\n    if (desc?.set) {\r\n      desc.set.call(state.draft_, value);\r\n      return true;\r\n    }\r\n    if (!state.modified_) {\r\n      const current2 = peek(latest(state), prop);\r\n      const currentState = current2?.[DRAFT_STATE];\r\n      if (currentState && currentState.base_ === value) {\r\n        state.copy_[prop] = value;\r\n        state.assigned_[prop] = false;\r\n        return true;\r\n      }\r\n      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))\r\n        return true;\r\n      prepareCopy(state);\r\n      markChanged(state);\r\n    }\r\n    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'\r\n    (value !== void 0 || prop in state.copy_) || // special case: NaN\r\n    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))\r\n      return true;\r\n    state.copy_[prop] = value;\r\n    state.assigned_[prop] = true;\r\n    return true;\r\n  },\r\n  deleteProperty(state, prop) {\r\n    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {\r\n      state.assigned_[prop] = false;\r\n      prepareCopy(state);\r\n      markChanged(state);\r\n    } else {\r\n      delete state.assigned_[prop];\r\n    }\r\n    if (state.copy_) {\r\n      delete state.copy_[prop];\r\n    }\r\n    return true;\r\n  },\r\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\r\n  // the same guarantee in ES5 mode.\r\n  getOwnPropertyDescriptor(state, prop) {\r\n    const owner = latest(state);\r\n    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);\r\n    if (!desc)\r\n      return desc;\r\n    return {\r\n      writable: true,\r\n      configurable: state.type_ !== 1 /* Array */ || prop !== \"length\",\r\n      enumerable: desc.enumerable,\r\n      value: owner[prop]\r\n    };\r\n  },\r\n  defineProperty() {\r\n    die(11);\r\n  },\r\n  getPrototypeOf(state) {\r\n    return getPrototypeOf(state.base_);\r\n  },\r\n  setPrototypeOf() {\r\n    die(12);\r\n  }\r\n};\r\nvar arrayTraps = {};\r\neach(objectTraps, (key, fn) => {\r\n  arrayTraps[key] = function() {\r\n    arguments[0] = arguments[0][0];\r\n    return fn.apply(this, arguments);\r\n  };\r\n});\r\narrayTraps.deleteProperty = function(state, prop) {\r\n  if ( true && isNaN(parseInt(prop)))\r\n    die(13);\r\n  return arrayTraps.set.call(this, state, prop, void 0);\r\n};\r\narrayTraps.set = function(state, prop, value) {\r\n  if ( true && prop !== \"length\" && isNaN(parseInt(prop)))\r\n    die(14);\r\n  return objectTraps.set.call(this, state[0], prop, value, state[0]);\r\n};\r\nfunction peek(draft, prop) {\r\n  const state = draft[DRAFT_STATE];\r\n  const source = state ? latest(state) : draft;\r\n  return source[prop];\r\n}\r\nfunction readPropFromProto(state, source, prop) {\r\n  const desc = getDescriptorFromProto(source, prop);\r\n  return desc ? `value` in desc ? desc.value : (\r\n    // This is a very special case, if the prop is a getter defined by the\r\n    // prototype, we should invoke it with the draft as context!\r\n    desc.get?.call(state.draft_)\r\n  ) : void 0;\r\n}\r\nfunction getDescriptorFromProto(source, prop) {\r\n  if (!(prop in source))\r\n    return void 0;\r\n  let proto = getPrototypeOf(source);\r\n  while (proto) {\r\n    const desc = Object.getOwnPropertyDescriptor(proto, prop);\r\n    if (desc)\r\n      return desc;\r\n    proto = getPrototypeOf(proto);\r\n  }\r\n  return void 0;\r\n}\r\nfunction markChanged(state) {\r\n  if (!state.modified_) {\r\n    state.modified_ = true;\r\n    if (state.parent_) {\r\n      markChanged(state.parent_);\r\n    }\r\n  }\r\n}\r\nfunction prepareCopy(state) {\r\n  if (!state.copy_) {\r\n    state.copy_ = shallowCopy(\r\n      state.base_,\r\n      state.scope_.immer_.useStrictShallowCopy_\r\n    );\r\n  }\r\n}\r\n\r\n// src/core/immerClass.ts\r\nvar Immer2 = class {\r\n  constructor(config) {\r\n    this.autoFreeze_ = true;\r\n    this.useStrictShallowCopy_ = false;\r\n    /**\r\n     * The `produce` function takes a value and a \"recipe function\" (whose\r\n     * return value often depends on the base state). The recipe function is\r\n     * free to mutate its first argument however it wants. All mutations are\r\n     * only ever applied to a __copy__ of the base state.\r\n     *\r\n     * Pass only a function to create a \"curried producer\" which relieves you\r\n     * from passing the recipe function every time.\r\n     *\r\n     * Only plain objects and arrays are made mutable. All other objects are\r\n     * considered uncopyable.\r\n     *\r\n     * Note: This function is __bound__ to its `Immer` instance.\r\n     *\r\n     * @param {any} base - the initial state\r\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\r\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n     * @returns {any} a new state, or the initial state if nothing was modified\r\n     */\r\n    this.produce = (base, recipe, patchListener) => {\r\n      if (typeof base === \"function\" && typeof recipe !== \"function\") {\r\n        const defaultBase = recipe;\r\n        recipe = base;\r\n        const self = this;\r\n        return function curriedProduce(base2 = defaultBase, ...args) {\r\n          return self.produce(base2, (draft) => recipe.call(this, draft, ...args));\r\n        };\r\n      }\r\n      if (typeof recipe !== \"function\")\r\n        die(6);\r\n      if (patchListener !== void 0 && typeof patchListener !== \"function\")\r\n        die(7);\r\n      let result;\r\n      if (isDraftable(base)) {\r\n        const scope = enterScope(this);\r\n        const proxy = createProxy(base, void 0);\r\n        let hasError = true;\r\n        try {\r\n          result = recipe(proxy);\r\n          hasError = false;\r\n        } finally {\r\n          if (hasError)\r\n            revokeScope(scope);\r\n          else\r\n            leaveScope(scope);\r\n        }\r\n        usePatchesInScope(scope, patchListener);\r\n        return processResult(result, scope);\r\n      } else if (!base || typeof base !== \"object\") {\r\n        result = recipe(base);\r\n        if (result === void 0)\r\n          result = base;\r\n        if (result === NOTHING)\r\n          result = void 0;\r\n        if (this.autoFreeze_)\r\n          freeze(result, true);\r\n        if (patchListener) {\r\n          const p = [];\r\n          const ip = [];\r\n          getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\r\n          patchListener(p, ip);\r\n        }\r\n        return result;\r\n      } else\r\n        die(1, base);\r\n    };\r\n    this.produceWithPatches = (base, recipe) => {\r\n      if (typeof base === \"function\") {\r\n        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));\r\n      }\r\n      let patches, inversePatches;\r\n      const result = this.produce(base, recipe, (p, ip) => {\r\n        patches = p;\r\n        inversePatches = ip;\r\n      });\r\n      return [result, patches, inversePatches];\r\n    };\r\n    if (typeof config?.autoFreeze === \"boolean\")\r\n      this.setAutoFreeze(config.autoFreeze);\r\n    if (typeof config?.useStrictShallowCopy === \"boolean\")\r\n      this.setUseStrictShallowCopy(config.useStrictShallowCopy);\r\n  }\r\n  createDraft(base) {\r\n    if (!isDraftable(base))\r\n      die(8);\r\n    if (isDraft(base))\r\n      base = current(base);\r\n    const scope = enterScope(this);\r\n    const proxy = createProxy(base, void 0);\r\n    proxy[DRAFT_STATE].isManual_ = true;\r\n    leaveScope(scope);\r\n    return proxy;\r\n  }\r\n  finishDraft(draft, patchListener) {\r\n    const state = draft && draft[DRAFT_STATE];\r\n    if (!state || !state.isManual_)\r\n      die(9);\r\n    const { scope_: scope } = state;\r\n    usePatchesInScope(scope, patchListener);\r\n    return processResult(void 0, scope);\r\n  }\r\n  /**\r\n   * Pass true to automatically freeze all copies created by Immer.\r\n   *\r\n   * By default, auto-freezing is enabled.\r\n   */\r\n  setAutoFreeze(value) {\r\n    this.autoFreeze_ = value;\r\n  }\r\n  /**\r\n   * Pass true to enable strict shallow copy.\r\n   *\r\n   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\r\n   */\r\n  setUseStrictShallowCopy(value) {\r\n    this.useStrictShallowCopy_ = value;\r\n  }\r\n  applyPatches(base, patches) {\r\n    let i;\r\n    for (i = patches.length - 1; i >= 0; i--) {\r\n      const patch = patches[i];\r\n      if (patch.path.length === 0 && patch.op === \"replace\") {\r\n        base = patch.value;\r\n        break;\r\n      }\r\n    }\r\n    if (i > -1) {\r\n      patches = patches.slice(i + 1);\r\n    }\r\n    const applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\r\n    if (isDraft(base)) {\r\n      return applyPatchesImpl(base, patches);\r\n    }\r\n    return this.produce(\r\n      base,\r\n      (draft) => applyPatchesImpl(draft, patches)\r\n    );\r\n  }\r\n};\r\nfunction createProxy(value, parent) {\r\n  const draft = isMap(value) ? getPlugin(\"MapSet\").proxyMap_(value, parent) : isSet(value) ? getPlugin(\"MapSet\").proxySet_(value, parent) : createProxyProxy(value, parent);\r\n  const scope = parent ? parent.scope_ : getCurrentScope();\r\n  scope.drafts_.push(draft);\r\n  return draft;\r\n}\r\n\r\n// src/core/current.ts\r\nfunction current(value) {\r\n  if (!isDraft(value))\r\n    die(10, value);\r\n  return currentImpl(value);\r\n}\r\nfunction currentImpl(value) {\r\n  if (!isDraftable(value) || isFrozen(value))\r\n    return value;\r\n  const state = value[DRAFT_STATE];\r\n  let copy;\r\n  if (state) {\r\n    if (!state.modified_)\r\n      return state.base_;\r\n    state.finalized_ = true;\r\n    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);\r\n  } else {\r\n    copy = shallowCopy(value, true);\r\n  }\r\n  each(copy, (key, childValue) => {\r\n    set(copy, key, currentImpl(childValue));\r\n  });\r\n  if (state) {\r\n    state.finalized_ = false;\r\n  }\r\n  return copy;\r\n}\r\n\r\n// src/plugins/patches.ts\r\nfunction enablePatches() {\r\n  const errorOffset = 16;\r\n  if (true) {\r\n    errors.push(\r\n      'Sets cannot have \"replace\" patches.',\r\n      function(op) {\r\n        return \"Unsupported patch operation: \" + op;\r\n      },\r\n      function(path) {\r\n        return \"Cannot apply patch, path doesn't resolve: \" + path;\r\n      },\r\n      \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\r\n    );\r\n  }\r\n  const REPLACE = \"replace\";\r\n  const ADD = \"add\";\r\n  const REMOVE = \"remove\";\r\n  function generatePatches_(state, basePath, patches, inversePatches) {\r\n    switch (state.type_) {\r\n      case 0 /* Object */:\r\n      case 2 /* Map */:\r\n        return generatePatchesFromAssigned(\r\n          state,\r\n          basePath,\r\n          patches,\r\n          inversePatches\r\n        );\r\n      case 1 /* Array */:\r\n        return generateArrayPatches(state, basePath, patches, inversePatches);\r\n      case 3 /* Set */:\r\n        return generateSetPatches(\r\n          state,\r\n          basePath,\r\n          patches,\r\n          inversePatches\r\n        );\r\n    }\r\n  }\r\n  function generateArrayPatches(state, basePath, patches, inversePatches) {\r\n    let { base_, assigned_ } = state;\r\n    let copy_ = state.copy_;\r\n    if (copy_.length < base_.length) {\r\n      ;\r\n      [base_, copy_] = [copy_, base_];\r\n      [patches, inversePatches] = [inversePatches, patches];\r\n    }\r\n    for (let i = 0; i < base_.length; i++) {\r\n      if (assigned_[i] && copy_[i] !== base_[i]) {\r\n        const path = basePath.concat([i]);\r\n        patches.push({\r\n          op: REPLACE,\r\n          path,\r\n          // Need to maybe clone it, as it can in fact be the original value\r\n          // due to the base/copy inversion at the start of this function\r\n          value: clonePatchValueIfNeeded(copy_[i])\r\n        });\r\n        inversePatches.push({\r\n          op: REPLACE,\r\n          path,\r\n          value: clonePatchValueIfNeeded(base_[i])\r\n        });\r\n      }\r\n    }\r\n    for (let i = base_.length; i < copy_.length; i++) {\r\n      const path = basePath.concat([i]);\r\n      patches.push({\r\n        op: ADD,\r\n        path,\r\n        // Need to maybe clone it, as it can in fact be the original value\r\n        // due to the base/copy inversion at the start of this function\r\n        value: clonePatchValueIfNeeded(copy_[i])\r\n      });\r\n    }\r\n    for (let i = copy_.length - 1; base_.length <= i; --i) {\r\n      const path = basePath.concat([i]);\r\n      inversePatches.push({\r\n        op: REMOVE,\r\n        path\r\n      });\r\n    }\r\n  }\r\n  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\r\n    const { base_, copy_ } = state;\r\n    each(state.assigned_, (key, assignedValue) => {\r\n      const origValue = get(base_, key);\r\n      const value = get(copy_, key);\r\n      const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\r\n      if (origValue === value && op === REPLACE)\r\n        return;\r\n      const path = basePath.concat(key);\r\n      patches.push(op === REMOVE ? { op, path } : { op, path, value });\r\n      inversePatches.push(\r\n        op === ADD ? { op: REMOVE, path } : op === REMOVE ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) } : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) }\r\n      );\r\n    });\r\n  }\r\n  function generateSetPatches(state, basePath, patches, inversePatches) {\r\n    let { base_, copy_ } = state;\r\n    let i = 0;\r\n    base_.forEach((value) => {\r\n      if (!copy_.has(value)) {\r\n        const path = basePath.concat([i]);\r\n        patches.push({\r\n          op: REMOVE,\r\n          path,\r\n          value\r\n        });\r\n        inversePatches.unshift({\r\n          op: ADD,\r\n          path,\r\n          value\r\n        });\r\n      }\r\n      i++;\r\n    });\r\n    i = 0;\r\n    copy_.forEach((value) => {\r\n      if (!base_.has(value)) {\r\n        const path = basePath.concat([i]);\r\n        patches.push({\r\n          op: ADD,\r\n          path,\r\n          value\r\n        });\r\n        inversePatches.unshift({\r\n          op: REMOVE,\r\n          path,\r\n          value\r\n        });\r\n      }\r\n      i++;\r\n    });\r\n  }\r\n  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {\r\n    patches.push({\r\n      op: REPLACE,\r\n      path: [],\r\n      value: replacement === NOTHING ? void 0 : replacement\r\n    });\r\n    inversePatches.push({\r\n      op: REPLACE,\r\n      path: [],\r\n      value: baseValue\r\n    });\r\n  }\r\n  function applyPatches_(draft, patches) {\r\n    patches.forEach((patch) => {\r\n      const { path, op } = patch;\r\n      let base = draft;\r\n      for (let i = 0; i < path.length - 1; i++) {\r\n        const parentType = getArchtype(base);\r\n        let p = path[i];\r\n        if (typeof p !== \"string\" && typeof p !== \"number\") {\r\n          p = \"\" + p;\r\n        }\r\n        if ((parentType === 0 /* Object */ || parentType === 1 /* Array */) && (p === \"__proto__\" || p === \"constructor\"))\r\n          die(errorOffset + 3);\r\n        if (typeof base === \"function\" && p === \"prototype\")\r\n          die(errorOffset + 3);\r\n        base = get(base, p);\r\n        if (typeof base !== \"object\")\r\n          die(errorOffset + 2, path.join(\"/\"));\r\n      }\r\n      const type = getArchtype(base);\r\n      const value = deepClonePatchValue(patch.value);\r\n      const key = path[path.length - 1];\r\n      switch (op) {\r\n        case REPLACE:\r\n          switch (type) {\r\n            case 2 /* Map */:\r\n              return base.set(key, value);\r\n            case 3 /* Set */:\r\n              die(errorOffset);\r\n            default:\r\n              return base[key] = value;\r\n          }\r\n        case ADD:\r\n          switch (type) {\r\n            case 1 /* Array */:\r\n              return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\r\n            case 2 /* Map */:\r\n              return base.set(key, value);\r\n            case 3 /* Set */:\r\n              return base.add(value);\r\n            default:\r\n              return base[key] = value;\r\n          }\r\n        case REMOVE:\r\n          switch (type) {\r\n            case 1 /* Array */:\r\n              return base.splice(key, 1);\r\n            case 2 /* Map */:\r\n              return base.delete(key);\r\n            case 3 /* Set */:\r\n              return base.delete(patch.value);\r\n            default:\r\n              return delete base[key];\r\n          }\r\n        default:\r\n          die(errorOffset + 1, op);\r\n      }\r\n    });\r\n    return draft;\r\n  }\r\n  function deepClonePatchValue(obj) {\r\n    if (!isDraftable(obj))\r\n      return obj;\r\n    if (Array.isArray(obj))\r\n      return obj.map(deepClonePatchValue);\r\n    if (isMap(obj))\r\n      return new Map(\r\n        Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\r\n      );\r\n    if (isSet(obj))\r\n      return new Set(Array.from(obj).map(deepClonePatchValue));\r\n    const cloned = Object.create(getPrototypeOf(obj));\r\n    for (const key in obj)\r\n      cloned[key] = deepClonePatchValue(obj[key]);\r\n    if (has(obj, DRAFTABLE))\r\n      cloned[DRAFTABLE] = obj[DRAFTABLE];\r\n    return cloned;\r\n  }\r\n  function clonePatchValueIfNeeded(obj) {\r\n    if (isDraft(obj)) {\r\n      return deepClonePatchValue(obj);\r\n    } else\r\n      return obj;\r\n  }\r\n  loadPlugin(\"Patches\", {\r\n    applyPatches_,\r\n    generatePatches_,\r\n    generateReplacementPatches_\r\n  });\r\n}\r\n\r\n// src/plugins/mapset.ts\r\nfunction enableMapSet() {\r\n  class DraftMap extends Map {\r\n    constructor(target, parent) {\r\n      super();\r\n      this[DRAFT_STATE] = {\r\n        type_: 2 /* Map */,\r\n        parent_: parent,\r\n        scope_: parent ? parent.scope_ : getCurrentScope(),\r\n        modified_: false,\r\n        finalized_: false,\r\n        copy_: void 0,\r\n        assigned_: void 0,\r\n        base_: target,\r\n        draft_: this,\r\n        isManual_: false,\r\n        revoked_: false\r\n      };\r\n    }\r\n    get size() {\r\n      return latest(this[DRAFT_STATE]).size;\r\n    }\r\n    has(key) {\r\n      return latest(this[DRAFT_STATE]).has(key);\r\n    }\r\n    set(key, value) {\r\n      const state = this[DRAFT_STATE];\r\n      assertUnrevoked(state);\r\n      if (!latest(state).has(key) || latest(state).get(key) !== value) {\r\n        prepareMapCopy(state);\r\n        markChanged(state);\r\n        state.assigned_.set(key, true);\r\n        state.copy_.set(key, value);\r\n        state.assigned_.set(key, true);\r\n      }\r\n      return this;\r\n    }\r\n    delete(key) {\r\n      if (!this.has(key)) {\r\n        return false;\r\n      }\r\n      const state = this[DRAFT_STATE];\r\n      assertUnrevoked(state);\r\n      prepareMapCopy(state);\r\n      markChanged(state);\r\n      if (state.base_.has(key)) {\r\n        state.assigned_.set(key, false);\r\n      } else {\r\n        state.assigned_.delete(key);\r\n      }\r\n      state.copy_.delete(key);\r\n      return true;\r\n    }\r\n    clear() {\r\n      const state = this[DRAFT_STATE];\r\n      assertUnrevoked(state);\r\n      if (latest(state).size) {\r\n        prepareMapCopy(state);\r\n        markChanged(state);\r\n        state.assigned_ = /* @__PURE__ */ new Map();\r\n        each(state.base_, (key) => {\r\n          state.assigned_.set(key, false);\r\n        });\r\n        state.copy_.clear();\r\n      }\r\n    }\r\n    forEach(cb, thisArg) {\r\n      const state = this[DRAFT_STATE];\r\n      latest(state).forEach((_value, key, _map) => {\r\n        cb.call(thisArg, this.get(key), key, this);\r\n      });\r\n    }\r\n    get(key) {\r\n      const state = this[DRAFT_STATE];\r\n      assertUnrevoked(state);\r\n      const value = latest(state).get(key);\r\n      if (state.finalized_ || !isDraftable(value)) {\r\n        return value;\r\n      }\r\n      if (value !== state.base_.get(key)) {\r\n        return value;\r\n      }\r\n      const draft = createProxy(value, state);\r\n      prepareMapCopy(state);\r\n      state.copy_.set(key, draft);\r\n      return draft;\r\n    }\r\n    keys() {\r\n      return latest(this[DRAFT_STATE]).keys();\r\n    }\r\n    values() {\r\n      const iterator = this.keys();\r\n      return {\r\n        [Symbol.iterator]: () => this.values(),\r\n        next: () => {\r\n          const r = iterator.next();\r\n          if (r.done)\r\n            return r;\r\n          const value = this.get(r.value);\r\n          return {\r\n            done: false,\r\n            value\r\n          };\r\n        }\r\n      };\r\n    }\r\n    entries() {\r\n      const iterator = this.keys();\r\n      return {\r\n        [Symbol.iterator]: () => this.entries(),\r\n        next: () => {\r\n          const r = iterator.next();\r\n          if (r.done)\r\n            return r;\r\n          const value = this.get(r.value);\r\n          return {\r\n            done: false,\r\n            value: [r.value, value]\r\n          };\r\n        }\r\n      };\r\n    }\r\n    [(DRAFT_STATE, Symbol.iterator)]() {\r\n      return this.entries();\r\n    }\r\n  }\r\n  function proxyMap_(target, parent) {\r\n    return new DraftMap(target, parent);\r\n  }\r\n  function prepareMapCopy(state) {\r\n    if (!state.copy_) {\r\n      state.assigned_ = /* @__PURE__ */ new Map();\r\n      state.copy_ = new Map(state.base_);\r\n    }\r\n  }\r\n  class DraftSet extends Set {\r\n    constructor(target, parent) {\r\n      super();\r\n      this[DRAFT_STATE] = {\r\n        type_: 3 /* Set */,\r\n        parent_: parent,\r\n        scope_: parent ? parent.scope_ : getCurrentScope(),\r\n        modified_: false,\r\n        finalized_: false,\r\n        copy_: void 0,\r\n        base_: target,\r\n        draft_: this,\r\n        drafts_: /* @__PURE__ */ new Map(),\r\n        revoked_: false,\r\n        isManual_: false\r\n      };\r\n    }\r\n    get size() {\r\n      return latest(this[DRAFT_STATE]).size;\r\n    }\r\n    has(value) {\r\n      const state = this[DRAFT_STATE];\r\n      assertUnrevoked(state);\r\n      if (!state.copy_) {\r\n        return state.base_.has(value);\r\n      }\r\n      if (state.copy_.has(value))\r\n        return true;\r\n      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\r\n        return true;\r\n      return false;\r\n    }\r\n    add(value) {\r\n      const state = this[DRAFT_STATE];\r\n      assertUnrevoked(state);\r\n      if (!this.has(value)) {\r\n        prepareSetCopy(state);\r\n        markChanged(state);\r\n        state.copy_.add(value);\r\n      }\r\n      return this;\r\n    }\r\n    delete(value) {\r\n      if (!this.has(value)) {\r\n        return false;\r\n      }\r\n      const state = this[DRAFT_STATE];\r\n      assertUnrevoked(state);\r\n      prepareSetCopy(state);\r\n      markChanged(state);\r\n      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : (\r\n        /* istanbul ignore next */\r\n        false\r\n      ));\r\n    }\r\n    clear() {\r\n      const state = this[DRAFT_STATE];\r\n      assertUnrevoked(state);\r\n      if (latest(state).size) {\r\n        prepareSetCopy(state);\r\n        markChanged(state);\r\n        state.copy_.clear();\r\n      }\r\n    }\r\n    values() {\r\n      const state = this[DRAFT_STATE];\r\n      assertUnrevoked(state);\r\n      prepareSetCopy(state);\r\n      return state.copy_.values();\r\n    }\r\n    entries() {\r\n      const state = this[DRAFT_STATE];\r\n      assertUnrevoked(state);\r\n      prepareSetCopy(state);\r\n      return state.copy_.entries();\r\n    }\r\n    keys() {\r\n      return this.values();\r\n    }\r\n    [(DRAFT_STATE, Symbol.iterator)]() {\r\n      return this.values();\r\n    }\r\n    forEach(cb, thisArg) {\r\n      const iterator = this.values();\r\n      let result = iterator.next();\r\n      while (!result.done) {\r\n        cb.call(thisArg, result.value, result.value, this);\r\n        result = iterator.next();\r\n      }\r\n    }\r\n  }\r\n  function proxySet_(target, parent) {\r\n    return new DraftSet(target, parent);\r\n  }\r\n  function prepareSetCopy(state) {\r\n    if (!state.copy_) {\r\n      state.copy_ = /* @__PURE__ */ new Set();\r\n      state.base_.forEach((value) => {\r\n        if (isDraftable(value)) {\r\n          const draft = createProxy(value, state);\r\n          state.drafts_.set(value, draft);\r\n          state.copy_.add(draft);\r\n        } else {\r\n          state.copy_.add(value);\r\n        }\r\n      });\r\n    }\r\n  }\r\n  function assertUnrevoked(state) {\r\n    if (state.revoked_)\r\n      die(3, JSON.stringify(latest(state)));\r\n  }\r\n  loadPlugin(\"MapSet\", { proxyMap_, proxySet_ });\r\n}\r\n\r\n// src/immer.ts\r\nvar immer = new Immer2();\r\nvar produce = immer.produce;\r\nvar produceWithPatches = immer.produceWithPatches.bind(\r\n  immer\r\n);\r\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\r\nvar setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);\r\nvar applyPatches = immer.applyPatches.bind(immer);\r\nvar createDraft = immer.createDraft.bind(immer);\r\nvar finishDraft = immer.finishDraft.bind(immer);\r\nfunction castDraft(value) {\r\n  return value;\r\n}\r\nfunction castImmutable(value) {\r\n  return value;\r\n}\r\n\r\n//# sourceMappingURL=immer.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbW1lci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBcUM7QUFDbEQ7QUFDQTtBQUNBLDhCQUE4QixPQUFPLGtGQUFrRixPQUFPO0FBQzlILEdBQUc7QUFDSDtBQUNBLGlLQUFpSyxNQUFNO0FBQ3ZLLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxNQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLElBQUksQ0FBRTtBQUNOO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0EsK0JBQStCLElBQUk7QUFDbkM7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxtQ0FBbUMsbUJBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxXQUFXLElBQUksaUJBQWlCO0FBQ3JFO0FBQ0EsdUJBQXVCLG1CQUFtQixvQkFBb0IsMkRBQTJELElBQUk7QUFDN0g7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXFCRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbW1lci5tanM/ZGQ0NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXRpbHMvZW52LnRzXHJcbnZhciBOT1RISU5HID0gU3ltYm9sLmZvcihcImltbWVyLW5vdGhpbmdcIik7XHJcbnZhciBEUkFGVEFCTEUgPSBTeW1ib2wuZm9yKFwiaW1tZXItZHJhZnRhYmxlXCIpO1xyXG52YXIgRFJBRlRfU1RBVEUgPSBTeW1ib2wuZm9yKFwiaW1tZXItc3RhdGVcIik7XHJcblxyXG4vLyBzcmMvdXRpbHMvZXJyb3JzLnRzXHJcbnZhciBlcnJvcnMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBbXHJcbiAgLy8gQWxsIGVycm9yIGNvZGVzLCBzdGFydGluZyBieSAwOlxyXG4gIGZ1bmN0aW9uKHBsdWdpbikge1xyXG4gICAgcmV0dXJuIGBUaGUgcGx1Z2luIGZvciAnJHtwbHVnaW59JyBoYXMgbm90IGJlZW4gbG9hZGVkIGludG8gSW1tZXIuIFRvIGVuYWJsZSB0aGUgcGx1Z2luLCBpbXBvcnQgYW5kIGNhbGwgXFxgZW5hYmxlJHtwbHVnaW59KClcXGAgd2hlbiBpbml0aWFsaXppbmcgeW91ciBhcHBsaWNhdGlvbi5gO1xyXG4gIH0sXHJcbiAgZnVuY3Rpb24odGhpbmcpIHtcclxuICAgIHJldHVybiBgcHJvZHVjZSBjYW4gb25seSBiZSBjYWxsZWQgb24gdGhpbmdzIHRoYXQgYXJlIGRyYWZ0YWJsZTogcGxhaW4gb2JqZWN0cywgYXJyYXlzLCBNYXAsIFNldCBvciBjbGFzc2VzIHRoYXQgYXJlIG1hcmtlZCB3aXRoICdbaW1tZXJhYmxlXTogdHJ1ZScuIEdvdCAnJHt0aGluZ30nYDtcclxuICB9LFxyXG4gIFwiVGhpcyBvYmplY3QgaGFzIGJlZW4gZnJvemVuIGFuZCBzaG91bGQgbm90IGJlIG11dGF0ZWRcIixcclxuICBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICByZXR1cm4gXCJDYW5ub3QgdXNlIGEgcHJveHkgdGhhdCBoYXMgYmVlbiByZXZva2VkLiBEaWQgeW91IHBhc3MgYW4gb2JqZWN0IGZyb20gaW5zaWRlIGFuIGltbWVyIGZ1bmN0aW9uIHRvIGFuIGFzeW5jIHByb2Nlc3M/IFwiICsgZGF0YTtcclxuICB9LFxyXG4gIFwiQW4gaW1tZXIgcHJvZHVjZXIgcmV0dXJuZWQgYSBuZXcgdmFsdWUgKmFuZCogbW9kaWZpZWQgaXRzIGRyYWZ0LiBFaXRoZXIgcmV0dXJuIGEgbmV3IHZhbHVlICpvciogbW9kaWZ5IHRoZSBkcmFmdC5cIixcclxuICBcIkltbWVyIGZvcmJpZHMgY2lyY3VsYXIgcmVmZXJlbmNlc1wiLFxyXG4gIFwiVGhlIGZpcnN0IG9yIHNlY29uZCBhcmd1bWVudCB0byBgcHJvZHVjZWAgbXVzdCBiZSBhIGZ1bmN0aW9uXCIsXHJcbiAgXCJUaGUgdGhpcmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIixcclxuICBcIkZpcnN0IGFyZ3VtZW50IHRvIGBjcmVhdGVEcmFmdGAgbXVzdCBiZSBhIHBsYWluIG9iamVjdCwgYW4gYXJyYXksIG9yIGFuIGltbWVyYWJsZSBvYmplY3RcIixcclxuICBcIkZpcnN0IGFyZ3VtZW50IHRvIGBmaW5pc2hEcmFmdGAgbXVzdCBiZSBhIGRyYWZ0IHJldHVybmVkIGJ5IGBjcmVhdGVEcmFmdGBcIixcclxuICBmdW5jdGlvbih0aGluZykge1xyXG4gICAgcmV0dXJuIGAnY3VycmVudCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6ICR7dGhpbmd9YDtcclxuICB9LFxyXG4gIFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcclxuICBcIk9iamVjdC5zZXRQcm90b3R5cGVPZigpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsXHJcbiAgXCJJbW1lciBvbmx5IHN1cHBvcnRzIGRlbGV0aW5nIGFycmF5IGluZGljZXNcIixcclxuICBcIkltbWVyIG9ubHkgc3VwcG9ydHMgc2V0dGluZyBhcnJheSBpbmRpY2VzIGFuZCB0aGUgJ2xlbmd0aCcgcHJvcGVydHlcIixcclxuICBmdW5jdGlvbih0aGluZykge1xyXG4gICAgcmV0dXJuIGAnb3JpZ2luYWwnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiAke3RoaW5nfWA7XHJcbiAgfVxyXG4gIC8vIE5vdGU6IGlmIG1vcmUgZXJyb3JzIGFyZSBhZGRlZCwgdGhlIGVycm9yT2Zmc2V0IGluIFBhdGNoZXMudHMgc2hvdWxkIGJlIGluY3JlYXNlZFxyXG4gIC8vIFNlZSBQYXRjaGVzLnRzIGZvciBhZGRpdGlvbmFsIGVycm9yc1xyXG5dIDogW107XHJcbmZ1bmN0aW9uIGRpZShlcnJvciwgLi4uYXJncykge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgIGNvbnN0IGUgPSBlcnJvcnNbZXJyb3JdO1xyXG4gICAgY29uc3QgbXNnID0gdHlwZW9mIGUgPT09IFwiZnVuY3Rpb25cIiA/IGUuYXBwbHkobnVsbCwgYXJncykgOiBlO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBbSW1tZXJdICR7bXNnfWApO1xyXG4gIH1cclxuICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICBgW0ltbWVyXSBtaW5pZmllZCBlcnJvciBucjogJHtlcnJvcn0uIEZ1bGwgZXJyb3IgYXQ6IGh0dHBzOi8vYml0Lmx5LzNjWEVLV2ZgXHJcbiAgKTtcclxufVxyXG5cclxuLy8gc3JjL3V0aWxzL2NvbW1vbi50c1xyXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XHJcbmZ1bmN0aW9uIGlzRHJhZnQodmFsdWUpIHtcclxuICByZXR1cm4gISF2YWx1ZSAmJiAhIXZhbHVlW0RSQUZUX1NUQVRFXTtcclxufVxyXG5mdW5jdGlvbiBpc0RyYWZ0YWJsZSh2YWx1ZSkge1xyXG4gIGlmICghdmFsdWUpXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8ICEhdmFsdWVbRFJBRlRBQkxFXSB8fCAhIXZhbHVlLmNvbnN0cnVjdG9yPy5bRFJBRlRBQkxFXSB8fCBpc01hcCh2YWx1ZSkgfHwgaXNTZXQodmFsdWUpO1xyXG59XHJcbnZhciBvYmplY3RDdG9yU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci50b1N0cmluZygpO1xyXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XHJcbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgY29uc3QgcHJvdG8gPSBnZXRQcm90b3R5cGVPZih2YWx1ZSk7XHJcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgY29uc3QgQ3RvciA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCBcImNvbnN0cnVjdG9yXCIpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xyXG4gIGlmIChDdG9yID09PSBPYmplY3QpXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gXCJmdW5jdGlvblwiICYmIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoQ3RvcikgPT09IG9iamVjdEN0b3JTdHJpbmc7XHJcbn1cclxuZnVuY3Rpb24gb3JpZ2luYWwodmFsdWUpIHtcclxuICBpZiAoIWlzRHJhZnQodmFsdWUpKVxyXG4gICAgZGllKDE1LCB2YWx1ZSk7XHJcbiAgcmV0dXJuIHZhbHVlW0RSQUZUX1NUQVRFXS5iYXNlXztcclxufVxyXG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlcikge1xyXG4gIGlmIChnZXRBcmNodHlwZShvYmopID09PSAwIC8qIE9iamVjdCAqLykge1xyXG4gICAgUmVmbGVjdC5vd25LZXlzKG9iaikuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgIGl0ZXIoa2V5LCBvYmpba2V5XSwgb2JqKTtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBvYmouZm9yRWFjaCgoZW50cnksIGluZGV4KSA9PiBpdGVyKGluZGV4LCBlbnRyeSwgb2JqKSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEFyY2h0eXBlKHRoaW5nKSB7XHJcbiAgY29uc3Qgc3RhdGUgPSB0aGluZ1tEUkFGVF9TVEFURV07XHJcbiAgcmV0dXJuIHN0YXRlID8gc3RhdGUudHlwZV8gOiBBcnJheS5pc0FycmF5KHRoaW5nKSA/IDEgLyogQXJyYXkgKi8gOiBpc01hcCh0aGluZykgPyAyIC8qIE1hcCAqLyA6IGlzU2V0KHRoaW5nKSA/IDMgLyogU2V0ICovIDogMCAvKiBPYmplY3QgKi87XHJcbn1cclxuZnVuY3Rpb24gaGFzKHRoaW5nLCBwcm9wKSB7XHJcbiAgcmV0dXJuIGdldEFyY2h0eXBlKHRoaW5nKSA9PT0gMiAvKiBNYXAgKi8gPyB0aGluZy5oYXMocHJvcCkgOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpbmcsIHByb3ApO1xyXG59XHJcbmZ1bmN0aW9uIGdldCh0aGluZywgcHJvcCkge1xyXG4gIHJldHVybiBnZXRBcmNodHlwZSh0aGluZykgPT09IDIgLyogTWFwICovID8gdGhpbmcuZ2V0KHByb3ApIDogdGhpbmdbcHJvcF07XHJcbn1cclxuZnVuY3Rpb24gc2V0KHRoaW5nLCBwcm9wT3JPbGRWYWx1ZSwgdmFsdWUpIHtcclxuICBjb25zdCB0ID0gZ2V0QXJjaHR5cGUodGhpbmcpO1xyXG4gIGlmICh0ID09PSAyIC8qIE1hcCAqLylcclxuICAgIHRoaW5nLnNldChwcm9wT3JPbGRWYWx1ZSwgdmFsdWUpO1xyXG4gIGVsc2UgaWYgKHQgPT09IDMgLyogU2V0ICovKSB7XHJcbiAgICB0aGluZy5hZGQodmFsdWUpO1xyXG4gIH0gZWxzZVxyXG4gICAgdGhpbmdbcHJvcE9yT2xkVmFsdWVdID0gdmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gaXMoeCwgeSkge1xyXG4gIGlmICh4ID09PSB5KSB7XHJcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzTWFwKHRhcmdldCkge1xyXG4gIHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBNYXA7XHJcbn1cclxuZnVuY3Rpb24gaXNTZXQodGFyZ2V0KSB7XHJcbiAgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIFNldDtcclxufVxyXG5mdW5jdGlvbiBsYXRlc3Qoc3RhdGUpIHtcclxuICByZXR1cm4gc3RhdGUuY29weV8gfHwgc3RhdGUuYmFzZV87XHJcbn1cclxuZnVuY3Rpb24gc2hhbGxvd0NvcHkoYmFzZSwgc3RyaWN0KSB7XHJcbiAgaWYgKGlzTWFwKGJhc2UpKSB7XHJcbiAgICByZXR1cm4gbmV3IE1hcChiYXNlKTtcclxuICB9XHJcbiAgaWYgKGlzU2V0KGJhc2UpKSB7XHJcbiAgICByZXR1cm4gbmV3IFNldChiYXNlKTtcclxuICB9XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmFzZSkpXHJcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYmFzZSk7XHJcbiAgY29uc3QgaXNQbGFpbiA9IGlzUGxhaW5PYmplY3QoYmFzZSk7XHJcbiAgaWYgKHN0cmljdCA9PT0gdHJ1ZSB8fCBzdHJpY3QgPT09IFwiY2xhc3Nfb25seVwiICYmICFpc1BsYWluKSB7XHJcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGJhc2UpO1xyXG4gICAgZGVsZXRlIGRlc2NyaXB0b3JzW0RSQUZUX1NUQVRFXTtcclxuICAgIGxldCBrZXlzID0gUmVmbGVjdC5vd25LZXlzKGRlc2NyaXB0b3JzKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICBjb25zdCBkZXNjID0gZGVzY3JpcHRvcnNba2V5XTtcclxuICAgICAgaWYgKGRlc2Mud3JpdGFibGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgZGVzYy53cml0YWJsZSA9IHRydWU7XHJcbiAgICAgICAgZGVzYy5jb25maWd1cmFibGUgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChkZXNjLmdldCB8fCBkZXNjLnNldClcclxuICAgICAgICBkZXNjcmlwdG9yc1trZXldID0ge1xyXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAvLyBjb3VsZCBsaXZlIHdpdGggISFkZXNjLnNldCBhcyB3ZWxsIGhlcmUuLi5cclxuICAgICAgICAgIGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZSxcclxuICAgICAgICAgIHZhbHVlOiBiYXNlW2tleV1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoZ2V0UHJvdG90eXBlT2YoYmFzZSksIGRlc2NyaXB0b3JzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihiYXNlKTtcclxuICAgIGlmIChwcm90byAhPT0gbnVsbCAmJiBpc1BsYWluKSB7XHJcbiAgICAgIHJldHVybiB7IC4uLmJhc2UgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUocHJvdG8pO1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCBiYXNlKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZnJlZXplKG9iaiwgZGVlcCA9IGZhbHNlKSB7XHJcbiAgaWYgKGlzRnJvemVuKG9iaikgfHwgaXNEcmFmdChvYmopIHx8ICFpc0RyYWZ0YWJsZShvYmopKVxyXG4gICAgcmV0dXJuIG9iajtcclxuICBpZiAoZ2V0QXJjaHR5cGUob2JqKSA+IDEpIHtcclxuICAgIG9iai5zZXQgPSBvYmouYWRkID0gb2JqLmNsZWFyID0gb2JqLmRlbGV0ZSA9IGRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucztcclxuICB9XHJcbiAgT2JqZWN0LmZyZWV6ZShvYmopO1xyXG4gIGlmIChkZWVwKVxyXG4gICAgT2JqZWN0LmVudHJpZXMob2JqKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IGZyZWV6ZSh2YWx1ZSwgdHJ1ZSkpO1xyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuZnVuY3Rpb24gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zKCkge1xyXG4gIGRpZSgyKTtcclxufVxyXG5mdW5jdGlvbiBpc0Zyb3plbihvYmopIHtcclxuICByZXR1cm4gT2JqZWN0LmlzRnJvemVuKG9iaik7XHJcbn1cclxuXHJcbi8vIHNyYy91dGlscy9wbHVnaW5zLnRzXHJcbnZhciBwbHVnaW5zID0ge307XHJcbmZ1bmN0aW9uIGdldFBsdWdpbihwbHVnaW5LZXkpIHtcclxuICBjb25zdCBwbHVnaW4gPSBwbHVnaW5zW3BsdWdpbktleV07XHJcbiAgaWYgKCFwbHVnaW4pIHtcclxuICAgIGRpZSgwLCBwbHVnaW5LZXkpO1xyXG4gIH1cclxuICByZXR1cm4gcGx1Z2luO1xyXG59XHJcbmZ1bmN0aW9uIGxvYWRQbHVnaW4ocGx1Z2luS2V5LCBpbXBsZW1lbnRhdGlvbikge1xyXG4gIGlmICghcGx1Z2luc1twbHVnaW5LZXldKVxyXG4gICAgcGx1Z2luc1twbHVnaW5LZXldID0gaW1wbGVtZW50YXRpb247XHJcbn1cclxuXHJcbi8vIHNyYy9jb3JlL3Njb3BlLnRzXHJcbnZhciBjdXJyZW50U2NvcGU7XHJcbmZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcclxuICByZXR1cm4gY3VycmVudFNjb3BlO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNjb3BlKHBhcmVudF8sIGltbWVyXykge1xyXG4gIHJldHVybiB7XHJcbiAgICBkcmFmdHNfOiBbXSxcclxuICAgIHBhcmVudF8sXHJcbiAgICBpbW1lcl8sXHJcbiAgICAvLyBXaGVuZXZlciB0aGUgbW9kaWZpZWQgZHJhZnQgY29udGFpbnMgYSBkcmFmdCBmcm9tIGFub3RoZXIgc2NvcGUsIHdlXHJcbiAgICAvLyBuZWVkIHRvIHByZXZlbnQgYXV0by1mcmVlemluZyBzbyB0aGUgdW5vd25lZCBkcmFmdCBjYW4gYmUgZmluYWxpemVkLlxyXG4gICAgY2FuQXV0b0ZyZWV6ZV86IHRydWUsXHJcbiAgICB1bmZpbmFsaXplZERyYWZ0c186IDBcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKSB7XHJcbiAgaWYgKHBhdGNoTGlzdGVuZXIpIHtcclxuICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIik7XHJcbiAgICBzY29wZS5wYXRjaGVzXyA9IFtdO1xyXG4gICAgc2NvcGUuaW52ZXJzZVBhdGNoZXNfID0gW107XHJcbiAgICBzY29wZS5wYXRjaExpc3RlbmVyXyA9IHBhdGNoTGlzdGVuZXI7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHJldm9rZVNjb3BlKHNjb3BlKSB7XHJcbiAgbGVhdmVTY29wZShzY29wZSk7XHJcbiAgc2NvcGUuZHJhZnRzXy5mb3JFYWNoKHJldm9rZURyYWZ0KTtcclxuICBzY29wZS5kcmFmdHNfID0gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBsZWF2ZVNjb3BlKHNjb3BlKSB7XHJcbiAgaWYgKHNjb3BlID09PSBjdXJyZW50U2NvcGUpIHtcclxuICAgIGN1cnJlbnRTY29wZSA9IHNjb3BlLnBhcmVudF87XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGVudGVyU2NvcGUoaW1tZXIyKSB7XHJcbiAgcmV0dXJuIGN1cnJlbnRTY29wZSA9IGNyZWF0ZVNjb3BlKGN1cnJlbnRTY29wZSwgaW1tZXIyKTtcclxufVxyXG5mdW5jdGlvbiByZXZva2VEcmFmdChkcmFmdCkge1xyXG4gIGNvbnN0IHN0YXRlID0gZHJhZnRbRFJBRlRfU1RBVEVdO1xyXG4gIGlmIChzdGF0ZS50eXBlXyA9PT0gMCAvKiBPYmplY3QgKi8gfHwgc3RhdGUudHlwZV8gPT09IDEgLyogQXJyYXkgKi8pXHJcbiAgICBzdGF0ZS5yZXZva2VfKCk7XHJcbiAgZWxzZVxyXG4gICAgc3RhdGUucmV2b2tlZF8gPSB0cnVlO1xyXG59XHJcblxyXG4vLyBzcmMvY29yZS9maW5hbGl6ZS50c1xyXG5mdW5jdGlvbiBwcm9jZXNzUmVzdWx0KHJlc3VsdCwgc2NvcGUpIHtcclxuICBzY29wZS51bmZpbmFsaXplZERyYWZ0c18gPSBzY29wZS5kcmFmdHNfLmxlbmd0aDtcclxuICBjb25zdCBiYXNlRHJhZnQgPSBzY29wZS5kcmFmdHNfWzBdO1xyXG4gIGNvbnN0IGlzUmVwbGFjZWQgPSByZXN1bHQgIT09IHZvaWQgMCAmJiByZXN1bHQgIT09IGJhc2VEcmFmdDtcclxuICBpZiAoaXNSZXBsYWNlZCkge1xyXG4gICAgaWYgKGJhc2VEcmFmdFtEUkFGVF9TVEFURV0ubW9kaWZpZWRfKSB7XHJcbiAgICAgIHJldm9rZVNjb3BlKHNjb3BlKTtcclxuICAgICAgZGllKDQpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzRHJhZnRhYmxlKHJlc3VsdCkpIHtcclxuICAgICAgcmVzdWx0ID0gZmluYWxpemUoc2NvcGUsIHJlc3VsdCk7XHJcbiAgICAgIGlmICghc2NvcGUucGFyZW50XylcclxuICAgICAgICBtYXliZUZyZWV6ZShzY29wZSwgcmVzdWx0KTtcclxuICAgIH1cclxuICAgIGlmIChzY29wZS5wYXRjaGVzXykge1xyXG4gICAgICBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyhcclxuICAgICAgICBiYXNlRHJhZnRbRFJBRlRfU1RBVEVdLmJhc2VfLFxyXG4gICAgICAgIHJlc3VsdCxcclxuICAgICAgICBzY29wZS5wYXRjaGVzXyxcclxuICAgICAgICBzY29wZS5pbnZlcnNlUGF0Y2hlc19cclxuICAgICAgKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgcmVzdWx0ID0gZmluYWxpemUoc2NvcGUsIGJhc2VEcmFmdCwgW10pO1xyXG4gIH1cclxuICByZXZva2VTY29wZShzY29wZSk7XHJcbiAgaWYgKHNjb3BlLnBhdGNoZXNfKSB7XHJcbiAgICBzY29wZS5wYXRjaExpc3RlbmVyXyhzY29wZS5wYXRjaGVzXywgc2NvcGUuaW52ZXJzZVBhdGNoZXNfKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdCAhPT0gTk9USElORyA/IHJlc3VsdCA6IHZvaWQgMDtcclxufVxyXG5mdW5jdGlvbiBmaW5hbGl6ZShyb290U2NvcGUsIHZhbHVlLCBwYXRoKSB7XHJcbiAgaWYgKGlzRnJvemVuKHZhbHVlKSlcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICBjb25zdCBzdGF0ZSA9IHZhbHVlW0RSQUZUX1NUQVRFXTtcclxuICBpZiAoIXN0YXRlKSB7XHJcbiAgICBlYWNoKFxyXG4gICAgICB2YWx1ZSxcclxuICAgICAgKGtleSwgY2hpbGRWYWx1ZSkgPT4gZmluYWxpemVQcm9wZXJ0eShyb290U2NvcGUsIHN0YXRlLCB2YWx1ZSwga2V5LCBjaGlsZFZhbHVlLCBwYXRoKVxyXG4gICAgKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbiAgaWYgKHN0YXRlLnNjb3BlXyAhPT0gcm9vdFNjb3BlKVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XHJcbiAgICBtYXliZUZyZWV6ZShyb290U2NvcGUsIHN0YXRlLmJhc2VfLCB0cnVlKTtcclxuICAgIHJldHVybiBzdGF0ZS5iYXNlXztcclxuICB9XHJcbiAgaWYgKCFzdGF0ZS5maW5hbGl6ZWRfKSB7XHJcbiAgICBzdGF0ZS5maW5hbGl6ZWRfID0gdHJ1ZTtcclxuICAgIHN0YXRlLnNjb3BlXy51bmZpbmFsaXplZERyYWZ0c18tLTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHN0YXRlLmNvcHlfO1xyXG4gICAgbGV0IHJlc3VsdEVhY2ggPSByZXN1bHQ7XHJcbiAgICBsZXQgaXNTZXQyID0gZmFsc2U7XHJcbiAgICBpZiAoc3RhdGUudHlwZV8gPT09IDMgLyogU2V0ICovKSB7XHJcbiAgICAgIHJlc3VsdEVhY2ggPSBuZXcgU2V0KHJlc3VsdCk7XHJcbiAgICAgIHJlc3VsdC5jbGVhcigpO1xyXG4gICAgICBpc1NldDIgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWFjaChcclxuICAgICAgcmVzdWx0RWFjaCxcclxuICAgICAgKGtleSwgY2hpbGRWYWx1ZSkgPT4gZmluYWxpemVQcm9wZXJ0eShyb290U2NvcGUsIHN0YXRlLCByZXN1bHQsIGtleSwgY2hpbGRWYWx1ZSwgcGF0aCwgaXNTZXQyKVxyXG4gICAgKTtcclxuICAgIG1heWJlRnJlZXplKHJvb3RTY29wZSwgcmVzdWx0LCBmYWxzZSk7XHJcbiAgICBpZiAocGF0aCAmJiByb290U2NvcGUucGF0Y2hlc18pIHtcclxuICAgICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVBhdGNoZXNfKFxyXG4gICAgICAgIHN0YXRlLFxyXG4gICAgICAgIHBhdGgsXHJcbiAgICAgICAgcm9vdFNjb3BlLnBhdGNoZXNfLFxyXG4gICAgICAgIHJvb3RTY29wZS5pbnZlcnNlUGF0Y2hlc19cclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlLmNvcHlfO1xyXG59XHJcbmZ1bmN0aW9uIGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBwYXJlbnRTdGF0ZSwgdGFyZ2V0T2JqZWN0LCBwcm9wLCBjaGlsZFZhbHVlLCByb290UGF0aCwgdGFyZ2V0SXNTZXQpIHtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGNoaWxkVmFsdWUgPT09IHRhcmdldE9iamVjdClcclxuICAgIGRpZSg1KTtcclxuICBpZiAoaXNEcmFmdChjaGlsZFZhbHVlKSkge1xyXG4gICAgY29uc3QgcGF0aCA9IHJvb3RQYXRoICYmIHBhcmVudFN0YXRlICYmIHBhcmVudFN0YXRlLnR5cGVfICE9PSAzIC8qIFNldCAqLyAmJiAvLyBTZXQgb2JqZWN0cyBhcmUgYXRvbWljIHNpbmNlIHRoZXkgaGF2ZSBubyBrZXlzLlxyXG4gICAgIWhhcyhwYXJlbnRTdGF0ZS5hc3NpZ25lZF8sIHByb3ApID8gcm9vdFBhdGguY29uY2F0KHByb3ApIDogdm9pZCAwO1xyXG4gICAgY29uc3QgcmVzID0gZmluYWxpemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlLCBwYXRoKTtcclxuICAgIHNldCh0YXJnZXRPYmplY3QsIHByb3AsIHJlcyk7XHJcbiAgICBpZiAoaXNEcmFmdChyZXMpKSB7XHJcbiAgICAgIHJvb3RTY29wZS5jYW5BdXRvRnJlZXplXyA9IGZhbHNlO1xyXG4gICAgfSBlbHNlXHJcbiAgICAgIHJldHVybjtcclxuICB9IGVsc2UgaWYgKHRhcmdldElzU2V0KSB7XHJcbiAgICB0YXJnZXRPYmplY3QuYWRkKGNoaWxkVmFsdWUpO1xyXG4gIH1cclxuICBpZiAoaXNEcmFmdGFibGUoY2hpbGRWYWx1ZSkgJiYgIWlzRnJvemVuKGNoaWxkVmFsdWUpKSB7XHJcbiAgICBpZiAoIXJvb3RTY29wZS5pbW1lcl8uYXV0b0ZyZWV6ZV8gJiYgcm9vdFNjb3BlLnVuZmluYWxpemVkRHJhZnRzXyA8IDEpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZmluYWxpemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlKTtcclxuICAgIGlmICgoIXBhcmVudFN0YXRlIHx8ICFwYXJlbnRTdGF0ZS5zY29wZV8ucGFyZW50XykgJiYgdHlwZW9mIHByb3AgIT09IFwic3ltYm9sXCIgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldE9iamVjdCwgcHJvcCkpXHJcbiAgICAgIG1heWJlRnJlZXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIG1heWJlRnJlZXplKHNjb3BlLCB2YWx1ZSwgZGVlcCA9IGZhbHNlKSB7XHJcbiAgaWYgKCFzY29wZS5wYXJlbnRfICYmIHNjb3BlLmltbWVyXy5hdXRvRnJlZXplXyAmJiBzY29wZS5jYW5BdXRvRnJlZXplXykge1xyXG4gICAgZnJlZXplKHZhbHVlLCBkZWVwKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIHNyYy9jb3JlL3Byb3h5LnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZVByb3h5UHJveHkoYmFzZSwgcGFyZW50KSB7XHJcbiAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYmFzZSk7XHJcbiAgY29uc3Qgc3RhdGUgPSB7XHJcbiAgICB0eXBlXzogaXNBcnJheSA/IDEgLyogQXJyYXkgKi8gOiAwIC8qIE9iamVjdCAqLyxcclxuICAgIC8vIFRyYWNrIHdoaWNoIHByb2R1Y2UgY2FsbCB0aGlzIGlzIGFzc29jaWF0ZWQgd2l0aC5cclxuICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxyXG4gICAgLy8gVHJ1ZSBmb3IgYm90aCBzaGFsbG93IGFuZCBkZWVwIGNoYW5nZXMuXHJcbiAgICBtb2RpZmllZF86IGZhbHNlLFxyXG4gICAgLy8gVXNlZCBkdXJpbmcgZmluYWxpemF0aW9uLlxyXG4gICAgZmluYWxpemVkXzogZmFsc2UsXHJcbiAgICAvLyBUcmFjayB3aGljaCBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBhc3NpZ25lZCAodHJ1ZSkgb3IgZGVsZXRlZCAoZmFsc2UpLlxyXG4gICAgYXNzaWduZWRfOiB7fSxcclxuICAgIC8vIFRoZSBwYXJlbnQgZHJhZnQgc3RhdGUuXHJcbiAgICBwYXJlbnRfOiBwYXJlbnQsXHJcbiAgICAvLyBUaGUgYmFzZSBzdGF0ZS5cclxuICAgIGJhc2VfOiBiYXNlLFxyXG4gICAgLy8gVGhlIGJhc2UgcHJveHkuXHJcbiAgICBkcmFmdF86IG51bGwsXHJcbiAgICAvLyBzZXQgYmVsb3dcclxuICAgIC8vIFRoZSBiYXNlIGNvcHkgd2l0aCBhbnkgdXBkYXRlZCB2YWx1ZXMuXHJcbiAgICBjb3B5XzogbnVsbCxcclxuICAgIC8vIENhbGxlZCBieSB0aGUgYHByb2R1Y2VgIGZ1bmN0aW9uLlxyXG4gICAgcmV2b2tlXzogbnVsbCxcclxuICAgIGlzTWFudWFsXzogZmFsc2VcclxuICB9O1xyXG4gIGxldCB0YXJnZXQgPSBzdGF0ZTtcclxuICBsZXQgdHJhcHMgPSBvYmplY3RUcmFwcztcclxuICBpZiAoaXNBcnJheSkge1xyXG4gICAgdGFyZ2V0ID0gW3N0YXRlXTtcclxuICAgIHRyYXBzID0gYXJyYXlUcmFwcztcclxuICB9XHJcbiAgY29uc3QgeyByZXZva2UsIHByb3h5IH0gPSBQcm94eS5yZXZvY2FibGUodGFyZ2V0LCB0cmFwcyk7XHJcbiAgc3RhdGUuZHJhZnRfID0gcHJveHk7XHJcbiAgc3RhdGUucmV2b2tlXyA9IHJldm9rZTtcclxuICByZXR1cm4gcHJveHk7XHJcbn1cclxudmFyIG9iamVjdFRyYXBzID0ge1xyXG4gIGdldChzdGF0ZSwgcHJvcCkge1xyXG4gICAgaWYgKHByb3AgPT09IERSQUZUX1NUQVRFKVxyXG4gICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICBjb25zdCBzb3VyY2UgPSBsYXRlc3Qoc3RhdGUpO1xyXG4gICAgaWYgKCFoYXMoc291cmNlLCBwcm9wKSkge1xyXG4gICAgICByZXR1cm4gcmVhZFByb3BGcm9tUHJvdG8oc3RhdGUsIHNvdXJjZSwgcHJvcCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtwcm9wXTtcclxuICAgIGlmIChzdGF0ZS5maW5hbGl6ZWRfIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlID09PSBwZWVrKHN0YXRlLmJhc2VfLCBwcm9wKSkge1xyXG4gICAgICBwcmVwYXJlQ29weShzdGF0ZSk7XHJcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5X1twcm9wXSA9IGNyZWF0ZVByb3h5KHZhbHVlLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfSxcclxuICBoYXMoc3RhdGUsIHByb3ApIHtcclxuICAgIHJldHVybiBwcm9wIGluIGxhdGVzdChzdGF0ZSk7XHJcbiAgfSxcclxuICBvd25LZXlzKHN0YXRlKSB7XHJcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKGxhdGVzdChzdGF0ZSkpO1xyXG4gIH0sXHJcbiAgc2V0KHN0YXRlLCBwcm9wLCB2YWx1ZSkge1xyXG4gICAgY29uc3QgZGVzYyA9IGdldERlc2NyaXB0b3JGcm9tUHJvdG8obGF0ZXN0KHN0YXRlKSwgcHJvcCk7XHJcbiAgICBpZiAoZGVzYz8uc2V0KSB7XHJcbiAgICAgIGRlc2Muc2V0LmNhbGwoc3RhdGUuZHJhZnRfLCB2YWx1ZSk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcclxuICAgICAgY29uc3QgY3VycmVudDIgPSBwZWVrKGxhdGVzdChzdGF0ZSksIHByb3ApO1xyXG4gICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBjdXJyZW50Mj8uW0RSQUZUX1NUQVRFXTtcclxuICAgICAgaWYgKGN1cnJlbnRTdGF0ZSAmJiBjdXJyZW50U3RhdGUuYmFzZV8gPT09IHZhbHVlKSB7XHJcbiAgICAgICAgc3RhdGUuY29weV9bcHJvcF0gPSB2YWx1ZTtcclxuICAgICAgICBzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXModmFsdWUsIGN1cnJlbnQyKSAmJiAodmFsdWUgIT09IHZvaWQgMCB8fCBoYXMoc3RhdGUuYmFzZV8sIHByb3ApKSlcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgcHJlcGFyZUNvcHkoc3RhdGUpO1xyXG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RhdGUuY29weV9bcHJvcF0gPT09IHZhbHVlICYmIC8vIHNwZWNpYWwgY2FzZTogaGFuZGxlIG5ldyBwcm9wcyB3aXRoIHZhbHVlICd1bmRlZmluZWQnXHJcbiAgICAodmFsdWUgIT09IHZvaWQgMCB8fCBwcm9wIGluIHN0YXRlLmNvcHlfKSB8fCAvLyBzcGVjaWFsIGNhc2U6IE5hTlxyXG4gICAgTnVtYmVyLmlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNOYU4oc3RhdGUuY29weV9bcHJvcF0pKVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIHN0YXRlLmNvcHlfW3Byb3BdID0gdmFsdWU7XHJcbiAgICBzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSxcclxuICBkZWxldGVQcm9wZXJ0eShzdGF0ZSwgcHJvcCkge1xyXG4gICAgaWYgKHBlZWsoc3RhdGUuYmFzZV8sIHByb3ApICE9PSB2b2lkIDAgfHwgcHJvcCBpbiBzdGF0ZS5iYXNlXykge1xyXG4gICAgICBzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSBmYWxzZTtcclxuICAgICAgcHJlcGFyZUNvcHkoc3RhdGUpO1xyXG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkZWxldGUgc3RhdGUuYXNzaWduZWRfW3Byb3BdO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0YXRlLmNvcHlfKSB7XHJcbiAgICAgIGRlbGV0ZSBzdGF0ZS5jb3B5X1twcm9wXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0sXHJcbiAgLy8gTm90ZTogV2UgbmV2ZXIgY29lcmNlIGBkZXNjLnZhbHVlYCBpbnRvIGFuIEltbWVyIGRyYWZ0LCBiZWNhdXNlIHdlIGNhbid0IG1ha2VcclxuICAvLyB0aGUgc2FtZSBndWFyYW50ZWUgaW4gRVM1IG1vZGUuXHJcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHN0YXRlLCBwcm9wKSB7XHJcbiAgICBjb25zdCBvd25lciA9IGxhdGVzdChzdGF0ZSk7XHJcbiAgICBjb25zdCBkZXNjID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3duZXIsIHByb3ApO1xyXG4gICAgaWYgKCFkZXNjKVxyXG4gICAgICByZXR1cm4gZGVzYztcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICBjb25maWd1cmFibGU6IHN0YXRlLnR5cGVfICE9PSAxIC8qIEFycmF5ICovIHx8IHByb3AgIT09IFwibGVuZ3RoXCIsXHJcbiAgICAgIGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZSxcclxuICAgICAgdmFsdWU6IG93bmVyW3Byb3BdXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgZGVmaW5lUHJvcGVydHkoKSB7XHJcbiAgICBkaWUoMTEpO1xyXG4gIH0sXHJcbiAgZ2V0UHJvdG90eXBlT2Yoc3RhdGUpIHtcclxuICAgIHJldHVybiBnZXRQcm90b3R5cGVPZihzdGF0ZS5iYXNlXyk7XHJcbiAgfSxcclxuICBzZXRQcm90b3R5cGVPZigpIHtcclxuICAgIGRpZSgxMik7XHJcbiAgfVxyXG59O1xyXG52YXIgYXJyYXlUcmFwcyA9IHt9O1xyXG5lYWNoKG9iamVjdFRyYXBzLCAoa2V5LCBmbikgPT4ge1xyXG4gIGFycmF5VHJhcHNba2V5XSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgYXJndW1lbnRzWzBdID0gYXJndW1lbnRzWzBdWzBdO1xyXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfTtcclxufSk7XHJcbmFycmF5VHJhcHMuZGVsZXRlUHJvcGVydHkgPSBmdW5jdGlvbihzdGF0ZSwgcHJvcCkge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNOYU4ocGFyc2VJbnQocHJvcCkpKVxyXG4gICAgZGllKDEzKTtcclxuICByZXR1cm4gYXJyYXlUcmFwcy5zZXQuY2FsbCh0aGlzLCBzdGF0ZSwgcHJvcCwgdm9pZCAwKTtcclxufTtcclxuYXJyYXlUcmFwcy5zZXQgPSBmdW5jdGlvbihzdGF0ZSwgcHJvcCwgdmFsdWUpIHtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHByb3AgIT09IFwibGVuZ3RoXCIgJiYgaXNOYU4ocGFyc2VJbnQocHJvcCkpKVxyXG4gICAgZGllKDE0KTtcclxuICByZXR1cm4gb2JqZWN0VHJhcHMuc2V0LmNhbGwodGhpcywgc3RhdGVbMF0sIHByb3AsIHZhbHVlLCBzdGF0ZVswXSk7XHJcbn07XHJcbmZ1bmN0aW9uIHBlZWsoZHJhZnQsIHByb3ApIHtcclxuICBjb25zdCBzdGF0ZSA9IGRyYWZ0W0RSQUZUX1NUQVRFXTtcclxuICBjb25zdCBzb3VyY2UgPSBzdGF0ZSA/IGxhdGVzdChzdGF0ZSkgOiBkcmFmdDtcclxuICByZXR1cm4gc291cmNlW3Byb3BdO1xyXG59XHJcbmZ1bmN0aW9uIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlLCBzb3VyY2UsIHByb3ApIHtcclxuICBjb25zdCBkZXNjID0gZ2V0RGVzY3JpcHRvckZyb21Qcm90byhzb3VyY2UsIHByb3ApO1xyXG4gIHJldHVybiBkZXNjID8gYHZhbHVlYCBpbiBkZXNjID8gZGVzYy52YWx1ZSA6IChcclxuICAgIC8vIFRoaXMgaXMgYSB2ZXJ5IHNwZWNpYWwgY2FzZSwgaWYgdGhlIHByb3AgaXMgYSBnZXR0ZXIgZGVmaW5lZCBieSB0aGVcclxuICAgIC8vIHByb3RvdHlwZSwgd2Ugc2hvdWxkIGludm9rZSBpdCB3aXRoIHRoZSBkcmFmdCBhcyBjb250ZXh0IVxyXG4gICAgZGVzYy5nZXQ/LmNhbGwoc3RhdGUuZHJhZnRfKVxyXG4gICkgOiB2b2lkIDA7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RGVzY3JpcHRvckZyb21Qcm90byhzb3VyY2UsIHByb3ApIHtcclxuICBpZiAoIShwcm9wIGluIHNvdXJjZSkpXHJcbiAgICByZXR1cm4gdm9pZCAwO1xyXG4gIGxldCBwcm90byA9IGdldFByb3RvdHlwZU9mKHNvdXJjZSk7XHJcbiAgd2hpbGUgKHByb3RvKSB7XHJcbiAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgcHJvcCk7XHJcbiAgICBpZiAoZGVzYylcclxuICAgICAgcmV0dXJuIGRlc2M7XHJcbiAgICBwcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcclxuICB9XHJcbiAgcmV0dXJuIHZvaWQgMDtcclxufVxyXG5mdW5jdGlvbiBtYXJrQ2hhbmdlZChzdGF0ZSkge1xyXG4gIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XHJcbiAgICBzdGF0ZS5tb2RpZmllZF8gPSB0cnVlO1xyXG4gICAgaWYgKHN0YXRlLnBhcmVudF8pIHtcclxuICAgICAgbWFya0NoYW5nZWQoc3RhdGUucGFyZW50Xyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHByZXBhcmVDb3B5KHN0YXRlKSB7XHJcbiAgaWYgKCFzdGF0ZS5jb3B5Xykge1xyXG4gICAgc3RhdGUuY29weV8gPSBzaGFsbG93Q29weShcclxuICAgICAgc3RhdGUuYmFzZV8sXHJcbiAgICAgIHN0YXRlLnNjb3BlXy5pbW1lcl8udXNlU3RyaWN0U2hhbGxvd0NvcHlfXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuLy8gc3JjL2NvcmUvaW1tZXJDbGFzcy50c1xyXG52YXIgSW1tZXIyID0gY2xhc3Mge1xyXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgdGhpcy5hdXRvRnJlZXplXyA9IHRydWU7XHJcbiAgICB0aGlzLnVzZVN0cmljdFNoYWxsb3dDb3B5XyA9IGZhbHNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYHByb2R1Y2VgIGZ1bmN0aW9uIHRha2VzIGEgdmFsdWUgYW5kIGEgXCJyZWNpcGUgZnVuY3Rpb25cIiAod2hvc2VcclxuICAgICAqIHJldHVybiB2YWx1ZSBvZnRlbiBkZXBlbmRzIG9uIHRoZSBiYXNlIHN0YXRlKS4gVGhlIHJlY2lwZSBmdW5jdGlvbiBpc1xyXG4gICAgICogZnJlZSB0byBtdXRhdGUgaXRzIGZpcnN0IGFyZ3VtZW50IGhvd2V2ZXIgaXQgd2FudHMuIEFsbCBtdXRhdGlvbnMgYXJlXHJcbiAgICAgKiBvbmx5IGV2ZXIgYXBwbGllZCB0byBhIF9fY29weV9fIG9mIHRoZSBiYXNlIHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIFBhc3Mgb25seSBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIFwiY3VycmllZCBwcm9kdWNlclwiIHdoaWNoIHJlbGlldmVzIHlvdVxyXG4gICAgICogZnJvbSBwYXNzaW5nIHRoZSByZWNpcGUgZnVuY3Rpb24gZXZlcnkgdGltZS5cclxuICAgICAqXHJcbiAgICAgKiBPbmx5IHBsYWluIG9iamVjdHMgYW5kIGFycmF5cyBhcmUgbWFkZSBtdXRhYmxlLiBBbGwgb3RoZXIgb2JqZWN0cyBhcmVcclxuICAgICAqIGNvbnNpZGVyZWQgdW5jb3B5YWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIF9fYm91bmRfXyB0byBpdHMgYEltbWVyYCBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gYmFzZSAtIHRoZSBpbml0aWFsIHN0YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWNpcGUgLSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgcHJveHkgb2YgdGhlIGJhc2Ugc3RhdGUgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHdoaWNoIGNhbiBiZSBmcmVlbHkgbW9kaWZpZWRcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHBhdGNoTGlzdGVuZXIgLSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYWxsIHRoZSBwYXRjaGVzIHByb2R1Y2VkIGhlcmVcclxuICAgICAqIEByZXR1cm5zIHthbnl9IGEgbmV3IHN0YXRlLCBvciB0aGUgaW5pdGlhbCBzdGF0ZSBpZiBub3RoaW5nIHdhcyBtb2RpZmllZFxyXG4gICAgICovXHJcbiAgICB0aGlzLnByb2R1Y2UgPSAoYmFzZSwgcmVjaXBlLCBwYXRjaExpc3RlbmVyKSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiByZWNpcGUgIT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRCYXNlID0gcmVjaXBlO1xyXG4gICAgICAgIHJlY2lwZSA9IGJhc2U7XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGN1cnJpZWRQcm9kdWNlKGJhc2UyID0gZGVmYXVsdEJhc2UsIC4uLmFyZ3MpIHtcclxuICAgICAgICAgIHJldHVybiBzZWxmLnByb2R1Y2UoYmFzZTIsIChkcmFmdCkgPT4gcmVjaXBlLmNhbGwodGhpcywgZHJhZnQsIC4uLmFyZ3MpKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eXBlb2YgcmVjaXBlICE9PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZGllKDYpO1xyXG4gICAgICBpZiAocGF0Y2hMaXN0ZW5lciAhPT0gdm9pZCAwICYmIHR5cGVvZiBwYXRjaExpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZGllKDcpO1xyXG4gICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICBpZiAoaXNEcmFmdGFibGUoYmFzZSkpIHtcclxuICAgICAgICBjb25zdCBzY29wZSA9IGVudGVyU2NvcGUodGhpcyk7XHJcbiAgICAgICAgY29uc3QgcHJveHkgPSBjcmVhdGVQcm94eShiYXNlLCB2b2lkIDApO1xyXG4gICAgICAgIGxldCBoYXNFcnJvciA9IHRydWU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHJlc3VsdCA9IHJlY2lwZShwcm94eSk7XHJcbiAgICAgICAgICBoYXNFcnJvciA9IGZhbHNlO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICBpZiAoaGFzRXJyb3IpXHJcbiAgICAgICAgICAgIHJldm9rZVNjb3BlKHNjb3BlKTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgbGVhdmVTY29wZShzY29wZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKTtcclxuICAgICAgICByZXR1cm4gcHJvY2Vzc1Jlc3VsdChyZXN1bHQsIHNjb3BlKTtcclxuICAgICAgfSBlbHNlIGlmICghYmFzZSB8fCB0eXBlb2YgYmFzZSAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHJlc3VsdCA9IHJlY2lwZShiYXNlKTtcclxuICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApXHJcbiAgICAgICAgICByZXN1bHQgPSBiYXNlO1xyXG4gICAgICAgIGlmIChyZXN1bHQgPT09IE5PVEhJTkcpXHJcbiAgICAgICAgICByZXN1bHQgPSB2b2lkIDA7XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0b0ZyZWV6ZV8pXHJcbiAgICAgICAgICBmcmVlemUocmVzdWx0LCB0cnVlKTtcclxuICAgICAgICBpZiAocGF0Y2hMaXN0ZW5lcikge1xyXG4gICAgICAgICAgY29uc3QgcCA9IFtdO1xyXG4gICAgICAgICAgY29uc3QgaXAgPSBbXTtcclxuICAgICAgICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIikuZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKGJhc2UsIHJlc3VsdCwgcCwgaXApO1xyXG4gICAgICAgICAgcGF0Y2hMaXN0ZW5lcihwLCBpcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH0gZWxzZVxyXG4gICAgICAgIGRpZSgxLCBiYXNlKTtcclxuICAgIH07XHJcbiAgICB0aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcyA9IChiYXNlLCByZWNpcGUpID0+IHtcclxuICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICByZXR1cm4gKHN0YXRlLCAuLi5hcmdzKSA9PiB0aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcyhzdGF0ZSwgKGRyYWZ0KSA9PiBiYXNlKGRyYWZ0LCAuLi5hcmdzKSk7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IHBhdGNoZXMsIGludmVyc2VQYXRjaGVzO1xyXG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnByb2R1Y2UoYmFzZSwgcmVjaXBlLCAocCwgaXApID0+IHtcclxuICAgICAgICBwYXRjaGVzID0gcDtcclxuICAgICAgICBpbnZlcnNlUGF0Y2hlcyA9IGlwO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIFtyZXN1bHQsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzXTtcclxuICAgIH07XHJcbiAgICBpZiAodHlwZW9mIGNvbmZpZz8uYXV0b0ZyZWV6ZSA9PT0gXCJib29sZWFuXCIpXHJcbiAgICAgIHRoaXMuc2V0QXV0b0ZyZWV6ZShjb25maWcuYXV0b0ZyZWV6ZSk7XHJcbiAgICBpZiAodHlwZW9mIGNvbmZpZz8udXNlU3RyaWN0U2hhbGxvd0NvcHkgPT09IFwiYm9vbGVhblwiKVxyXG4gICAgICB0aGlzLnNldFVzZVN0cmljdFNoYWxsb3dDb3B5KGNvbmZpZy51c2VTdHJpY3RTaGFsbG93Q29weSk7XHJcbiAgfVxyXG4gIGNyZWF0ZURyYWZ0KGJhc2UpIHtcclxuICAgIGlmICghaXNEcmFmdGFibGUoYmFzZSkpXHJcbiAgICAgIGRpZSg4KTtcclxuICAgIGlmIChpc0RyYWZ0KGJhc2UpKVxyXG4gICAgICBiYXNlID0gY3VycmVudChiYXNlKTtcclxuICAgIGNvbnN0IHNjb3BlID0gZW50ZXJTY29wZSh0aGlzKTtcclxuICAgIGNvbnN0IHByb3h5ID0gY3JlYXRlUHJveHkoYmFzZSwgdm9pZCAwKTtcclxuICAgIHByb3h5W0RSQUZUX1NUQVRFXS5pc01hbnVhbF8gPSB0cnVlO1xyXG4gICAgbGVhdmVTY29wZShzY29wZSk7XHJcbiAgICByZXR1cm4gcHJveHk7XHJcbiAgfVxyXG4gIGZpbmlzaERyYWZ0KGRyYWZ0LCBwYXRjaExpc3RlbmVyKSB7XHJcbiAgICBjb25zdCBzdGF0ZSA9IGRyYWZ0ICYmIGRyYWZ0W0RSQUZUX1NUQVRFXTtcclxuICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLmlzTWFudWFsXylcclxuICAgICAgZGllKDkpO1xyXG4gICAgY29uc3QgeyBzY29wZV86IHNjb3BlIH0gPSBzdGF0ZTtcclxuICAgIHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKTtcclxuICAgIHJldHVybiBwcm9jZXNzUmVzdWx0KHZvaWQgMCwgc2NvcGUpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBQYXNzIHRydWUgdG8gYXV0b21hdGljYWxseSBmcmVlemUgYWxsIGNvcGllcyBjcmVhdGVkIGJ5IEltbWVyLlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCwgYXV0by1mcmVlemluZyBpcyBlbmFibGVkLlxyXG4gICAqL1xyXG4gIHNldEF1dG9GcmVlemUodmFsdWUpIHtcclxuICAgIHRoaXMuYXV0b0ZyZWV6ZV8gPSB2YWx1ZTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUGFzcyB0cnVlIHRvIGVuYWJsZSBzdHJpY3Qgc2hhbGxvdyBjb3B5LlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCwgaW1tZXIgZG9lcyBub3QgY29weSB0aGUgb2JqZWN0IGRlc2NyaXB0b3JzIHN1Y2ggYXMgZ2V0dGVyLCBzZXR0ZXIgYW5kIG5vbi1lbnVtcmFibGUgcHJvcGVydGllcy5cclxuICAgKi9cclxuICBzZXRVc2VTdHJpY3RTaGFsbG93Q29weSh2YWx1ZSkge1xyXG4gICAgdGhpcy51c2VTdHJpY3RTaGFsbG93Q29weV8gPSB2YWx1ZTtcclxuICB9XHJcbiAgYXBwbHlQYXRjaGVzKGJhc2UsIHBhdGNoZXMpIHtcclxuICAgIGxldCBpO1xyXG4gICAgZm9yIChpID0gcGF0Y2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICBjb25zdCBwYXRjaCA9IHBhdGNoZXNbaV07XHJcbiAgICAgIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMCAmJiBwYXRjaC5vcCA9PT0gXCJyZXBsYWNlXCIpIHtcclxuICAgICAgICBiYXNlID0gcGF0Y2gudmFsdWU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpID4gLTEpIHtcclxuICAgICAgcGF0Y2hlcyA9IHBhdGNoZXMuc2xpY2UoaSArIDEpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYXBwbHlQYXRjaGVzSW1wbCA9IGdldFBsdWdpbihcIlBhdGNoZXNcIikuYXBwbHlQYXRjaGVzXztcclxuICAgIGlmIChpc0RyYWZ0KGJhc2UpKSB7XHJcbiAgICAgIHJldHVybiBhcHBseVBhdGNoZXNJbXBsKGJhc2UsIHBhdGNoZXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMucHJvZHVjZShcclxuICAgICAgYmFzZSxcclxuICAgICAgKGRyYWZ0KSA9PiBhcHBseVBhdGNoZXNJbXBsKGRyYWZ0LCBwYXRjaGVzKVxyXG4gICAgKTtcclxuICB9XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZVByb3h5KHZhbHVlLCBwYXJlbnQpIHtcclxuICBjb25zdCBkcmFmdCA9IGlzTWFwKHZhbHVlKSA/IGdldFBsdWdpbihcIk1hcFNldFwiKS5wcm94eU1hcF8odmFsdWUsIHBhcmVudCkgOiBpc1NldCh2YWx1ZSkgPyBnZXRQbHVnaW4oXCJNYXBTZXRcIikucHJveHlTZXRfKHZhbHVlLCBwYXJlbnQpIDogY3JlYXRlUHJveHlQcm94eSh2YWx1ZSwgcGFyZW50KTtcclxuICBjb25zdCBzY29wZSA9IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKTtcclxuICBzY29wZS5kcmFmdHNfLnB1c2goZHJhZnQpO1xyXG4gIHJldHVybiBkcmFmdDtcclxufVxyXG5cclxuLy8gc3JjL2NvcmUvY3VycmVudC50c1xyXG5mdW5jdGlvbiBjdXJyZW50KHZhbHVlKSB7XHJcbiAgaWYgKCFpc0RyYWZ0KHZhbHVlKSlcclxuICAgIGRpZSgxMCwgdmFsdWUpO1xyXG4gIHJldHVybiBjdXJyZW50SW1wbCh2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gY3VycmVudEltcGwodmFsdWUpIHtcclxuICBpZiAoIWlzRHJhZnRhYmxlKHZhbHVlKSB8fCBpc0Zyb3plbih2YWx1ZSkpXHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgY29uc3Qgc3RhdGUgPSB2YWx1ZVtEUkFGVF9TVEFURV07XHJcbiAgbGV0IGNvcHk7XHJcbiAgaWYgKHN0YXRlKSB7XHJcbiAgICBpZiAoIXN0YXRlLm1vZGlmaWVkXylcclxuICAgICAgcmV0dXJuIHN0YXRlLmJhc2VfO1xyXG4gICAgc3RhdGUuZmluYWxpemVkXyA9IHRydWU7XHJcbiAgICBjb3B5ID0gc2hhbGxvd0NvcHkodmFsdWUsIHN0YXRlLnNjb3BlXy5pbW1lcl8udXNlU3RyaWN0U2hhbGxvd0NvcHlfKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29weSA9IHNoYWxsb3dDb3B5KHZhbHVlLCB0cnVlKTtcclxuICB9XHJcbiAgZWFjaChjb3B5LCAoa2V5LCBjaGlsZFZhbHVlKSA9PiB7XHJcbiAgICBzZXQoY29weSwga2V5LCBjdXJyZW50SW1wbChjaGlsZFZhbHVlKSk7XHJcbiAgfSk7XHJcbiAgaWYgKHN0YXRlKSB7XHJcbiAgICBzdGF0ZS5maW5hbGl6ZWRfID0gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiBjb3B5O1xyXG59XHJcblxyXG4vLyBzcmMvcGx1Z2lucy9wYXRjaGVzLnRzXHJcbmZ1bmN0aW9uIGVuYWJsZVBhdGNoZXMoKSB7XHJcbiAgY29uc3QgZXJyb3JPZmZzZXQgPSAxNjtcclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICBlcnJvcnMucHVzaChcclxuICAgICAgJ1NldHMgY2Fubm90IGhhdmUgXCJyZXBsYWNlXCIgcGF0Y2hlcy4nLFxyXG4gICAgICBmdW5jdGlvbihvcCkge1xyXG4gICAgICAgIHJldHVybiBcIlVuc3VwcG9ydGVkIHBhdGNoIG9wZXJhdGlvbjogXCIgKyBvcDtcclxuICAgICAgfSxcclxuICAgICAgZnVuY3Rpb24ocGF0aCkge1xyXG4gICAgICAgIHJldHVybiBcIkNhbm5vdCBhcHBseSBwYXRjaCwgcGF0aCBkb2Vzbid0IHJlc29sdmU6IFwiICsgcGF0aDtcclxuICAgICAgfSxcclxuICAgICAgXCJQYXRjaGluZyByZXNlcnZlZCBhdHRyaWJ1dGVzIGxpa2UgX19wcm90b19fLCBwcm90b3R5cGUgYW5kIGNvbnN0cnVjdG9yIGlzIG5vdCBhbGxvd2VkXCJcclxuICAgICk7XHJcbiAgfVxyXG4gIGNvbnN0IFJFUExBQ0UgPSBcInJlcGxhY2VcIjtcclxuICBjb25zdCBBREQgPSBcImFkZFwiO1xyXG4gIGNvbnN0IFJFTU9WRSA9IFwicmVtb3ZlXCI7XHJcbiAgZnVuY3Rpb24gZ2VuZXJhdGVQYXRjaGVzXyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XHJcbiAgICBzd2l0Y2ggKHN0YXRlLnR5cGVfKSB7XHJcbiAgICAgIGNhc2UgMCAvKiBPYmplY3QgKi86XHJcbiAgICAgIGNhc2UgMiAvKiBNYXAgKi86XHJcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZChcclxuICAgICAgICAgIHN0YXRlLFxyXG4gICAgICAgICAgYmFzZVBhdGgsXHJcbiAgICAgICAgICBwYXRjaGVzLFxyXG4gICAgICAgICAgaW52ZXJzZVBhdGNoZXNcclxuICAgICAgICApO1xyXG4gICAgICBjYXNlIDEgLyogQXJyYXkgKi86XHJcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlQXJyYXlQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpO1xyXG4gICAgICBjYXNlIDMgLyogU2V0ICovOlxyXG4gICAgICAgIHJldHVybiBnZW5lcmF0ZVNldFBhdGNoZXMoXHJcbiAgICAgICAgICBzdGF0ZSxcclxuICAgICAgICAgIGJhc2VQYXRoLFxyXG4gICAgICAgICAgcGF0Y2hlcyxcclxuICAgICAgICAgIGludmVyc2VQYXRjaGVzXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gZ2VuZXJhdGVBcnJheVBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xyXG4gICAgbGV0IHsgYmFzZV8sIGFzc2lnbmVkXyB9ID0gc3RhdGU7XHJcbiAgICBsZXQgY29weV8gPSBzdGF0ZS5jb3B5XztcclxuICAgIGlmIChjb3B5Xy5sZW5ndGggPCBiYXNlXy5sZW5ndGgpIHtcclxuICAgICAgO1xyXG4gICAgICBbYmFzZV8sIGNvcHlfXSA9IFtjb3B5XywgYmFzZV9dO1xyXG4gICAgICBbcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdID0gW2ludmVyc2VQYXRjaGVzLCBwYXRjaGVzXTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZV8ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKGFzc2lnbmVkX1tpXSAmJiBjb3B5X1tpXSAhPT0gYmFzZV9baV0pIHtcclxuICAgICAgICBjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XHJcbiAgICAgICAgcGF0Y2hlcy5wdXNoKHtcclxuICAgICAgICAgIG9wOiBSRVBMQUNFLFxyXG4gICAgICAgICAgcGF0aCxcclxuICAgICAgICAgIC8vIE5lZWQgdG8gbWF5YmUgY2xvbmUgaXQsIGFzIGl0IGNhbiBpbiBmYWN0IGJlIHRoZSBvcmlnaW5hbCB2YWx1ZVxyXG4gICAgICAgICAgLy8gZHVlIHRvIHRoZSBiYXNlL2NvcHkgaW52ZXJzaW9uIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZ1bmN0aW9uXHJcbiAgICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoY29weV9baV0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XHJcbiAgICAgICAgICBvcDogUkVQTEFDRSxcclxuICAgICAgICAgIHBhdGgsXHJcbiAgICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoYmFzZV9baV0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSBiYXNlXy5sZW5ndGg7IGkgPCBjb3B5Xy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XHJcbiAgICAgIHBhdGNoZXMucHVzaCh7XHJcbiAgICAgICAgb3A6IEFERCxcclxuICAgICAgICBwYXRoLFxyXG4gICAgICAgIC8vIE5lZWQgdG8gbWF5YmUgY2xvbmUgaXQsIGFzIGl0IGNhbiBpbiBmYWN0IGJlIHRoZSBvcmlnaW5hbCB2YWx1ZVxyXG4gICAgICAgIC8vIGR1ZSB0byB0aGUgYmFzZS9jb3B5IGludmVyc2lvbiBhdCB0aGUgc3RhcnQgb2YgdGhpcyBmdW5jdGlvblxyXG4gICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChjb3B5X1tpXSlcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gY29weV8ubGVuZ3RoIC0gMTsgYmFzZV8ubGVuZ3RoIDw9IGk7IC0taSkge1xyXG4gICAgICBjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XHJcbiAgICAgIGludmVyc2VQYXRjaGVzLnB1c2goe1xyXG4gICAgICAgIG9wOiBSRU1PVkUsXHJcbiAgICAgICAgcGF0aFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcclxuICAgIGNvbnN0IHsgYmFzZV8sIGNvcHlfIH0gPSBzdGF0ZTtcclxuICAgIGVhY2goc3RhdGUuYXNzaWduZWRfLCAoa2V5LCBhc3NpZ25lZFZhbHVlKSA9PiB7XHJcbiAgICAgIGNvbnN0IG9yaWdWYWx1ZSA9IGdldChiYXNlXywga2V5KTtcclxuICAgICAgY29uc3QgdmFsdWUgPSBnZXQoY29weV8sIGtleSk7XHJcbiAgICAgIGNvbnN0IG9wID0gIWFzc2lnbmVkVmFsdWUgPyBSRU1PVkUgOiBoYXMoYmFzZV8sIGtleSkgPyBSRVBMQUNFIDogQUREO1xyXG4gICAgICBpZiAob3JpZ1ZhbHVlID09PSB2YWx1ZSAmJiBvcCA9PT0gUkVQTEFDRSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoa2V5KTtcclxuICAgICAgcGF0Y2hlcy5wdXNoKG9wID09PSBSRU1PVkUgPyB7IG9wLCBwYXRoIH0gOiB7IG9wLCBwYXRoLCB2YWx1ZSB9KTtcclxuICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaChcclxuICAgICAgICBvcCA9PT0gQUREID8geyBvcDogUkVNT1ZFLCBwYXRoIH0gOiBvcCA9PT0gUkVNT1ZFID8geyBvcDogQURELCBwYXRoLCB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQob3JpZ1ZhbHVlKSB9IDogeyBvcDogUkVQTEFDRSwgcGF0aCwgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9yaWdWYWx1ZSkgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGdlbmVyYXRlU2V0UGF0Y2hlcyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XHJcbiAgICBsZXQgeyBiYXNlXywgY29weV8gfSA9IHN0YXRlO1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgYmFzZV8uZm9yRWFjaCgodmFsdWUpID0+IHtcclxuICAgICAgaWYgKCFjb3B5Xy5oYXModmFsdWUpKSB7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xyXG4gICAgICAgIHBhdGNoZXMucHVzaCh7XHJcbiAgICAgICAgICBvcDogUkVNT1ZFLFxyXG4gICAgICAgICAgcGF0aCxcclxuICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaW52ZXJzZVBhdGNoZXMudW5zaGlmdCh7XHJcbiAgICAgICAgICBvcDogQURELFxyXG4gICAgICAgICAgcGF0aCxcclxuICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgaSsrO1xyXG4gICAgfSk7XHJcbiAgICBpID0gMDtcclxuICAgIGNvcHlfLmZvckVhY2goKHZhbHVlKSA9PiB7XHJcbiAgICAgIGlmICghYmFzZV8uaGFzKHZhbHVlKSkge1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcclxuICAgICAgICBwYXRjaGVzLnB1c2goe1xyXG4gICAgICAgICAgb3A6IEFERCxcclxuICAgICAgICAgIHBhdGgsXHJcbiAgICAgICAgICB2YWx1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xyXG4gICAgICAgICAgb3A6IFJFTU9WRSxcclxuICAgICAgICAgIHBhdGgsXHJcbiAgICAgICAgICB2YWx1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGkrKztcclxuICAgIH0pO1xyXG4gIH1cclxuICBmdW5jdGlvbiBnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oYmFzZVZhbHVlLCByZXBsYWNlbWVudCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcclxuICAgIHBhdGNoZXMucHVzaCh7XHJcbiAgICAgIG9wOiBSRVBMQUNFLFxyXG4gICAgICBwYXRoOiBbXSxcclxuICAgICAgdmFsdWU6IHJlcGxhY2VtZW50ID09PSBOT1RISU5HID8gdm9pZCAwIDogcmVwbGFjZW1lbnRcclxuICAgIH0pO1xyXG4gICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XHJcbiAgICAgIG9wOiBSRVBMQUNFLFxyXG4gICAgICBwYXRoOiBbXSxcclxuICAgICAgdmFsdWU6IGJhc2VWYWx1ZVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGFwcGx5UGF0Y2hlc18oZHJhZnQsIHBhdGNoZXMpIHtcclxuICAgIHBhdGNoZXMuZm9yRWFjaCgocGF0Y2gpID0+IHtcclxuICAgICAgY29uc3QgeyBwYXRoLCBvcCB9ID0gcGF0Y2g7XHJcbiAgICAgIGxldCBiYXNlID0gZHJhZnQ7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwYXJlbnRUeXBlID0gZ2V0QXJjaHR5cGUoYmFzZSk7XHJcbiAgICAgICAgbGV0IHAgPSBwYXRoW2ldO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcCAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcCAhPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgcCA9IFwiXCIgKyBwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHBhcmVudFR5cGUgPT09IDAgLyogT2JqZWN0ICovIHx8IHBhcmVudFR5cGUgPT09IDEgLyogQXJyYXkgKi8pICYmIChwID09PSBcIl9fcHJvdG9fX1wiIHx8IHAgPT09IFwiY29uc3RydWN0b3JcIikpXHJcbiAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQgKyAzKTtcclxuICAgICAgICBpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIiAmJiBwID09PSBcInByb3RvdHlwZVwiKVxyXG4gICAgICAgICAgZGllKGVycm9yT2Zmc2V0ICsgMyk7XHJcbiAgICAgICAgYmFzZSA9IGdldChiYXNlLCBwKTtcclxuICAgICAgICBpZiAodHlwZW9mIGJhc2UgIT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQgKyAyLCBwYXRoLmpvaW4oXCIvXCIpKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCB0eXBlID0gZ2V0QXJjaHR5cGUoYmFzZSk7XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gZGVlcENsb25lUGF0Y2hWYWx1ZShwYXRjaC52YWx1ZSk7XHJcbiAgICAgIGNvbnN0IGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcclxuICAgICAgc3dpdGNoIChvcCkge1xyXG4gICAgICAgIGNhc2UgUkVQTEFDRTpcclxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIDIgLyogTWFwICovOlxyXG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLnNldChrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgY2FzZSAzIC8qIFNldCAqLzpcclxuICAgICAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIHJldHVybiBiYXNlW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICBjYXNlIEFERDpcclxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogQXJyYXkgKi86XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGtleSA9PT0gXCItXCIgPyBiYXNlLnB1c2godmFsdWUpIDogYmFzZS5zcGxpY2Uoa2V5LCAwLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIGNhc2UgMiAvKiBNYXAgKi86XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICBjYXNlIDMgLyogU2V0ICovOlxyXG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLmFkZCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Vba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgUkVNT1ZFOlxyXG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMSAvKiBBcnJheSAqLzpcclxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zcGxpY2Uoa2V5LCAxKTtcclxuICAgICAgICAgICAgY2FzZSAyIC8qIE1hcCAqLzpcclxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgY2FzZSAzIC8qIFNldCAqLzpcclxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5kZWxldGUocGF0Y2gudmFsdWUpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIHJldHVybiBkZWxldGUgYmFzZVtrZXldO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQgKyAxLCBvcCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGRyYWZ0O1xyXG4gIH1cclxuICBmdW5jdGlvbiBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9iaikge1xyXG4gICAgaWYgKCFpc0RyYWZ0YWJsZShvYmopKVxyXG4gICAgICByZXR1cm4gb2JqO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSlcclxuICAgICAgcmV0dXJuIG9iai5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSk7XHJcbiAgICBpZiAoaXNNYXAob2JqKSlcclxuICAgICAgcmV0dXJuIG5ldyBNYXAoXHJcbiAgICAgICAgQXJyYXkuZnJvbShvYmouZW50cmllcygpKS5tYXAoKFtrLCB2XSkgPT4gW2ssIGRlZXBDbG9uZVBhdGNoVmFsdWUodildKVxyXG4gICAgICApO1xyXG4gICAgaWYgKGlzU2V0KG9iaikpXHJcbiAgICAgIHJldHVybiBuZXcgU2V0KEFycmF5LmZyb20ob2JqKS5tYXAoZGVlcENsb25lUGF0Y2hWYWx1ZSkpO1xyXG4gICAgY29uc3QgY2xvbmVkID0gT2JqZWN0LmNyZWF0ZShnZXRQcm90b3R5cGVPZihvYmopKTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iailcclxuICAgICAgY2xvbmVkW2tleV0gPSBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9ialtrZXldKTtcclxuICAgIGlmIChoYXMob2JqLCBEUkFGVEFCTEUpKVxyXG4gICAgICBjbG9uZWRbRFJBRlRBQkxFXSA9IG9ialtEUkFGVEFCTEVdO1xyXG4gICAgcmV0dXJuIGNsb25lZDtcclxuICB9XHJcbiAgZnVuY3Rpb24gY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQob2JqKSB7XHJcbiAgICBpZiAoaXNEcmFmdChvYmopKSB7XHJcbiAgICAgIHJldHVybiBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9iaik7XHJcbiAgICB9IGVsc2VcclxuICAgICAgcmV0dXJuIG9iajtcclxuICB9XHJcbiAgbG9hZFBsdWdpbihcIlBhdGNoZXNcIiwge1xyXG4gICAgYXBwbHlQYXRjaGVzXyxcclxuICAgIGdlbmVyYXRlUGF0Y2hlc18sXHJcbiAgICBnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc19cclxuICB9KTtcclxufVxyXG5cclxuLy8gc3JjL3BsdWdpbnMvbWFwc2V0LnRzXHJcbmZ1bmN0aW9uIGVuYWJsZU1hcFNldCgpIHtcclxuICBjbGFzcyBEcmFmdE1hcCBleHRlbmRzIE1hcCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHBhcmVudCkge1xyXG4gICAgICBzdXBlcigpO1xyXG4gICAgICB0aGlzW0RSQUZUX1NUQVRFXSA9IHtcclxuICAgICAgICB0eXBlXzogMiAvKiBNYXAgKi8sXHJcbiAgICAgICAgcGFyZW50XzogcGFyZW50LFxyXG4gICAgICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxyXG4gICAgICAgIG1vZGlmaWVkXzogZmFsc2UsXHJcbiAgICAgICAgZmluYWxpemVkXzogZmFsc2UsXHJcbiAgICAgICAgY29weV86IHZvaWQgMCxcclxuICAgICAgICBhc3NpZ25lZF86IHZvaWQgMCxcclxuICAgICAgICBiYXNlXzogdGFyZ2V0LFxyXG4gICAgICAgIGRyYWZ0XzogdGhpcyxcclxuICAgICAgICBpc01hbnVhbF86IGZhbHNlLFxyXG4gICAgICAgIHJldm9rZWRfOiBmYWxzZVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemU7XHJcbiAgICB9XHJcbiAgICBoYXMoa2V5KSB7XHJcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLmhhcyhrZXkpO1xyXG4gICAgfVxyXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcclxuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcclxuICAgICAgaWYgKCFsYXRlc3Qoc3RhdGUpLmhhcyhrZXkpIHx8IGxhdGVzdChzdGF0ZSkuZ2V0KGtleSkgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgcHJlcGFyZU1hcENvcHkoc3RhdGUpO1xyXG4gICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcclxuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgdHJ1ZSk7XHJcbiAgICAgICAgc3RhdGUuY29weV8uc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXy5zZXQoa2V5LCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGRlbGV0ZShrZXkpIHtcclxuICAgICAgaWYgKCF0aGlzLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XHJcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XHJcbiAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcclxuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xyXG4gICAgICBpZiAoc3RhdGUuYmFzZV8uaGFzKGtleSkpIHtcclxuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgZmFsc2UpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXy5kZWxldGUoa2V5KTtcclxuICAgICAgfVxyXG4gICAgICBzdGF0ZS5jb3B5Xy5kZWxldGUoa2V5KTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcclxuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcclxuICAgICAgaWYgKGxhdGVzdChzdGF0ZSkuc2l6ZSkge1xyXG4gICAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcclxuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XHJcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcclxuICAgICAgICBlYWNoKHN0YXRlLmJhc2VfLCAoa2V5KSA9PiB7XHJcbiAgICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgZmFsc2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN0YXRlLmNvcHlfLmNsZWFyKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZvckVhY2goY2IsIHRoaXNBcmcpIHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcclxuICAgICAgbGF0ZXN0KHN0YXRlKS5mb3JFYWNoKChfdmFsdWUsIGtleSwgX21hcCkgPT4ge1xyXG4gICAgICAgIGNiLmNhbGwodGhpc0FyZywgdGhpcy5nZXQoa2V5KSwga2V5LCB0aGlzKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXQoa2V5KSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XHJcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gbGF0ZXN0KHN0YXRlKS5nZXQoa2V5KTtcclxuICAgICAgaWYgKHN0YXRlLmZpbmFsaXplZF8gfHwgIWlzRHJhZnRhYmxlKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodmFsdWUgIT09IHN0YXRlLmJhc2VfLmdldChrZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGRyYWZ0ID0gY3JlYXRlUHJveHkodmFsdWUsIHN0YXRlKTtcclxuICAgICAgcHJlcGFyZU1hcENvcHkoc3RhdGUpO1xyXG4gICAgICBzdGF0ZS5jb3B5Xy5zZXQoa2V5LCBkcmFmdCk7XHJcbiAgICAgIHJldHVybiBkcmFmdDtcclxuICAgIH1cclxuICAgIGtleXMoKSB7XHJcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLmtleXMoKTtcclxuICAgIH1cclxuICAgIHZhbHVlcygpIHtcclxuICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLmtleXMoKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4gdGhpcy52YWx1ZXMoKSxcclxuICAgICAgICBuZXh0OiAoKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCByID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgICAgaWYgKHIuZG9uZSlcclxuICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KHIudmFsdWUpO1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZG9uZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGVudHJpZXMoKSB7XHJcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5rZXlzKCk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHRoaXMuZW50cmllcygpLFxyXG4gICAgICAgIG5leHQ6ICgpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHIgPSBpdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgICBpZiAoci5kb25lKVxyXG4gICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoci52YWx1ZSk7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcclxuICAgICAgICAgICAgdmFsdWU6IFtyLnZhbHVlLCB2YWx1ZV1cclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgWyhEUkFGVF9TVEFURSwgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcclxuICAgIH1cclxuICB9XHJcbiAgZnVuY3Rpb24gcHJveHlNYXBfKHRhcmdldCwgcGFyZW50KSB7XHJcbiAgICByZXR1cm4gbmV3IERyYWZ0TWFwKHRhcmdldCwgcGFyZW50KTtcclxuICB9XHJcbiAgZnVuY3Rpb24gcHJlcGFyZU1hcENvcHkoc3RhdGUpIHtcclxuICAgIGlmICghc3RhdGUuY29weV8pIHtcclxuICAgICAgc3RhdGUuYXNzaWduZWRfID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcclxuICAgICAgc3RhdGUuY29weV8gPSBuZXcgTWFwKHN0YXRlLmJhc2VfKTtcclxuICAgIH1cclxuICB9XHJcbiAgY2xhc3MgRHJhZnRTZXQgZXh0ZW5kcyBTZXQge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBwYXJlbnQpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpc1tEUkFGVF9TVEFURV0gPSB7XHJcbiAgICAgICAgdHlwZV86IDMgLyogU2V0ICovLFxyXG4gICAgICAgIHBhcmVudF86IHBhcmVudCxcclxuICAgICAgICBzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSxcclxuICAgICAgICBtb2RpZmllZF86IGZhbHNlLFxyXG4gICAgICAgIGZpbmFsaXplZF86IGZhbHNlLFxyXG4gICAgICAgIGNvcHlfOiB2b2lkIDAsXHJcbiAgICAgICAgYmFzZV86IHRhcmdldCxcclxuICAgICAgICBkcmFmdF86IHRoaXMsXHJcbiAgICAgICAgZHJhZnRzXzogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcclxuICAgICAgICByZXZva2VkXzogZmFsc2UsXHJcbiAgICAgICAgaXNNYW51YWxfOiBmYWxzZVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemU7XHJcbiAgICB9XHJcbiAgICBoYXModmFsdWUpIHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcclxuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcclxuICAgICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xyXG4gICAgICAgIHJldHVybiBzdGF0ZS5iYXNlXy5oYXModmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdGF0ZS5jb3B5Xy5oYXModmFsdWUpKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICBpZiAoc3RhdGUuZHJhZnRzXy5oYXModmFsdWUpICYmIHN0YXRlLmNvcHlfLmhhcyhzdGF0ZS5kcmFmdHNfLmdldCh2YWx1ZSkpKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBhZGQodmFsdWUpIHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcclxuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcclxuICAgICAgaWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcclxuICAgICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XHJcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xyXG4gICAgICAgIHN0YXRlLmNvcHlfLmFkZCh2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBkZWxldGUodmFsdWUpIHtcclxuICAgICAgaWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcclxuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcclxuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xyXG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XHJcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5Xy5kZWxldGUodmFsdWUpIHx8IChzdGF0ZS5kcmFmdHNfLmhhcyh2YWx1ZSkgPyBzdGF0ZS5jb3B5Xy5kZWxldGUoc3RhdGUuZHJhZnRzXy5nZXQodmFsdWUpKSA6IChcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGZhbHNlXHJcbiAgICAgICkpO1xyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XHJcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XHJcbiAgICAgIGlmIChsYXRlc3Qoc3RhdGUpLnNpemUpIHtcclxuICAgICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XHJcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xyXG4gICAgICAgIHN0YXRlLmNvcHlfLmNsZWFyKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHZhbHVlcygpIHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcclxuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcclxuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xyXG4gICAgICByZXR1cm4gc3RhdGUuY29weV8udmFsdWVzKCk7XHJcbiAgICB9XHJcbiAgICBlbnRyaWVzKCkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xyXG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xyXG4gICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XHJcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5Xy5lbnRyaWVzKCk7XHJcbiAgICB9XHJcbiAgICBrZXlzKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcclxuICAgIH1cclxuICAgIFsoRFJBRlRfU1RBVEUsIFN5bWJvbC5pdGVyYXRvcildKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcclxuICAgIH1cclxuICAgIGZvckVhY2goY2IsIHRoaXNBcmcpIHtcclxuICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLnZhbHVlcygpO1xyXG4gICAgICBsZXQgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XHJcbiAgICAgICAgY2IuY2FsbCh0aGlzQXJnLCByZXN1bHQudmFsdWUsIHJlc3VsdC52YWx1ZSwgdGhpcyk7XHJcbiAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHByb3h5U2V0Xyh0YXJnZXQsIHBhcmVudCkge1xyXG4gICAgcmV0dXJuIG5ldyBEcmFmdFNldCh0YXJnZXQsIHBhcmVudCk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHByZXBhcmVTZXRDb3B5KHN0YXRlKSB7XHJcbiAgICBpZiAoIXN0YXRlLmNvcHlfKSB7XHJcbiAgICAgIHN0YXRlLmNvcHlfID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcclxuICAgICAgc3RhdGUuYmFzZV8uZm9yRWFjaCgodmFsdWUpID0+IHtcclxuICAgICAgICBpZiAoaXNEcmFmdGFibGUodmFsdWUpKSB7XHJcbiAgICAgICAgICBjb25zdCBkcmFmdCA9IGNyZWF0ZVByb3h5KHZhbHVlLCBzdGF0ZSk7XHJcbiAgICAgICAgICBzdGF0ZS5kcmFmdHNfLnNldCh2YWx1ZSwgZHJhZnQpO1xyXG4gICAgICAgICAgc3RhdGUuY29weV8uYWRkKGRyYWZ0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc3RhdGUuY29weV8uYWRkKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBhc3NlcnRVbnJldm9rZWQoc3RhdGUpIHtcclxuICAgIGlmIChzdGF0ZS5yZXZva2VkXylcclxuICAgICAgZGllKDMsIEpTT04uc3RyaW5naWZ5KGxhdGVzdChzdGF0ZSkpKTtcclxuICB9XHJcbiAgbG9hZFBsdWdpbihcIk1hcFNldFwiLCB7IHByb3h5TWFwXywgcHJveHlTZXRfIH0pO1xyXG59XHJcblxyXG4vLyBzcmMvaW1tZXIudHNcclxudmFyIGltbWVyID0gbmV3IEltbWVyMigpO1xyXG52YXIgcHJvZHVjZSA9IGltbWVyLnByb2R1Y2U7XHJcbnZhciBwcm9kdWNlV2l0aFBhdGNoZXMgPSBpbW1lci5wcm9kdWNlV2l0aFBhdGNoZXMuYmluZChcclxuICBpbW1lclxyXG4pO1xyXG52YXIgc2V0QXV0b0ZyZWV6ZSA9IGltbWVyLnNldEF1dG9GcmVlemUuYmluZChpbW1lcik7XHJcbnZhciBzZXRVc2VTdHJpY3RTaGFsbG93Q29weSA9IGltbWVyLnNldFVzZVN0cmljdFNoYWxsb3dDb3B5LmJpbmQoaW1tZXIpO1xyXG52YXIgYXBwbHlQYXRjaGVzID0gaW1tZXIuYXBwbHlQYXRjaGVzLmJpbmQoaW1tZXIpO1xyXG52YXIgY3JlYXRlRHJhZnQgPSBpbW1lci5jcmVhdGVEcmFmdC5iaW5kKGltbWVyKTtcclxudmFyIGZpbmlzaERyYWZ0ID0gaW1tZXIuZmluaXNoRHJhZnQuYmluZChpbW1lcik7XHJcbmZ1bmN0aW9uIGNhc3REcmFmdCh2YWx1ZSkge1xyXG4gIHJldHVybiB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBjYXN0SW1tdXRhYmxlKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmV4cG9ydCB7XHJcbiAgSW1tZXIyIGFzIEltbWVyLFxyXG4gIGFwcGx5UGF0Y2hlcyxcclxuICBjYXN0RHJhZnQsXHJcbiAgY2FzdEltbXV0YWJsZSxcclxuICBjcmVhdGVEcmFmdCxcclxuICBjdXJyZW50LFxyXG4gIGVuYWJsZU1hcFNldCxcclxuICBlbmFibGVQYXRjaGVzLFxyXG4gIGZpbmlzaERyYWZ0LFxyXG4gIGZyZWV6ZSxcclxuICBEUkFGVEFCTEUgYXMgaW1tZXJhYmxlLFxyXG4gIGlzRHJhZnQsXHJcbiAgaXNEcmFmdGFibGUsXHJcbiAgTk9USElORyBhcyBub3RoaW5nLFxyXG4gIG9yaWdpbmFsLFxyXG4gIHByb2R1Y2UsXHJcbiAgcHJvZHVjZVdpdGhQYXRjaGVzLFxyXG4gIHNldEF1dG9GcmVlemUsXHJcbiAgc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHlcclxufTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1tZXIubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/immer/dist/immer.mjs\n");

/***/ })

};
;